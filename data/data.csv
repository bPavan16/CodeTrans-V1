,Pseudo Code,Java,Python
0,Maximum Prefix Sum possible by merging two given arrays | Java Program to implement the above approach ; Stores the maximum prefix sum of the array A [ ] ; Traverse the array A [ ] ; Stores the maximum prefix sum of the array B [ ] ; Traverse the array B [ ] ; Driver code,"```java
public static int maxPrefixSum(int[] A, int[] B) {
    int maxPrefixSumA = 0, maxPrefixSumB = 0;
    for (int i = 0; i < A.length; i++) {
      maxPrefixSumA = Math.max(maxPrefixSumA, maxPrefixSumA + A[i]);
    }
    for (int i = 0; i < B.length; i++) {
      maxPrefixSumB = Math.max(maxPrefixSumB, maxPrefixSumB + B[i]);
    }
    return Math.max(maxPrefixSumA, maxPrefixSumB);
  }
```","```python
def max_prefix_sum(A, B):
  max_prefix_sum_A = 0
  for i in range(len(A)):
    max_prefix_sum_A = max(max_prefix_sum_A, max_prefix_sum_A + A[i])
  max_prefix_sum_B = 0
  for i in range(len(B)):
    max_prefix_sum_B = max(max_prefix_sum_B, max_prefix_sum_B + B[i])
  return max(max_prefix_sum_A, max_prefix_sum_B)
```"
1,Check if a number can be represented as sum of two positive perfect cubes | Java program for the above approach ; Function to check if N can be represented as sum of two perfect cubes or not ; if it is same return true ; ; if the curr smaller than n increment the lo ; if the curr is greater than curr decrement the hi ; Driver Code ; Function call to check if N can be represented as sum of two perfect cubes or not,"```java
public static boolean checkSumOfCubes(int n) {
    int lo = 1;
    int hi = (int) Math.cbrt(n);
    while (lo <= hi) {
        int curr = (int) Math.pow(lo, 3) + (int) Math.pow(hi, 3);
        if (curr == n) {
            return true;
        } else if (curr < n) {
            lo++;
        } else {
            hi--;
        }
    }
    return false;
}
```","```python
def isSumOfCubes(n):
  lo = 1
  hi = int(n ** (1/3)) + 1
  while lo <= hi:
    curr = lo ** 3 + hi ** 3
    if curr == n:
      return True
    elif curr < n:
      lo += 1
    else:
      hi -= 1
  return False
```"
2,"Generate an N | Java program for the above approach ; Function to generate all prime numbers upto 10 ^ 6 ; Initialize sieve [ ] as 1 ; Iterate over the range [ 2 , N ] ; If current element is non - prime ; Make all multiples of i as 0 ; Function to construct an array A [ ] satisfying the given conditions ; Stores the resultant array ; Stores all prime numbers ; Sieve of Erastosthenes ; Append the integer i if it is a prime ; Indicates current position in list of prime numbers ; Traverse the array arr [ ] ; If already filled with another prime number ; If A [ i ] is not filled but A [ ind ] is filled ; Store A [ i ] = A [ ind ] ; If none of them were filled ; To make sure A [ i ] does not affect other values , store next prime number ; Print the resultant array ; Driver Code ; Function Call","```java
public static void generatePrimeNumbers(int N, int[] sieve) {
    for (int i = 2; i <= N; i++) {
      if (sieve[i] != 0) {
        for (int j = i * i; j <= N; j += i) {
          sieve[j] = 0;
        }
      }
    }
  }

  public static int[] constructArray(int N, int[] sieve) {
    int[] A = new int[N];
    int ind = 0;
    for (int i = 0; i < N; i++) {
      if (A[i] == 0) {
        if (sieve[i + 1] != 0) {
          A[i] = i + 1;
          ind++;
        } else if (A[ind] != 0) {
          A[i] = A[ind];
        } else {
          A[i] = ind + 1;
        }
      }
    }
    return A;
  }

  public static void main(String[] args) {
    int N = 1000000;
    int[] sieve = new int[N + 1];
    for (int i = 0; i <= N; i++) {
      sieve[i] = 1;
    }
    generatePrimeNumbers(N, sieve);
    int[] A = constructArray(N, sieve);
    for (int i = 0; i < N; i++) {
      System.out.print(A[i] + "" "");
    }
  }
```","```python
def generate_primes(N):
  sieve = [1] * (N + 1)
  for i in range(2, int(N**0.5) + 1):
    if sieve[i]:
      for j in range(i * i, N + 1, i):
        sieve[j] = 0
  primes = []
  for i in range(2, N + 1):
    if sieve[i]:
      primes.append(i)
  return primes

def construct_array(arr, primes):
  ind = 0
  for i in range(len(arr)):
    if arr[i] != -1:
      continue
    if primes[ind] <= i:
      arr[i] = primes[ind]
      ind += 1
    else:
      if ind < len(primes):
        arr[i] = primes[ind]
  return arr

def main():
  N = 10**6
  primes = generate_primes(N)
  arr = [-1] * N
  arr = construct_array(arr, primes)
  print(arr)

if __name__ == ""__main__"":
  main()
```"
3,Nth natural number after removing all numbers consisting of the digit 9 | Java program for the above approach ; Function to find Nth number in base 9 ; Stores the Nth number ; Iterate while N is greater than 0 ; Update result ; Divide N by 9 ; Multiply p by 10 ; Return result ; Driver Code,"```java
public static int findNthNumberInBase9(int n) {
    int result = 0;
    int p = 1;
    while (n > 0) {
        result += (n % 9) * p;
        n /= 9;
        p *= 10;
    }
    return result;
}
```","```python
def findNthNumber(N):
  result = 0
  p = 1
  while N > 0:
    result += (N % 9) * p
    N //= 9
    p *= 10
  return result
```"
4,Check if an integer is rotation of another given integer | Java implementation of the approach ; Function to check if the integer A is a rotation of the integer B ; Stores the count of digits in A ; Stores the count of digits in B ; If dig1 not equal to dig2 ; Stores position of first digit ; Stores the first digit ; Rotate the digits of the integer ; If A is equal to B ; If A is equal to the initial value of integer A ; Driver Code,"```java
public static boolean isRotation(int A, int B) {
    int dig1 = Integer.toString(A).length();
    int dig2 = Integer.toString(B).length();
    if (dig1 != dig2) {
      return false;
    }
    int pos = 0;
    int firstDigit = A % 10;
    while (A != 0) {
      A /= 10;
      pos++;
    }
    int temp = firstDigit;
    while (pos > 0) {
      temp = temp * 10 + (B % 10);
      B /= 10;
      pos--;
    }
    if (A == B && temp == firstDigit) {
      return true;
    }
    return false;
  }
```","```python
def isRotation(A, B):
  dig1 = len(str(A))
  dig2 = len(str(B))
  if dig1 != dig2:
    return False
  pos = 0
  first = int(str(A)[0])
  while int(str(A)[pos]) != first:
    pos += 1
  A = int(str(A)[pos:] + str(A)[:pos])
  if A == B:
    if A == int(str(A)[pos:] + str(A)[:pos]):
      return True
  return False 
```"
5,"Count of quadruples with product of a pair equal to the product of the remaining pair | Java program for the above approach ; Function to count the number of unique quadruples from an array that satisfies the given condition ; Hashmap to store the product of pairs ; Store the count of required quadruples ; Traverse the array arr [ ] and generate all possible pairs ; Store their product ; Pair ( a , b ) can be used to generate 8 unique permutations with another pair ( c , d ) ; Increment um [ prod ] by 1 ; Print the result ; Driver Code","```java
public static int countQuadruples(int[] arr) {
    HashMap<Integer, Integer> um = new HashMap<>();
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
        for (int j = i + 1; j < arr.length; j++) {
            int prod = arr[i] * arr[j];
            if (um.containsKey(prod)) {
                count += um.get(prod);
            }
            um.put(prod, um.getOrDefault(prod, 0) + 1);
        }
    }
    return count;
}
```","```python
def countQuadruples(arr):
  um = {}
  count = 0
  for i in range(len(arr)):
    for j in range(i + 1, len(arr)):
      prod = arr[i] * arr[j]
      if prod in um:
        um[prod] += 1
      else:
        um[prod] = 1
  for prod in um:
    count += um[prod] * (um[prod] - 1) // 2
  return count
```"
6,"Count ways to place M objects in distinct partitions of N boxes | Java implementation of the above Approach ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize Result ; Update x if x >= MOD to avoid multiplication overflow ; If y is odd , multiply x with result ; y = y \/ 2 ; Change x to x ^ 2 ; Utility function to find the Total Number of Ways ; Number of Even Indexed Boxes ; Number of partitions of Even Indexed Boxes ; Number of ways to distribute objects ; Driver Code ; N = number of boxes M = number of distinct objects ; Function call to get Total Number of Ways","```java
public static long countWays(int N, int M) {
    long evenBoxes = N / 2;
    long partitions = (long) Math.pow(2, evenBoxes);
    return power(2, M) % MOD * partitions % MOD;
}

public static long power(long x, long y) {
    long res = 1;
    x %= MOD;
    while (y > 0) {
      if ((y & 1) != 0) {
        res = (res * x) % MOD;
      }
      y >>= 1;
      x = (x * x) % MOD;
    }
    return res;
  }
  
  public static final long MOD = 1000000007;
  public static void main(String[] args) {
    int N = 4;
    int M = 3;
    System.out.println(countWays(N, M));
  }
```","```python
def count_ways(N, M):
  even_boxes = N // 2
  partitions_even = 1 << even_boxes
  ways = 0
  for i in range(partitions_even):
    partitions_odd = 1 << (N - even_boxes)
    for j in range(partitions_odd):
      count = 0
      for k in range(N):
        if (k % 2 == 0 and (i >> (k // 2)) & 1) or (k % 2 == 1 and (j >> (k // 2)) & 1):
          count += 1
      if count == M:
        ways += 1
  return ways
```"
7,Check if a graph constructed from an array based on given conditions consists of a cycle or not | Java program for the above approach ; Function to check if the graph constructed from given array contains a cycle or not ; Traverse the array ; If arr [ i ] is less than arr [ i - 1 ] and arr [ i ] ; Driver Code ; Given array ; Size of the array,"```java
public boolean hasCycle(int[] arr) {
    if (arr.length < 3) {
      return false;
    }
    for (int i = 2; i < arr.length; i++) {
      if (arr[i] < arr[i - 1] && arr[i] < arr[i - 2]) {
        return true;
      }
    }
    return false;
  }
```","```python
def check_cycle(arr):
  n = len(arr)
  for i in range(1, n):
    if arr[i] < arr[i - 1] and arr[i] < arr[(i + 1) % n]:
      return True
  return False
```"
8,"Maximize first array element by performing given operations at most K times | Java program for the above approach ; Function to maximize the first array element ; Traverse the array ; Initialize cur_val to a [ i ] ; If all operations are not over yet ; If current value is greater than zero ; Incrementing first element of array by 1 ; Decrementing current value of array by 1 ; Decrementing number of operations by i ; If current value is zero , then break ; Print first array element ; Driver Code ; Given array ; Size of the array ; Given K ; Prints the maximum possible value of the first array element","```java
public static int maximizeFirstElement(int[] a, int k) {
    for (int i = 0; i < a.length; i++) {
      int cur_val = a[i];
      if (k > 0) {
        while (cur_val > 0 && k > 0) {
          a[0]++;
          cur_val--;
          k--;
        }
        if (cur_val == 0) {
          break;
        }
      }
    }
    return a[0];
  }
```","```python
def maximize_first_element(a, n, k):
  for i in range(n):
    cur_val = a[i]
    if k > 0:
      while cur_val > 0:
        a[0] += 1
        cur_val -= 1
        k -= 1
        if cur_val == 0:
          break
  return a[0]
```"
9,"Count Non | Java program of the above approach ; Function to find the gcd of the two numbers ; Function to find distinct elements in the array by repeatidely inserting the absolute difference of all possible pairs ; Stores largest element of the array ; Traverse the array , arr [ ] ; Update max_value ; Stores GCD of array ; Traverse the array , arr [ ] ; Update GCDArr ; Stores distinct elements in the array by repeatidely inserting absolute difference of all possible pairs ; Driver code ; Given array arr [ ]","```java
public static int countNon(int[] arr) {
    int max_value = arr[0];
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] > max_value) {
        max_value = arr[i];
      }
    }
    int GCDArr = arr[0];
    for (int i = 1; i < arr.length; i++) {
      GCDArr = gcd(GCDArr, arr[i]);
    }
    int[] distinct = new int[max_value + 1];
    for (int i = 0; i < arr.length; i++) {
      for (int j = i + 1; j < arr.length; j++) {
        distinct[Math.abs(arr[i] - arr[j])] = 1;
      }
    }
    int count = 0;
    for (int i = 0; i < distinct.length; i++) {
      if (distinct[i] == 1) {
        count++;
      }
    }
    return count;
  }
  
  public static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
```","```python
def countNon(arr):
  def gcd(a, b):
    while b:
      a, b = b, a % b
    return a
  
  max_value = max(arr)
  GCDArr = gcd(arr[0], arr[1])
  for i in range(2, len(arr)):
    GCDArr = gcd(GCDArr, arr[i])
  
  distinct = set()
  for i in range(len(arr)):
    for j in range(i + 1, len(arr)):
      distinct.add(abs(arr[i] - arr[j]))
  
  return len(distinct) - max_value + GCDArr 
```"
10,"Minimum row or column swaps required to make every pair of adjacent cell of a Binary Matrix distinct | Java program for the above approach ; Function to return number of moves to convert matrix into chessboard ; Size of the matrix ; Traverse the matrix ; Initialize rowSum to count 1 s in row ; Initialize colSum to count 1 s in column ; To store no . of rows to be corrected ; To store no . of columns to be corrected ; Traverse in the range [ 0 , N - 1 ] ; Check if rows is either N \/ 2 or ( N + 1 ) \/ 2 and return - 1 ; Check if rows is either N \/ 2 or ( N + 1 ) \/ 2 and return - 1 ; Check if N is odd ; Check if column required to be corrected is odd and then assign N - colSwap to colSwap ; Check if rows required to be corrected is odd and then assign N - rowSwap to rowSwap ; Take min of colSwap and N - colSwap ; Take min of rowSwap and N - rowSwap ; Finally return answer ; Driver Code ; Given matrix ; Function Call ; Print answer","```java
public static int getMinimumSwaps(int[][] matrix) {
    int N = matrix.length;
    int rowSum = 0, colSum = 0;
    int rowSwap = 0, colSwap = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            rowSum += matrix[i][j];
            colSum += matrix[j][i];
        }
        if (rowSum != N / 2 && rowSum != (N + 1) / 2) {
            rowSwap++;
        }
        if (colSum != N / 2 && colSum != (N + 1) / 2) {
            colSwap++;
        }
        rowSum = 0;
        colSum = 0;
    }
    if (N % 2 == 1) {
        if (colSwap % 2 != 0) {
            colSwap = N - colSwap;
        }
        if (rowSwap % 2 != 0) {
            rowSwap = N - rowSwap;
        }
    }
    colSwap = Math.min(colSwap, N - colSwap);
    rowSwap = Math.min(rowSwap, N - rowSwap);
    return Math.min(colSwap, rowSwap);
}
```","```python
def min_swaps(matrix):
  N = len(matrix)
  rowSum = [0] * N
  colSum = [0] * N
  rowSwap = 0
  colSwap = 0
  for i in range(N):
    for j in range(N):
      rowSum[i] += matrix[i][j]
      colSum[j] += matrix[i][j]
  for i in range(N):
    if rowSum[i] != N//2 and rowSum[i] != (N+1)//2:
      return -1
    if colSum[i] != N//2 and colSum[i] != (N+1)//2:
      return -1
  if N%2 == 1:
    if colSwap%2 == 1:
      colSwap = N - colSwap
    if rowSwap%2 == 1:
      rowSwap = N - rowSwap
  colSwap = min(colSwap, N - colSwap)
  rowSwap = min(rowSwap, N - rowSwap)
  return colSwap + rowSwap
```"
11,"Minimum number of coins having value equal to powers of 2 required to obtain N | Java program for above approach ; Function to count of set bit in N ; Stores count of set bit in N ; Iterate over the range [ 0 , 31 ] ; If current bit is set ; Update result ; Driver Code","```java
public static int countSetBits(int n) {
    int count = 0;
    for (int i = 0; i < 31; i++) {
      if ((n & (1 << i)) != 0) {
        count++;
      }
    }
    return count;
  }
```","```python
def count_coins(N):
  result = 0
  for i in range(31):
    if (N >> i) & 1:
      result += 1
  return result
```"
12,Evaluate the expression ( N1 * ( N | Java program to implement the above approach ; Function to find the value of the expression ( N ^ 1 * ( N 1 ) ^ 2 * ... * 1 ^ N ) % ( 109 + 7 ) . ; factorial [ i ] : Stores factorial of i ; Base Case for factorial ; Precompute the factorial ; dp [ N ] : Stores the value of the expression ( N ^ 1 * ( N 1 ) ^ 2 * ... * 1 ^ N ) % ( 109 + 7 ) . ; Update dp [ i ] ; Return the answer . ; Driver code ; Function call,"```java
public static long findValue(int N) {
    long[] factorial = new long[N + 1];
    factorial[0] = 1;
    for (int i = 1; i <= N; i++) {
        factorial[i] = (factorial[i - 1] * i) % 1000000007;
    }
    long[] dp = new long[N + 1];
    dp[0] = 1;
    for (int i = 1; i <= N; i++) {
        dp[i] = (dp[i - 1] * factorial[i]) % 1000000007;
    }
    return dp[N];
}
```","```python
def findValue(N):
  MOD = 10**9 + 7
  factorial = [1] * (N + 1)
  for i in range(1, N + 1):
    factorial[i] = (factorial[i - 1] * i) % MOD
  dp = [1] * (N + 1)
  for i in range(1, N + 1):
    dp[i] = (dp[i - 1] * pow(i, i, MOD) * factorial[i - 1]) % MOD
  return dp[N]
```"
13,Chocolate Distribution Problem | Set 2 | Java program for the above approach ; FUnction to print minimum number of candies required ; Distribute 1 chocolate to each ; Traverse from left to right ; Traverse from right to left ; Initialize sum ; Find total sum ; Return sum ; Driver Code ; Given array ; Size of the given array,"```java
public static int minCandies(int[] arr, int n) {
    int[] candies = new int[n];
    Arrays.fill(candies, 1);
    for (int i = 1; i < n; i++) {
        if (arr[i] > arr[i - 1] && candies[i] <= candies[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }
    for (int i = n - 2; i >= 0; i--) {
        if (arr[i] > arr[i + 1] && candies[i] <= candies[i + 1]) {
            candies[i] = candies[i + 1] + 1;
        }
    }
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += candies[i];
    }
    return sum;
}
```","```python
def minCandies(arr, n):
  candies = [1] * n
  for i in range(1, n):
    if arr[i] > arr[i - 1] and candies[i] <= candies[i - 1]:
      candies[i] = candies[i - 1] + 1
  for i in range(n - 2, -1, -1):
    if arr[i] > arr[i + 1] and candies[i] <= candies[i + 1]:
      candies[i] = candies[i + 1] + 1
  sum = 0
  for i in range(n):
    sum += candies[i]
  return sum
```"
14,"Construct longest possible sequence of unique elements with given LCM | Java program to implement the above approach ; Function to construct an array of unique elements whose LCM is N ; Stores array elements whose LCM is N ; Iterate over the range [ 1 , sqrt ( N ) ] ; If N is divisible by i ; Insert i into newArr [ ] ; If N is not perfect square ; Sort the array newArr [ ] ; Print array elements ; Driver Code ; Given N ; Function Call","```java
public static int[] constructArray(int N) {
    int[] newArr = new int[0];
    for (int i = 1; i <= Math.sqrt(N); i++) {
      if (N % i == 0) {
        newArr = Arrays.copyOf(newArr, newArr.length + 1);
        newArr[newArr.length - 1] = i;
        if (i != N / i) {
          newArr = Arrays.copyOf(newArr, newArr.length + 1);
          newArr[newArr.length - 1] = N / i;
        }
      }
    }
    Arrays.sort(newArr);
    return newArr;
  }
```","```python
def construct_array(N):
  newArr = []
  for i in range(1, int(N**0.5) + 1):
    if N % i == 0:
      newArr.append(i)
  if N != int(N**0.5)**2:
    newArr.append(N // newArr[-1])
  newArr.sort()
  return newArr
```"
15,"Count numbers from given range having odd digits at odd places and even digits at even places | Java program to implement the above approach ; Function to calculate 5 ^ p ; Stores the result ; Multiply 5 p times ; Return the result ; Function to count all numbers upto N having odd digits at odd places and even digits at even places ; Stores the count ; Stores the digits of N ; Insert the digits of N ; Reverse the vector to arrange the digits from first to last ; Stores count of digits of n ; Stores the count of numbers with i digits ; If the last digit is reached , subtract numbers eceeding range ; Iterate over all the places ; Stores the digit in the pth place ; Stores the count of numbers having a digit greater than x in the p - th position ; Calculate the count of numbers exceeding the range if p is even ; Calculate the count of numbers exceeding the range if p is odd ; Subtract the count of numbers exceeding the range from total count ; If the parity of p and the parity of x are not same ; Add count of numbers having i digits and satisfies the given conditions ; Return the total count of numbers till n ; Function to calculate the count of numbers from given range having odd digits places and even digits at even places ; Count of numbers in range [ L , R ] = Count of numbers till R - ; Count of numbers till ( L - 1 ) ; Driver Code","```java
public static int countNumbers(int L, int R) {
    return countNumbersTill(R) - countNumbersTill(L - 1);
}

public static int countNumbersTill(int N) {
    int count = 0;
    Vector<Integer> digits = new Vector<>();
    for (int i = N; i > 0; i /= 10) {
        digits.add(i % 10);
    }
    Collections.reverse(digits);
    int n = digits.size();
    int[] dp = new int[n + 1];
    for (int i = 1; i <= n; i++) {
        dp[i] = power5(i);
        if (i == n) {
            dp[i] -= Math.max(0, N - power5(n) + 1);
        }
        for (int p = 1; p <= i; p++) {
            int x = digits.get(p - 1);
            int countNumbersGreaterThanX = power5(i - p);
            if (p % 2 == 0) {
                countNumbersGreaterThanX -= Math.max(0, N - (power5(p - 1) * 10 + power5(i - p)) + 1);
            } else {
                countNumbersGreaterThanX -= Math.max(0, N - (power5(p - 1) * 10 + power5(i - p) * 5) + 1);
            }
            if (p % 2 != x % 2) {
                dp[i] += countNumbersGreaterThanX;
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        count += dp[i];
    }
    return count;
}

public static int power5(int p) {
    int result = 1;
    for (int i = 0; i < p; i++) {
        result *= 5;
    }
    return result;
}
```","```python
def power5(p):
  result = 1
  for _ in range(p):
    result *= 5
  return result

def countNumbers(N):
  count = 0
  digits = []
  for i in str(N):
    digits.append(int(i))
  digits.reverse()
  n = len(digits)
  dp = [0] * (n + 1)
  for i in range(1, n + 1):
    dp[i] = power5(i)
    if i == n:
      dp[i] -= (power5(i) - N)
    for p in range(1, i + 1):
      x = digits[p - 1]
      cnt = 0
      if p % 2 == 0:
        if x > 0:
          cnt = power5(p - 1)
      else:
        if x > 1:
          cnt = power5(p - 1)
      dp[i] -= cnt
      if (p % 2 == 0 and x % 2 == 0) or (p % 2 != 0 and x % 2 != 0):
        dp[i] += dp[p - 1]
  count = dp[n]
  return count

def countInRange(L, R):
  return countNumbers(R) - countNumbers(L - 1)
```"
16,Sum of first N natural numbers with alternate signs | Java program to implement the above approach ; Function to find the sum of first N natural numbers with alternate signs ; Stores sum of alternate sign of first N natural numbers ; If is an even number ; Update alternateSum ; If i is an odd number ; Update alternateSum ; Driver Code,"```java
public static int alternateSum(int n) {
    int alternateSum = 0;
    for (int i = 1; i <= n; i++) {
      if (i % 2 == 0) {
        alternateSum -= i;
      } else {
        alternateSum += i;
      }
    }
    return alternateSum;
  }
```","```python
def sum_alternate_signs(N):
  alternateSum = 0
  for i in range(1, N + 1):
    if i % 2 == 0:
      alternateSum -= i
    else:
      alternateSum += i
  return alternateSum
```"
17,"Sum of all numbers up to N that are co | Java program for the above approach ; Function to return gcd of a and b ; Base Case ; Recursive GCD ; Function to calculate the sum of all numbers till N that are coprime with N ; Stores the resultant sum ; Iterate over [ 1 , N ] ; If gcd is 1 ; Update sum ; Return the final sum ; Driver Code ; Given N ; Function Call","```java
public static int sumOfCoprimes(int N) {
  int sum = 0;
  for (int i = 1; i <= N; i++) {
    if (gcd(i, N) == 1) {
      sum += i;
    }
  }
  return sum;
}

public static int gcd(int a, int b) {
  if (b == 0) {
    return a;
  }
  return gcd(b, a % b);
}
```","```python
def sum_coprimes(N):
  sum = 0
  for i in range(1, N + 1):
    if gcd(i, N) == 1:
      sum += i
  return sum

def gcd(a, b):
  if b == 0:
    return a
  return gcd(b, a % b)
```"
18,Count all distinct pairs of repeating elements from the array for every array element | Java program for the above approach ; Function to print the required count of pairs excluding the current element ; Store the frequency ; Find all the count ; Delete the contribution of each element for equal pairs ; Print the answer ; Driver Code ; Given array arr [ ] ; Function Call,"```java
public static int countDistinctPairs(int[] arr) {
    int n = arr.length;
    int count = 0;
    Map<Integer, Integer> frequency = new HashMap<>();
    for (int i = 0; i < n; i++) {
      frequency.put(arr[i], frequency.getOrDefault(arr[i], 0) + 1);
    }
    for (int i = 0; i < n; i++) {
      int currentElement = arr[i];
      int currentFrequency = frequency.get(currentElement);
      count += (currentFrequency - 1) * (currentFrequency - 2) / 2;
      frequency.put(currentElement, frequency.get(currentElement) - 1);
    }
    return count;
  }
  public static void main(String[] args) {
    int[] arr = {1, 2, 2, 3, 3, 3};
    int result = countDistinctPairs(arr);
    System.out.println(result);
  }
```","```python
def countDistinctPairs(arr):
  n = len(arr)
  freq = {}
  for i in range(n):
    if arr[i] in freq:
      freq[arr[i]] += 1
    else:
      freq[arr[i]] = 1
  count = 0
  for i in range(n):
    temp = freq[arr[i]]
    freq[arr[i]] = 0
    for j in freq:
      if freq[j] > 0:
        count += 1
    freq[arr[i]] = temp
  return count

# Driver Code
arr = [1, 2, 3, 1, 2, 3]
print(countDistinctPairs(arr)) 
```"
19,Mode in a stream of integers ( running integers ) | Java implementation of the above approach ; Function that prints the Mode values ; Map used to map integers to its frequency ; To store the maximum frequency ; To store the element with the maximum frequency ; Loop used to read the elements one by one ; Updates the frequency of that element ; Checks for maximum Number of occurrence ; Updates the maximum frequency ; Updates the Mode ; Driver Code ; Function Call,"```java
import java.util.HashMap;
import java.util.Map;

public class ModeInStream {

    public static void printMode(int[] arr) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        int maxFrequency = 0;
        int mode = 0;
        for (int element : arr) {
            frequencyMap.put(element, frequencyMap.getOrDefault(element, 0) + 1);
            if (frequencyMap.get(element) > maxFrequency) {
                maxFrequency = frequencyMap.get(element);
                mode = element;
            }
        }
        System.out.println(""Mode: "" + mode);
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};
        printMode(arr);
    }
}
```","```python
from collections import defaultdict

def printMode(arr):
  freq = defaultdict(int)
  max_freq = 0
  mode = None
  for num in arr:
    freq[num] += 1
    if freq[num] > max_freq:
      max_freq = freq[num]
      mode = num
  print(mode)
```"
20,Count of distinct numbers formed by shuffling the digits of a large number N | Java program for the above approach ; Recursive function to return the value of ( x ^ n ) % m ; Base Case ; If N is even ; Else N is odd ; Function to find modular inverse of a number x under modulo m ; Using Fermat 's little theorem ; Function to count of numbers formed by shuffling the digits of a large number N ; Modulo value ; Array to store the factorials upto the maximum value of N ; Store factorial of i at index i ; To store count of occurrence of a digit ; Increment the count of digit occured ; Assign the factorial of length of input ; Multiplying result with the modulo multiplicative inverse of factorial of count of i ; Print the result ; Driver code ; Given number as string ; Function call,"```java
public static long power(long x, long n, long m) {
    if (n == 0) {
        return 1;
    } else if (n % 2 == 0) {
        return power((x * x) % m, n / 2, m);
    } else {
        return (x * power((x * x) % m, (n - 1) / 2, m)) % m;
    }
}

public static long modInverse(long x, long m) {
    return power(x, m - 2, m);
}

public static long countDistinctNumbers(String N, long m) {
    long[] fact = new long[N.length() + 1];
    fact[0] = 1;
    for (int i = 1; i <= N.length(); i++) {
        fact[i] = (fact[i - 1] * i) % m;
    }
    int[] count = new int[10];
    for (int i = 0; i < N.length(); i++) {
        count[N.charAt(i) - '0']++;
    }
    long result = fact[N.length()];
    for (int i = 0; i < 10; i++) {
        result = (result * modInverse(fact[count[i]], m)) % m;
    }
    return result;
}

public static void main(String[] args) {
    String N = ""12345"";
    long m = 1000000007;
    System.out.println(countDistinctNumbers(N, m));
}
```","```python
def countDistinctNumbers(N, MOD):
    fact = [1] * (len(N) + 1)
    for i in range(1, len(N) + 1):
        fact[i] = (fact[i - 1] * i) % MOD
    count = [0] * 10
    for i in N:
        count[int(i)] += 1
    result = fact[len(N)]
    for i in range(10):
        result = (result * modularInverse(fact[count[i]], MOD)) % MOD
    return result

def modularInverse(x, m):
    return pow(x, m - 2, m)
```"
21,Find prime factors of Array elements whose sum of exponents is divisible by K | Java program for the above approach ; To store the smallest prime factor till 10 ^ 5 ; Function to compute smallest prime factor array ; Initialize the spf array first element ; Marking smallest prime factor for every number to be itself ; Separately marking smallest prime factor for every even number as 2 ; Checking if i is prime ; Marking SPF for all numbers divisible by i ; Marking spf [ j ] if it is not previously marked ; Function that finds minimum operation ; Create a spf [ ] array ; Map created to store the unique prime numbers ; To store the result ; To store minimum operations ; To store every unique prime number ; Erase 1 as a key because it is not a prime number ; First prime number ; Frequency is divisible by K then insert primeNum in the result [ ] ; Print the elements if it exists ; Driver code ; Given array arr [ ] ; Given K ; Function call,"```java
import java.util.*;
public class PrimeFactors {
    static int[] spf;
    public static void sieveOfEratosthenes(int n) {
        spf = new int[n + 1];
        spf[1] = 1;
        for (int i = 2; i <= n; i++) {
            spf[i] = i;
        }
        for (int i = 2; i * i <= n; i++) {
            if (spf[i] == i) {
                for (int j = i * i; j <= n; j += i) {
                    if (spf[j] == j) {
                        spf[j] = i;
                    }
                }
            }
        }
    }
    public static int minOperations(int[] arr, int k) {
        sieveOfEratosthenes(100000);
        Map<Integer, Integer> primeMap = new HashMap<>();
        List<Integer> result = new ArrayList<>();
        int minOperations = Integer.MAX_VALUE;
        for (int i = 0; i < arr.length; i++) {
            int num = arr[i];
            while (num > 1) {
                int primeNum = spf[num];
                primeMap.put(primeNum, primeMap.getOrDefault(primeNum, 0) + 1);
                num /= primeNum;
            }
        }
        primeMap.remove(1);
        for (Map.Entry<Integer, Integer> entry : primeMap.entrySet()) {
            int primeNum = entry.getKey();
            int frequency = entry.getValue();
            if (frequency % k == 0) {
                result.add(primeNum);
            }
        }
        if (result.size() > 0) {
            Collections.sort(result);
            minOperations = result.get(0);
        }
        return minOperations;
    }
    public static void main(String[] args) {
        int[] arr = {2, 4, 6, 8, 10};
        int k = 2;
        int minOperations = minOperations(arr, k);
        if (minOperations != Integer.MAX_VALUE) {
            System.out.println(minOperations);
        } else {
            System.out.println(""-1"");
        }
    }
}
```","```python
def find_prime_factors(arr, K):
    def sieve_of_eratosthenes(n):
        spf = [i for i in range(n + 1)]
        spf[0] = spf[1] = 1
        for i in range(2, int(n ** 0.5) + 1):
            if spf[i] == i:
                for j in range(i * i, n + 1, i):
                    if spf[j] == j:
                        spf[j] = i
        return spf

    def min_operations(arr, K, spf):
        prime_freq = {}
        result = []
        min_operations = float('inf')
        for num in arr:
            while num > 1:
                prime = spf[num]
                if prime in prime_freq:
                    prime_freq[prime] += 1
                else:
                    prime_freq[prime] = 1
                num //= prime
        prime_freq.pop(1, None)
        for primeNum, freq in prime_freq.items():
            if freq % K == 0:
                result.append(primeNum)
        if result:
            return result
        else:
            return -1

    spf = sieve_of_eratosthenes(10**5)
    return min_operations(arr, K, spf)
```"
22,"Generate first K multiples of N using Bitwise operators | Java program to implement the above approach ; Function to print the first K multiples of N ; Print the value of N * i ; Iterate each bit of N and add Math . pow ( 2 , pos ) , where pos is the index of each set bit ; Check if current bit at pos j is fixed or not ; For next set bit ; Driver Code","```java
public static void printFirstKMultiples(int N, int K) {
    for (int i = 1; i <= K; i++) {
      int multiple = N * i;
      System.out.print(multiple + "" "");
      for (int j = 0; j < 32; j++) {
        if ((N & (1 << j)) != 0) {
          multiple += Math.pow(2, j);
        }
      }
      System.out.println();
    }
  }
```","```python
def print_first_k_multiples(N, K):
  for i in range(1, K + 1):
    multiple = N * i
    print(multiple, end="" "")
    for j in range(31):
      if (multiple >> j) & 1:
        for pos in range(j + 1, 32):
          if (multiple >> pos) & 1:
            multiple += 2 ** pos
            break
```"
23,Least Square Regression Line | Java program to find the regression line ; Function to calculate b ; sum of array x ; sum of array y ; for sum of product of x and y ; sum of square of x ; Function to find the least regression line ; Finding b ; calculating a ; Printing regression line ; Driver code ; statistical data,"```java
public static double calculateB(double[] x, double[] y) {
    double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
    for (int i = 0; i < x.length; i++) {
        sumX += x[i];
        sumY += y[i];
        sumXY += x[i] * y[i];
        sumX2 += x[i] * x[i];
    }
    return (x.length * sumXY - sumX * sumY) / (x.length * sumX2 - sumX * sumX);
}

public static void leastSquaresRegressionLine(double[] x, double[] y) {
    double b = calculateB(x, y);
    double a = (sumY - b * sumX) / x.length;
    System.out.println(""Regression Line: y = "" + a + "" + "" + b + ""x"");
}

public static void main(String[] args) {
    double[] x = {1, 2, 3, 4, 5};
    double[] y = {2, 4, 5, 4, 6};
    leastSquaresRegressionLine(x, y);
}
```","```python
def least_squares_regression_line(x, y):
  n = len(x)
  sum_x = sum(x)
  sum_y = sum(y)
  sum_xy = sum([x[i] * y[i] for i in range(n)])
  sum_x_squared = sum([x[i] ** 2 for i in range(n)])
  b = (n * sum_xy - sum_x * sum_y) / (n * sum_x_squared - sum_x ** 2)
  a = (sum_y - b * sum_x) / n
  return a, b
```"
24,Count of repeating digits in a given Number | Java program for the above approach ; Function that returns the count of repeating digits of the given number ; Initialize a variable to store count of Repeating digits ; Initialize cnt array to store digit count ; Iterate through the digits of N ; Retrieve the last digit of N ; Increase the count of digit ; Remove the last digit of N ; Iterate through the cnt array ; If frequency of digit is greater than 1 ; Increment the count of Repeating digits ; Return count of repeating digit ; Driver Code ; Given array arr [ ] ; Function Call,"```java
public static int countRepeatingDigits(int N) {
    int countRepeatingDigits = 0;
    int[] cnt = new int[10];
    while (N > 0) {
      int digit = N % 10;
      cnt[digit]++;
      N /= 10;
    }
    for (int i = 0; i < 10; i++) {
      if (cnt[i] > 1) {
        countRepeatingDigits++;
      }
    }
    return countRepeatingDigits;
  }
```","```python
def count_repeating_digits(N):
  count = 0
  cnt = [0] * 10
  while N > 0:
    digit = N % 10
    cnt[digit] += 1
    N //= 10
  for i in range(10):
    if cnt[i] > 1:
      count += 1
  return count
```"
25,Find temperature of missing days using given sum and average | Java program for the above approach ; Function for finding the temperature ; Store Day1 - Day2 in diff ; Remaining from s will be Day1 ; Print Day1 and Day2 ; Driver Code ; Functions,"```java
public static void findTemperature(int s, int avg) {
    int diff = avg * 2 - s;
    int day1 = (s - diff) / 2;
    int day2 = day1 + diff;
    System.out.println(day1 + "" "" + day2);
}
```","```python
def find_temperature(s, avg):
  diff = avg * 2 - s
  day1 = (s - diff) / 2
  day2 = day1 + diff
  print(day1, day2)
```"
26,Find two numbers whose sum is N and does not contain any digit as K | Java program for the above approach ; Function to find two numbers whose sum is N and do not contain any digit as k ; Check every number i and ( n - i ) ; Check if i and n - i doesn 't  contain k in them print i and n-i ; Check if flag is 0 then print - 1 ; Driver code ; Given N and K ; Function call,"```java
public static void findNumbers(int n, int k) {
    boolean flag = false;
    for (int i = 1; i <= n / 2; i++) {
      if (!String.valueOf(i).contains(String.valueOf(k)) && !String.valueOf(n - i).contains(String.valueOf(k))) {
        System.out.println(i + "" "" + (n - i));
        flag = true;
        break;
      }
    }
    if (!flag) {
      System.out.println(-1);
    }
  }
```","```python
def find_numbers(N, K):
  for i in range(1, N):
    if str(K) not in str(i) and str(K) not in str(N - i):
      print(i, N - i)
      return
  print(-1)
```"
27,Find the value of P and modular inverse of Q modulo 998244353 | Java implementation to find the value of P . Q - 1 mod 998244353 ; Function to find the value of P * Q ^ - 1 mod 998244353 ; Loop to find the value until the expo is not zero ; Multiply p with q if expo is odd ; Reduce the value of expo by 2 ; Driver code ; Function call,"```java
public static long modInverse(long a, long m) {
    long m0 = m;
    long y = 0, x = 1;
    if (m == 1) {
        return 0;
    }
    while (a > 1) {
        long q = a / m;
        long t = m;
        m = a % m;
        a = t;
        t = y;
        y = x - q * y;
        x = t;
    }
    if (x < 0) {
        x += m0;
    }
    return x;
}

public static long findP(long p, long q, long expo) {
    long result = 1;
    while (expo != 0) {
        if (expo % 2 == 1) {
            result = (result * p) % 998244353;
        }
        expo /= 2;
        p = (p * p) % 998244353;
    }
    return result;
}

public static void main(String[] args) {
    long p = 2, q = 5, expo = 3;
    long qInverse = modInverse(q, 998244353);
    long result = findP(p, qInverse, expo);
    System.out.println(result);
}
```","```python
def modular_inverse(q, mod):
  expo = mod - 2
  p = 1
  while expo != 0:
    if expo % 2 == 1:
      p = (p * q) % mod
    expo //= 2
    q = (q * q) % mod
  return p

def find_value(p, q, mod):
  return (p * modular_inverse(q, mod)) % mod
```"
28,Find two numbers with given sum and maximum possible LCM | Java program of the above approach ; Function that print two numbers with the sum X and maximum possible LCM ; Variables to store the result ; If X is odd ; If X is even ; If floor ( X \/ 2 ) is even ; If floor ( X \/ 2 ) is odd ; Print the result ; Driver code ; Given number ; Function call,"```java
public static void findTwoNumbers(int X) {
  int num1 = 0;
  int num2 = 0;
  if (X % 2 != 0) {
    num1 = X / 2;
    num2 = X / 2 + 1;
  } else {
    if (X / 2 % 2 == 0) {
      num1 = X / 2 - 1;
      num2 = X / 2 + 1;
    } else {
      num1 = X / 2;
      num2 = X / 2;
    }
  }
  System.out.println(num1 + "" "" + num2);
}
```","```python
def find_two_numbers(X):
  a = 0
  b = 0
  if X % 2 != 0:
    a = (X - 1) // 2
    b = (X + 1) // 2
  else:
    if (X // 2) % 2 == 0:
      a = X // 2 - 1
      b = X // 2 + 1
    else:
      a = X // 2
      b = X // 2
  print(a, b)

# Driver code
X = 10
find_two_numbers(X)
```"
29,"Length of longest subarray whose sum is not divisible by integer K | Java program to find the length of the longest subarray whose sum is not divisible by integer K ; Function to find the longest subarray with sum is not divisible by k ; left is the index of the leftmost element that is not divisible by k ; right is the index of the rightmost element that is not divisible by k ; sum of the array ; Find the element that is not multiple of k ; left = - 1 means we are finding the leftmost element that is not divisible by k ; Updating the rightmost element ; Update the sum of the array up to the index i ; Check if the sum of the array is not divisible by k , then return the size of array ; All elements of array are divisible by k , then no such subarray possible so return - 1 ; Length of prefix elements that can be removed ; Length of suffix elements that can be removed ; Return the length of subarray after removing the elements which have lesser number of elements ; Driver code","```java
public static int longestSubarrayNotDivisibleByK(int[] arr, int k) {
    int left = -1;
    int right = -1;
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
      sum += arr[i];
      if (sum % k != 0) {
        right = i;
        if (left == -1) {
          left = i;
        }
      }
    }
    if (right != -1) {
      return right - left + 1;
    }
    return -1;
  }
```","```python
def longestSubarray(arr, k):
  left = -1
  right = -1
  sum = 0
  for i in range(len(arr)):
    sum += arr[i]
    if sum % k != 0 and left == -1:
      left = i
    right = i
  if sum % k != 0:
    return len(arr)
  if left == -1:
    return -1
  prefix = left
  suffix = len(arr) - right - 1
  return len(arr) - min(prefix, suffix)
```"
30,Minimum steps to convert X to Y by repeated division and multiplication | Java implementation to find minimum steps to convert X to Y by repeated division and multiplication ; Check if X is greater than Y then swap the elements ; Check if X equals Y ; Driver code,"```java
public static int minSteps(int X, int Y) {
    if (X > Y) {
      int temp = X;
      X = Y;
      Y = temp;
    }
    if (X == Y) {
      return 0;
    }
    int steps = 0;
    while (X < Y) {
      if (Y % 2 == 0) {
        Y /= 2;
      } else {
        Y = (Y + 1) / 2;
      }
      steps++;
    }
    return steps + (X - Y);
  }
```","```python
def minSteps(X, Y):
  if X > Y:
    X, Y = Y, X
  if X == Y:
    return 0
  count = 0
  while X != Y:
    if X * 2 <= Y:
      X *= 2
      count += 1
    elif Y % 2 == 0 and Y // 2 >= X:
      Y //= 2
      count += 1
    else:
      return -1
  return count
```"
31,"Count quadruplets ( A , B , C , D ) till N such that sum of square of A and B is equal to that of C and D | Java program for the above approach ; Function to count the quadruples ; Counter variable ; Map to store the sum of pair ( a ^ 2 + b ^ 2 ) ; Iterate till N ; Calculate a ^ 2 + b ^ 2 ; Increment the value in map ; Check if this sum was also in a ^ 2 + b ^ 2 ; Return the count ; Driver code ; Given N ; Function call","```java
public static int countQuadruplets(int N) {
    int count = 0;
    Map<Integer, Integer> sumMap = new HashMap<>();
    for (int a = 1; a <= N; a++) {
      for (int b = 1; b <= N; b++) {
        int sum = a * a + b * b;
        sumMap.put(sum, sumMap.getOrDefault(sum, 0) + 1);
        count += sumMap.getOrDefault(sum, 0) - 1;
      }
    }
    return count;
  }
```","```python
def countQuadruplets(n):
  count = 0
  sums = {}
  for a in range(n + 1):
    for b in range(n + 1):
      sum_ab = a**2 + b**2
      sums[sum_ab] = sums.get(sum_ab, 0) + 1
      count += sums.get(sum_ab, 0) - 1
  return count 
```"
32,"Count of distinct index pair ( i , j ) such that element sum of First Array is greater | Java program for the above problem ; function to find the number of pairs satisfying the given cond . ; variables used for traversal ; count variable to store the count of possible pairs ; Nested loop to find out the possible pairs ; Check if the given condition is satisfied or not . If yes then increment the count . ; Return the count value ; Driver Code ; Size of the arrays ; Initialise the arrays ; function call that returns the count of possible pairs","```java
public static int countPairs(int[] arr1, int[] arr2) {
    int count = 0;
    for (int i = 0; i < arr1.length; i++) {
        for (int j = 0; j < arr2.length; j++) {
            if (arr1[i] + arr2[j] > 0) {
                count++;
            }
        }
    }
    return count;
}
```","```python
def countPairs(arr1, arr2, n):
  count = 0
  for i in range(n):
    for j in range(n):
      if arr1[i] + arr2[j] > 0:
        count += 1
  return count
```"
33,"Count of distinct index pair ( i , j ) such that element sum of First Array is greater | Java program of the above approach ; Function to find the number of pairs . ; Array c [ ] where c [ i ] = a [ i ] - b [ i ] ; Sort the array c ; Initialise answer as 0 ; Iterate from index 0 to n - 1 ; If c [ i ] <= 0 then in the sorted array c [ i ] + c [ pos ] can never greater than 0 where pos < i ; Which is equivalent to c [ j ] >= - c [ i ] + 1 ; Add ( i - pos ) to answer ; Return the answer ; Driver code ; Number of elements in a and b ; array a ; array b","```java
public static int countPairs(int[] a, int[] b) {
    int n = a.length;
    int[] c = new int[n];
    for (int i = 0; i < n; i++) {
      c[i] = a[i] - b[i];
    }
    Arrays.sort(c);
    int answer = 0;
    for (int i = 0; i < n; i++) {
      if (c[i] <= 0) {
        int pos = Arrays.binarySearch(c, -c[i] + 1);
        if (pos < 0) {
          pos = -pos - 1;
        }
        answer += (i - pos);
      }
    }
    return answer;
  }
```","```python
def count_pairs(a, b):
  n = len(a)
  c = [a[i] - b[i] for i in range(n)]
  c.sort()
  answer = 0
  for i in range(n):
    if c[i] <= 0:
      pos = i
      while pos < n and c[pos] < -c[i] + 1:
        pos += 1
      answer += (i - pos)
  return answer
```"
34,Find K for every Array element such that at least K prefixes are â ‰¥ K | Java program for the above approach ; Function to find the K - value for every index in the array ; Multiset to store the array in the form of red - black tree ; Iterating over the array ; Inserting the current value in the multiset ; Condition to check if the smallest value in the set is less than it 's size ; Erase the smallest value ; h - index value will be the size of the multiset ; Driver code ; Array ; Size of the array ; Function call,"```java
import java.util.*;
public class KValue {
    public static List<Integer> findK(int[] arr) {
        List<Integer> result = new ArrayList<>();
        TreeSet<Integer> set = new TreeSet<>();
        for (int i = 0; i < arr.length; i++) {
            set.add(arr[i]);
            if (set.first() < set.size()) {
                set.remove(set.first());
            }
            result.add(set.size());
        }
        return result;
    }
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int n = arr.length;
        List<Integer> kValues = findK(arr);
        System.out.println(kValues);
    }
}
```","```python
from collections import Counter

def find_k(arr):
  result = []
  count = Counter()
  for i in range(len(arr)):
    count[arr[i]] += 1
    if min(count) < len(count):
      del count[min(count)]
    result.append(len(count))
  return result
```"
35,"Non | Java program to find Non - repeating Primes ; Function to find count of prime ; Find maximum value in the array ; Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Function to print Non - repeating primes ; Precompute primes using Sieve ; Create HashMap to store frequency of prime numbers ; Traverse through array elements and Count frequencies of all primes ; Traverse through map and print non repeating primes ; Driver code","```java
import java.util.*;
public class NonRepeatingPrimes {
    public static int countPrimes(int n) {
        boolean[] prime = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * p; i <= n; i += p) {
                    prime[i] = false;
                }
            }
        }
        int count = 0;
        for (int i = 2; i <= n; i++) {
            if (prime[i]) {
                count++;
            }
        }
        return count;
    }
    public static void printNonRepeatingPrimes(int[] arr) {
        int n = Arrays.stream(arr).max().getAsInt();
        boolean[] prime = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * p; i <= n; i += p) {
                    prime[i] = false;
                }
            }
        }
        Map<Integer, Integer> freq = new HashMap<>();
        for (int i = 0; i < arr.length; i++) {
            if (prime[arr[i]]) {
                freq.put(arr[i], freq.getOrDefault(arr[i], 0) + 1);
            }
        }
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            if (entry.getValue() == 1) {
                System.out.print(entry.getKey() + "" "");
            }
        }
    }
    public static void main(String[] args) {
        int[] arr = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 2, 3, 5, 7, 11, 13};
        printNonRepeatingPrimes(arr);
    }
}
```","```python
def find_non_repeating_primes(arr):
  n = max(arr)
  prime = [True] * (n + 1)
  prime[0] = prime[1] = False
  for p in range(2, int(n ** 0.5) + 1):
    if prime[p]:
      for i in range(p * p, n + 1, p):
        prime[i] = False
  prime_count = 0
  for i in range(2, n + 1):
    if prime[i]:
      prime_count += 1
  prime_freq = {}
  for num in arr:
    if prime[num]:
      if num in prime_freq:
        prime_freq[num] += 1
      else:
        prime_freq[num] = 1
  for prime_num, freq in prime_freq.items():
    if freq == 1:
      print(prime_num, end="" "")
```"
36,Prefix Product Array | Java program to generate Prefix Product Array ; Function to generate prefix product array ; Update the array with the product of prefixes ; Print the array ; Driver Code,"```java
public static void prefixProduct(int[] arr) {
    int n = arr.length;
    for (int i = 1; i < n; i++) {
      arr[i] = arr[i] * arr[i - 1];
    }
    for (int i = 0; i < n; i++) {
      System.out.print(arr[i] + "" "");
    }
    System.out.println();
  }
```","```python
def prefix_product_array(arr):
  n = len(arr)
  for i in range(1, n):
    arr[i] *= arr[i - 1]
  return arr
```"
37,Count of ways to distribute N items among 3 people with one person receiving maximum | Java program to find the number of ways to distribute N item among three people such that one person always gets the maximum value ; Function to find the number of ways to distribute N items among 3 people ; No distribution possible ; Total number of ways to distribute N items among 3 people ; Store the number of distributions which are not possible ; Count possibilities of two persons receiving the maximum ; If N is divisible by 3 ; Return the final count of ways to distribute ; Driver Code,"```java
public static int countDistribution(int N) {
    if (N < 3) {
        return 0;
    }
    int totalWays = (N + 2) * (N + 1) / 2;
    int impossibleDistributions = 0;
    for (int i = 0; i <= N / 3; i++) {
        impossibleDistributions += (N - 3 * i + 2) * (N - 3 * i + 1) / 2;
    }
    int maxTwo = 0;
    for (int i = N / 3 + 1; i <= N / 2; i++) {
        maxTwo += (N - 2 * i + 1);
    }
    if (N % 3 == 0) {
        return totalWays - impossibleDistributions - maxTwo + 1;
    }
    return totalWays - impossibleDistributions - maxTwo;
}
```","```python
def count_distribution_ways(N):
  if N <= 0:
    return 0
  total_ways = (N + 2) * (N + 1) // 2
  impossible_ways = 0
  if N % 3 == 0:
    impossible_ways = 1
  else:
    for i in range(N // 3 + 1):
      for j in range(N // 3 + 1):
        if 3 * i + 3 * j == N:
          impossible_ways += 1
  return total_ways - impossible_ways
```"
38,Magnanimous Numbers | Java implementation to check if a number is Magnanimous ; Function to check if n is prime ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is Magnanimous or not ; Converting the number to string ; Finding length of string ; Number should not be of single digit ; Loop to find all left and right part of the string ; Driver code,"```java
public static boolean isMagnanimous(int n) {
    if (n < 10) {
        return false;
    }
    String numStr = String.valueOf(n);
    int len = numStr.length();
    for (int i = 1; i <= len / 2 - 2; i++) {
        String left = numStr.substring(0, i);
        String right = numStr.substring(len - i, len);
        if (isPrime(Integer.parseInt(left)) && isPrime(Integer.parseInt(right))) {
            return true;
        }
    }
    return false;
}

public static boolean isPrime(int n) {
    if (n <= 1) {
        return false;
    }
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```","```python
def is_prime(n):
  if n <= 1:
    return False
  for i in range(2, int(n**0.5) + 1):
    if n % i == 0:
      return False
  return True

def is_magnanimous(n):
  if n < 10:
    return False
  n_str = str(n)
  length = len(n_str)
  for i in range(1, length - 1):
    left_part = int(n_str[:i])
    right_part = int(n_str[i:])
    if is_prime(left_part) and is_prime(right_part):
      return True
  return False
```"
39,Honaker Prime Number | Java program for above approach ; Function to precompute the position of every prime number using Sieve ; 0 and 1 are not prime numbers ; Variable to store the position ; Incrementing the position for every prime number ; Function to get sum of digits ; Function to check whether the given number is Honaker Prime number or not ; Driver code ; Precompute the prime numbers till 10 ^ 6 ; Given Number ; Function Call,"```java
import java.util.*;
public class HonakerPrime {
    static int[] primePos = new int[1000001];
    public static void precomputePrimes() {
        Arrays.fill(primePos, 1);
        primePos[0] = primePos[1] = 0;
        for (int i = 2; i * i <= 1000000; i++) {
            if (primePos[i] == 1) {
                for (int j = i * i; j <= 1000000; j += i) {
                    primePos[j] = 0;
                }
            }
        }
        for (int i = 2, pos = 1; i <= 1000000; i++) {
            if (primePos[i] == 1) {
                primePos[i] = pos++;
            }
        }
    }
    public static int sumDigits(int n) {
        int sum = 0;
        while (n > 0) {
            sum += n % 10;
            n /= 10;
        }
        return sum;
    }
    public static boolean isHonakerPrime(int n) {
        if (primePos[n] == 0) {
            return false;
        }
        int sum = sumDigits(n);
        return primePos[sum] != 0;
    }
    public static void main(String[] args) {
        precomputePrimes();
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if (isHonakerPrime(n)) {
            System.out.println(""Honaker Prime"");
        } else {
            System.out.println(""Not Honaker Prime"");
        }
    }
}
```","```python
def is_honaker_prime(n):
  def sieve_of_eratosthenes(limit):
    prime = [True] * (limit + 1)
    prime[0] = prime[1] = False
    for i in range(2, int(limit**0.5) + 1):
      if prime[i]:
        for j in range(i * i, limit + 1, i):
          prime[j] = False
    return prime

  def sum_of_digits(n):
    sum = 0
    while n > 0:
      sum += n % 10
      n //= 10
    return sum

  primes = sieve_of_eratosthenes(10**6)
  prime_positions = [0] * (10**6 + 1)
  position = 1
  for i in range(2, 10**6 + 1):
    if primes[i]:
      prime_positions[i] = position
      position += 1
  return prime_positions[n] == sum_of_digits(n)
```"
40,Check if Matrix sum is prime or not | Java implementation to check if the sum of matrix is prime or not ; Function to check whether a number is prime or not ; Corner case ; Check from 2 to n - 1 ; Function for to find the sum of the given matrix ; Driver Code,"```java
public class MatrixPrimeSum {

    public static boolean isPrime(int n) {
        if (n <= 1) {
            return false;
        }
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static int sumMatrix(int[][] matrix) {
        int sum = 0;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                sum += matrix[i][j];
            }
        }
        return sum;
    }

    public static void main(String[] args) {
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        int sum = sumMatrix(matrix);
        if (isPrime(sum)) {
            System.out.println(""The sum of the matrix is prime: "" + sum);
        } else {
            System.out.println(""The sum of the matrix is not prime: "" + sum);
        }
    }
}
```","```python
def is_prime(n):
  if n <= 1:
    return False
  for i in range(2, int(n**0.5) + 1):
    if n % i == 0:
      return False
  return True

def matrix_sum(matrix):
  sum = 0
  for i in range(len(matrix)):
    for j in range(len(matrix[0])):
      sum += matrix[i][j]
  return sum

def is_matrix_sum_prime(matrix):
  sum = matrix_sum(matrix)
  return is_prime(sum)
```"
41,Sum of sum | Java program to implement the above approach ; Function to find the sum ; Calculate sum - series for every natural number and add them ; Driver code,"```java
public static int sumOfSum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
      sum += i * (i + 1) / 2;
    }
    return sum;
  }
```","```python
def sum_of_sum(n):
  sum = 0
  for i in range(1, n + 1):
    sum += i * (i + 1) // 2
  return sum
```"
42,Sum of sum | Java program to implement the above approach ; Function to find the sum ; Driver code,"```java
public static int sumOfSum(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
      sum += i * (i + 1) / 2;
    }
    return sum;
  }
```","```python
def sum_of_sum(n):
  sum = 0
  for i in range(1, n + 1):
    sum += i * (i + 1) // 2
  return sum
```"
43,"Tetradic Primes | Java implementation to print all Tetradic primes smaller than or equal to N . ; Function to check if the number N having all digits lies in the set ( 0 , 1 , 8 ) ; Function to check if the number N is palindrome ; Function to check if a number N is Tetradic ; Function to generate all primes and checking whether number is Tetradic or not ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all Tetradic prime numbers ; Checking whether the given number is prime Tetradic or not ; Driver Code","```java
public static void printTetradicPrimes(int n) {
    boolean[] prime = new boolean[n + 1];
    Arrays.fill(prime, true);
    for (int p = 2; p * p <= n; p++) {
        if (prime[p]) {
            for (int i = p * p; i <= n; i += p) {
                prime[i] = false;
            }
        }
    }
    for (int i = 2; i <= n; i++) {
        if (prime[i] && isTetradic(i)) {
            System.out.print(i + "" "");
        }
    }
}

private static boolean isTetradic(int n) {
    return isDigitsValid(n) && isPalindrome(n);
}

private static boolean isDigitsValid(int n) {
    while (n > 0) {
        int digit = n % 10;
        if (digit != 0 && digit != 1 && digit != 8) {
            return false;
        }
        n /= 10;
    }
    return true;
}

private static boolean isPalindrome(int n) {
    int reversed = 0;
    int temp = n;
    while (temp > 0) {
        int digit = temp % 10;
        reversed = reversed * 10 + digit;
        temp /= 10;
    }
    return reversed == n;
}
```","```python
def is_tetradic(n):
  return all(digit in '018' for digit in str(n)) and n == int(str(n)[::-1]) and n > 1

def generate_tetradic_primes(n):
  prime = [True] * (n + 1)
  p = 2
  while (p * p <= n):
    if (prime[p]):
      for i in range(p * 2, n + 1, p):
        prime[i] = False
    p += 1
  tetradic_primes = []
  for i in range(2, n + 1):
    if prime[i] and is_tetradic(i):
      tetradic_primes.append(i)
  return tetradic_primes

n = int(input())
tetradic_primes = generate_tetradic_primes(n)
print(tetradic_primes)
```"
44,Astonishing Numbers | Java implementation for the above approach ; Function to concatenate two integers into one ; Convert both the integers to String ; Concatenate both Strings ; Convert the concatenated String to integer ; return the formed integer ; Function to check if N is a Astonishing number ; Loop to find sum of all integers from i till the sum becomes >= n ; variable to store sum of all integers from i to j and check if sum and concatenation equals n or not ; finding concatenation of i and j ; condition for Astonishing number ; Driver Code ; Given Number ; Function Call,"```java
public static int concatenateIntegers(int i, int j) {
    return Integer.parseInt(String.valueOf(i) + String.valueOf(j));
  }
  public static boolean isAstonishing(int n) {
    int sum = 0;
    for (int i = 1; sum < n; i++) {
      for (int j = i; sum < n; j++) {
        sum += j;
        int concat = concatenateIntegers(i, j);
        if (sum == n && concat == n) {
          return true;
        }
      }
      sum = 0;
    }
    return false;
  }
  public static void main(String[] args) {
    int n = 12;
    System.out.println(isAstonishing(n));
  }
```","```python
def concatenate_integers(num1, num2):
  return int(str(num1) + str(num2))

def is_astonishing(n):
  for i in range(1, n):
    sum = i
    j = i + 1
    while sum < n:
      sum += j
      j += 1
    if sum == n and concatenate_integers(i, j) == n:
      return True
  return False

n = int(input())
print(is_astonishing(n))
```"
45,Digitally balanced numbers | Java implementation to check if a number is a digitally balanced number ; Function to check if the digits in the number is the same number of digits ; Loop to iterate over the digits of the number N ; Loop to iterate over the map ; Driver Code ; function to check,"```java
import java.util.HashMap;
import java.util.Map;

public class DigitallyBalanced {

    public static boolean isDigitallyBalanced(int N) {
        Map<Integer, Integer> digitCount = new HashMap<>();
        while (N > 0) {
            int digit = N % 10;
            digitCount.put(digit, digitCount.getOrDefault(digit, 0) + 1);
            N /= 10;
        }
        int count = digitCount.values().stream().distinct().count();
        return count == 1;
    }

    public static void main(String[] args) {
        int N = 1221;
        if (isDigitallyBalanced(N)) {
            System.out.println(""Digitally balanced"");
        } else {
            System.out.println(""Not digitally balanced"");
        }
    }
}
```","```python
def isDigitallyBalanced(N):
  digitCounts = {}
  for digit in str(N):
    if digit in digitCounts:
      digitCounts[digit] += 1
    else:
      digitCounts[digit] = 1
  for count in digitCounts.values():
    if count != len(digitCounts):
      return False
  return True
```"
46,Sum of series formed by difference between product and sum of N natural numbers | Java program to implement the above approach ; Function to calculate the sum upto Nth term ; Stores the sum of the series ; Stores the product of natural numbers upto the current term ; Stores the sum of natural numbers upto the upto current term ; Generate the remaining terms and calculate sum ; Update the sum ; Return the sum ; Driver code,"```java
public static int sumOfSeries(int N) {
    int sum = 0;
    int product = 1;
    int naturalSum = 0;
    for (int i = 1; i <= N; i++) {
        product *= i;
        naturalSum += i;
        sum += product - naturalSum;
    }
    return sum;
}
```","```python
def sum_of_series(n):
  sum = 0
  product = 1
  natural_sum = 0
  for i in range(1, n + 1):
    product *= i
    natural_sum += i
    sum += product - natural_sum
  return sum
```"
47,Count of elements not divisible by any other elements of Array | Java program for the above approach ; Function to count the number of elements of array which are not divisible by any other element in the array arr [ ] ; Iterate over the array ; Check if the element is itself or not ; Check for divisibility ; Return the final result ; Driver Code ; Given array ; Function call,"```java
public static int countNonDivisible(int[] arr) {
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
      boolean divisible = false;
      for (int j = 0; j < arr.length; j++) {
        if (i != j && arr[i] % arr[j] == 0) {
          divisible = true;
          break;
        }
      }
      if (!divisible) {
        count++;
      }
    }
    return count;
  }
```","```python
def count_elements(arr):
  count = 0
  for i in range(len(arr)):
    divisible = False
    for j in range(len(arr)):
      if i != j and arr[i] % arr[j] == 0:
        divisible = True
        break
    if not divisible:
      count += 1
  return count
```"
48,Smallest N digit number divisible by N | Java program for the above approach ; Function to find the smallest N - digit number divisible by N ; Return the smallest N - digit number calculated using above formula ; Driver Code ; Given N ; Function Call,"```java
public static int smallestNdigitDivisibleByN(int n) {
    return (int) Math.pow(10, n - 1) + (n - (int) Math.pow(10, n - 1) % n) % n;
}
```","```python
def smallest_n_digit_number_divisible_by_n(n):
  return (10**(n-1)) + (n - (10**(n-1)) % n)
```"
49,Count pairs in an array containing at least one even value | Java implementation to Count pairs in an array such that each pair contains at least one even element ; Function to count the pairs in the array such as there is at least one even element in each pair ; Generate all possible pairs and increment then count if the condition is satisfied ; Driver code ; Function Call,"```java
public static int countPairs(int[] arr) {
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[i] % 2 == 0 || arr[j] % 2 == 0) {
                count++;
            }
        }
    }
    return count;
}
```","```python
def count_pairs(arr):
  count = 0
  n = len(arr)
  for i in range(n):
    for j in range(i + 1, n):
      if (arr[i] % 2 == 0 or arr[j] % 2 == 0):
        count += 1
  return count
```"
50,Count pairs in an array containing at least one even value | Java implementation to Count pairs in an array such that each pair contains at least one even element ; Function to count the pairs in the array such as there is at least one even element in each pair ; store count of even and odd elements ; check element is even or odd ; Driver Code,"```java
public static int countPairs(int[] arr) {
    int evenCount = 0;
    int oddCount = 0;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] % 2 == 0) {
            evenCount++;
        } else {
            oddCount++;
        }
    }
    return Math.min(evenCount, oddCount);
}
```","```python
def countPairs(arr, n):
  evenCount = 0
  oddCount = 0
  for i in range(n):
    if arr[i] % 2 == 0:
      evenCount += 1
    else:
      oddCount += 1
  return min(evenCount, oddCount)
```"
51,"Giuga Numbers | Java program for the above approach ; Function to check if n is a composite number ; Corner cases ; This is checked to skip middle 5 numbers ; Function to check if N is a Giuga Number ; N should be composite to be a Giuga Number ; Print the number of 2 s that divide n ; N must be odd at this point . So we can skip one element ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number > 2 ; Driver code ; Given Number N ; Function Call","```java
public static boolean isGiugaNumber(int n) {
    if (!isComposite(n)) {
        return false;
    }
    int count = 0;
    while (n % 2 == 0) {
        count++;
        n /= 2;
    }
    if (n == 1) {
        return false;
    }
    int i = 3;
    while (i * i <= n) {
        if (n % i == 0) {
            System.out.print(i + "" "");
            n /= i;
        } else {
            i += 2;
        }
    }
    if (n > 1) {
        System.out.print(n + "" "");
    }
    return (count + 1) == (n - 1);
}

public static boolean isComposite(int n) {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return false;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return true;
    }
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return true;
        }
    }
    return false;
}

public static void main(String[] args) {
    int N = 30;
    System.out.println(isGiugaNumber(N));
}
```","```python
def is_giuga(n):
  if n <= 1:
    return False
  if n == 2:
    return False
  if n % 2 == 0:
    count = 0
    while n % 2 == 0:
      count += 1
      n //= 2
    if n == 1:
      return False
    if count == 1:
      return False
  i = 3
  while i * i <= n:
    if n % i == 0:
      return False
    i += 2
  i = 3
  while i < n:
    if n % i == 0:
      return (n - 1) % i == 0
    i += 2
  return False
```"
52,"Droll Numbers | Java program for the above approach ; Function to check droll numbers ; To store sum of even prime factors ; To store sum of odd prime factors ; Add the number of 2 s that divide n in sum_even ; N must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Condition to check droll number ; Driver code ; Given Number N ; Function Call","```java
public static boolean isDroll(int n) {
  if (n <= 1) {
    return false;
  }
  int sum_even = 0;
  int sum_odd = 0;
  if (n % 2 == 0) {
    sum_even += 2;
    n /= 2;
  }
  for (int i = 3; i * i <= n; i += 2) {
    while (n % i == 0) {
      if (i % 2 == 0) {
        sum_even += i;
      } else {
        sum_odd += i;
      }
      n /= i;
    }
  }
  if (n > 2) {
    if (n % 2 == 0) {
      sum_even += n;
    } else {
      sum_odd += n;
    }
  }
  return sum_even == sum_odd;
}
```","```python
def is_droll(n):
  sum_even = 0
  sum_odd = 0
  while n % 2 == 0:
    sum_even += 2
    n //= 2
  i = 3
  while i * i <= n:
    if n % i == 0:
      if i % 2 == 0:
        sum_even += i
      else:
        sum_odd += i
      n //= i
    else:
      i += 2
  if n > 2:
    if n % 2 == 0:
      sum_even += n
    else:
      sum_odd += n
  return sum_even == sum_odd
```"
53,Count all pairs of divisors of a number N whose sum is coprime with N | Java program to count all pairs of divisors such that their sum is coprime with N ; Function to calculate GCD ; Function to count all valid pairs ; Initialize count ; Check if sum of pair and n are coprime ; Return the result ; Driver code,"```java
static int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}

static int countValidPairs(int n) {
    int count = 0;
    for (int i = 1; i <= Math.sqrt(n); i++) {
        if (n % i == 0) {
            if (gcd(i + n / i, n) == 1) {
                count++;
            }
            if (i != n / i && gcd(n / i + i, n) == 1) {
                count++;
            }
        }
    }
    return count;
}
```","```python
def gcd(a, b):
  while b:
    a, b = b, a % b
  return a

def count_valid_pairs(n):
  count = 0
  for i in range(1, n + 1):
    if n % i == 0:
      for j in range(i, n + 1):
        if n % j == 0 and gcd(i + j, n) == 1:
          count += 1
  return count
```"
54,Check if A can be converted to B by reducing with a Prime number | Java implementation to find if it is possible to make a equal to b ; Function to find if it is possible to make A equal to B ; Driver Code ; Function Call,"```java
import java.util.*;
class Solution {
    public static boolean isPossible(int a, int b) {
        if (a == b) {
            return true;
        }
        if (a < b) {
            return false;
        }
        for (int i = 2; i * i <= a; i++) {
            if (a % i == 0) {
                if (isPossible(a / i, b)) {
                    return true;
                }
            }
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        if (isPossible(a, b)) {
            System.out.println(""Yes"");
        } else {
            System.out.println(""No"");
        }
    }
}
```","```python
def can_convert(a, b):
  if a == b:
    return True
  if a < b:
    return False
  for i in range(2, int(a**0.5) + 1):
    if a % i == 0 and a // i <= b:
      return can_convert(a // i, b)
  return False

def main():
  a = int(input(""Enter the value of A: ""))
  b = int(input(""Enter the value of B: ""))
  if can_convert(a, b):
    print(""Yes, A can be converted to B by reducing with a prime number"")
  else:
    print(""No, A cannot be converted to B by reducing with a prime number"")

if __name__ == ""__main__"":
  main()
```"
55,Maximize sum of minimum difference of divisors of nodes in N | Java program to maximize the sum of minimum difference of divisors of nodes in an n - ary tree ; Array to store the result at each node ; Function to get minimum difference between the divisors of a number ; Iterate from square root of N to N ; return absolute difference ; DFS function to calculate the maximum sum ; Store the min difference ; Add the maximum of all children to sub [ u ] ; Return maximum sum of node ' u ' to its parent ; Driver code,"```java
class Node {
    int data;
    List<Node> children;

    Node(int data) {
        this.data = data;
        this.children = new ArrayList<>();
    }
}

class Solution {
    int[] sub;

    int minDiff(int n) {
        int minDiff = Integer.MAX_VALUE;
        for (int i = (int) Math.sqrt(n); i <= n; i++) {
            if (n % i == 0) {
                minDiff = Math.min(minDiff, Math.abs(i - n / i));
            }
        }
        return minDiff;
    }

    int dfs(Node u) {
        sub[u.data] = minDiff(u.data);
        for (Node child : u.children) {
            sub[u.data] += dfs(child);
        }
        return Math.max(sub[u.data], 0);
    }

    int maxSum(Node root, int n) {
        sub = new int[n + 1];
        return dfs(root);
    }

    public static void main(String[] args) {
        // Your code to create the tree and call the maxSum function
    }
}
```","```python
def get_min_diff(n):
  min_diff = float('inf')
  for i in range(2, int(n**0.5) + 1):
    if n % i == 0:
      min_diff = min(min_diff, abs(i - n // i))
  if min_diff == float('inf'):
    return 0
  return min_diff

def dfs(u, adj, sub):
  min_diff = get_min_diff(u)
  for v in adj[u]:
    sub[u] += max(0, dfs(v, adj, sub))
  sub[u] += min_diff
  return sub[u]

def max_sum_min_diff(n, adj):
  sub = [0] * (n + 1)
  return dfs(1, adj, sub)
```"
56,Program to check if N is a Centered Cubic Number | Java program to check if N is a centered cubic number ; Function to check if N is a centered cubic number ; Iterating from 1 ; Infinite loop ; Finding ith_term ; Checking if the number N is a centered cube number ; If ith_term > N then N is not a centered cube number ; Incrementing i ; Driver code ; Function call,"```java
public static boolean isCenteredCubicNumber(int N) {
    int i = 1;
    while (true) {
        int ith_term = i * i * i + (i - 1) * (i - 1) * (i - 1);
        if (ith_term == N) {
            return true;
        } else if (ith_term > N) {
            return false;
        }
        i++;
    }
}
```","```python
def is_centered_cubic(n):
  i = 1
  while True:
    ith_term = i**3 + 3 * i**2 + 3 * i + 1
    if ith_term > n:
      return False
    if ith_term == n:
      return True
    i += 1
```"
57,Product of N terms of a given Geometric series | Java program for the above approach ; Function to calculate product of geometric series ; Initialise final product with 1 ; Multiply product with each term stored in a ; Return the final product ; Driver Code ; Given first term and common ratio ; Number of terms ; Function Call,"```java
public static double productOfGeometricSeries(double a, double r, int n) {
    double product = 1;
    for (int i = 0; i < n; i++) {
      product *= a;
      a *= r;
    }
    return product;
  }
```","```python
def product_of_geometric_series(a, r, n):
  product = 1
  for i in range(n):
    product *= a
    a *= r
  return product
```"
58,Sum of given N fractions in reduced form | Java program for the above approach ; Function to find GCD of a & b using Euclid Lemma ; Base case ; Function to find the LCM of all elements in arr [ ] ; Initialize result ; Iterate arr [ ] to find LCM ; Return the final LCM ; Function to find the sum of N fraction in reduced form ; To store the sum of all final numerators ; Find the LCM of all denominator ; Find the sum of all N numerators & denominators ; Add each fraction one by one ; Find GCD of final numerator and denominator ; Convert into reduced form by dividing from GCD ; Print the final fraction ; Driver code ; Given N ; Given numerator ; Given denominator ; Function call,"```java
public static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
  
  public static int lcm(int[] arr) {
    int result = arr[0];
    for (int i = 1; i < arr.length; i++) {
      result = (result * arr[i]) / gcd(result, arr[i]);
    }
    return result;
  }
  
  public static void sumOfFractions(int n, int[] numerator, int[] denominator) {
    int sumNumerator = 0;
    int lcmDenominator = lcm(denominator);
    for (int i = 0; i < n; i++) {
      sumNumerator += (lcmDenominator / denominator[i]) * numerator[i];
    }
    int gcdResult = gcd(sumNumerator, lcmDenominator);
    System.out.println(sumNumerator / gcdResult + ""/"" + lcmDenominator / gcdResult);
  }
  
  public static void main(String[] args) {
    int n = 5;
    int[] numerator = {1, 2, 3, 4, 5};
    int[] denominator = {2, 3, 4, 5, 6};
    sumOfFractions(n, numerator, denominator);
  }
```","```python
def gcd(a, b):
  if b == 0:
    return a
  return gcd(b, a % b)

def lcm(arr):
  result = arr[0]
  for i in range(1, len(arr)):
    result = (result * arr[i]) // gcd(result, arr[i])
  return result

def sum_of_fractions(n, numerator, denominator):
  sum_numerator = 0
  lcm_denominator = lcm(denominator)
  for i in range(n):
    sum_numerator += numerator[i] * (lcm_denominator // denominator[i])
  gcd_value = gcd(sum_numerator, lcm_denominator)
  return sum_numerator // gcd_value, lcm_denominator // gcd_value

n = int(input())
numerator = list(map(int, input().split()))
denominator = list(map(int, input().split()))
final_numerator, final_denominator = sum_of_fractions(n, numerator, denominator)
print(final_numerator, ""/"", final_denominator)
```"
59,Minimum LCM of all pairs in a given array | Java program to find minimum possible lcm from any pair ; Function to compute GCD of two numbers ; Function that return minimum possible lcm from any pair ; Fix the ith element and iterate over all the array to find minimum LCM ; Driver code,"```java
static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
  
  static int minLCM(int[] arr, int n) {
    int minLCM = Integer.MAX_VALUE;
    for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
        int lcm = (arr[i] * arr[j]) / gcd(arr[i], arr[j]);
        minLCM = Math.min(minLCM, lcm);
      }
    }
    return minLCM;
  }
```","```python
def gcd(a, b):
  while b:
    a, b = b, a % b
  return a

def min_lcm_pair(arr):
  n = len(arr)
  min_lcm = float('inf')
  for i in range(n):
    for j in range(i + 1, n):
      lcm = (arr[i] * arr[j]) // gcd(arr[i], arr[j])
      min_lcm = min(min_lcm, lcm)
  return min_lcm
```"
60,"Find two numbers whose difference of fourth power is equal to N | Java implementation to find the values of x and y for the given equation with integer N ; Function which find required x & y ; Upper limit of x & y , if such x & y exists ; num1 stores x ^ 4 ; num2 stores y ^ 4 ; If condition is satisfied the print and return ; If no such pair exists ; Driver code","```java
public static void findXY(int N) {
    for (int x = 1; x <= Math.pow(N, 0.25) + 1; x++) {
        for (int y = 1; y <= Math.pow(N, 0.25) + 1; y++) {
            long num1 = (long) Math.pow(x, 4);
            long num2 = (long) Math.pow(y, 4);
            if (Math.abs(num1 - num2) == N) {
                System.out.println(""x: "" + x + "", y: "" + y);
                return;
            }
        }
    }
    System.out.println(""No such pair exists."");
}
```","```python
def find_numbers(N):
  for x in range(1, int(N**0.25) + 1):
    num1 = x**4
    for y in range(1, x + 1):
      num2 = y**4
      if abs(num1 - num2) == N:
        print(x, y)
        return
  print(""No such pair exists"")
```"
61,"Check if count of even divisors of N is equal to count of odd divisors | Java code for the above program ; Function to check if count of even and odd divisors are equal ; To store the count of even factors and odd factors ; Loop till [ 1 , sqrt ( N ) ] ; If divisors are equal add only one ; Check for even divisor ; Odd divisor ; Check for both divisor i . e . , i and N \/ i ; Check if i is odd or even ; Check if N \/ i is odd or even ; Return true if count of even_div and odd_div are equals ; Driver code ; Given number ; Function call","```java
boolean checkDivisors(int N) {
    int even_div = 0;
    int odd_div = 0;
    for (int i = 1; i * i <= N; i++) {
        if (N % i == 0) {
            if (i == N / i) {
                if (i % 2 == 0) {
                    even_div++;
                } else {
                    odd_div++;
                }
            } else {
                if (i % 2 == 0) {
                    even_div++;
                } else {
                    odd_div++;
                }
                if ((N / i) % 2 == 0) {
                    even_div++;
                } else {
                    odd_div++;
                }
            }
        }
    }
    return even_div == odd_div;
}
```","```python
def check_divisors(N):
  even_div = 0
  odd_div = 0
  for i in range(1, int(N**0.5) + 1):
    if N % i == 0:
      if i == N // i:
        if i % 2 == 0:
          even_div += 1
        else:
          odd_div += 1
      else:
        if i % 2 == 0:
          even_div += 1
        else:
          odd_div += 1
        if (N // i) % 2 == 0:
          even_div += 1
        else:
          odd_div += 1
  return even_div == odd_div

# Driver code
N = 12
print(check_divisors(N))
```"
62,Check if N is a Balanced Prime number or not | Java program to check if a given number is Balanced prime ; Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a Balanced prime ; If n is not a prime number or n is the first prime then return false ; Initialize previous_prime to n - 1 and next_prime to n + 1 ; Find next prime number ; Find previous prime number ; Arithmetic mean ; If n is a weak prime ; Driver code,"```java
public static boolean isBalancedPrime(int n) {
    if (!isPrime(n) || n == 2) {
        return false;
    }
    int previous_prime = n - 1;
    int next_prime = n + 1;
    while (!isPrime(next_prime)) {
        next_prime++;
    }
    while (!isPrime(previous_prime)) {
        previous_prime--;
    }
    int arithmetic_mean = (previous_prime + next_prime) / 2;
    return n == arithmetic_mean;
}

public static boolean isPrime(int n) {
    if (n <= 1) {
        return false;
    }
    if (n <= 3) {
        return true;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return false;
    }
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    return true;
}

public static void main(String[] args) {
    int n = 5;
    if (isBalancedPrime(n)) {
        System.out.println(n + "" is a Balanced prime number"");
    } else {
        System.out.println(n + "" is not a Balanced prime number"");
    }
}
```","```python
def isBalancedPrime(n):
  if n <= 1:
    return False
  for i in range(2, int(n**0.5) + 1):
    if n % i == 0:
      return False
  if n == 2:
    return False
  previous_prime = n - 1
  while previous_prime > 1:
    if isPrime(previous_prime):
      break
    previous_prime -= 1
  next_prime = n + 1
  while next_prime <= 2 * n:
    if isPrime(next_prime):
      break
    next_prime += 1
  arithmetic_mean = (previous_prime + next_prime) / 2
  return n == arithmetic_mean

def isPrime(n):
  if n <= 1:
    return False
  for i in range(2, int(n**0.5) + 1):
    if n % i == 0:
      return False
  return True
```"
63,Count of nodes having odd divisors in the given subtree for Q queries | Java implementation to count the number of nodes having odd number of divisors for each query ; Adjacency list for tree . ; Array for values and answer at ith node . ; Function to check whether N has odd divisors or not ; DFS function to pre - compute the answers ; Initialize the count ; Repeat for every child ; Increase the count if current node has odd number of divisors ; Driver Code ; Adjacency List ; Function call,"```java
import java.util.*;
class Solution {
    static ArrayList<ArrayList<Integer>> adj;
    static int[] val, ans;
    static int N;

    public static boolean isOddDivisors(int n) {
        int count = 0;
        for (int i = 1; i * i <= n; i++) {
            if (n % i == 0) {
                count++;
                if (i * i != n) {
                    count++;
                }
            }
        }
        return count % 2 != 0;
    }

    public static void dfs(int node, int parent) {
        ans[node] = isOddDivisors(val[node]) ? 1 : 0;
        for (int child : adj.get(node)) {
            if (child != parent) {
                dfs(child, node);
                ans[node] += ans[child];
            }
        }
    }

    public static int[] countOddDivisors(int n, int[][] edges, int[] values, int[][] queries) {
        N = n;
        adj = new ArrayList<>();
        val = values;
        ans = new int[n];
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int[] edge : edges) {
            adj.get(edge[0]).add(edge[1]);
            adj.get(edge[1]).add(edge[0]);
        }
        dfs(0, -1);
        int[] result = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            result[i] = ans[queries[i][0]];
        }
        return result;
    }
}
```","```python
def count_odd_divisors(n):
  return int(n**(1/2)) % 2

def dfs(node, parent, adj, values, answer):
  count = 0
  for child in adj[node]:
    if child != parent:
      count += dfs(child, node, adj, values, answer)
  if count_odd_divisors(values[node]):
    count += 1
  answer[node] = count
  return count

def count_odd_divisors_queries(n, q, adj, values):
  answer = [0] * (n + 1)
  dfs(1, -1, adj, values, answer)
  return answer
```"
64,Minimum Cost to make all array elements equal using given operations | Java implementation to find the minimum cost to make all array elements equal ; Checks if the value is less than middle element of the array ; Function that returns the cost of making all elements equal to current element ; Compute the lower bound of current element ; Calculate the requirement of add operation ; Calculate the requirement of subtract operation ; Compute minimum of left and right ; Computing the total cost of add and subtract operations ; Function that prints minimum cost of making all elements equal ; Sort the given array ; Calculate minimum from a + r and m ; Compute prefix sum and store in pref array ; Find the minimum cost from the given elements ; Finding the minimum cost from the other cases where minimum cost can occur ; Printing the minimum cost of making all elements equal ; Driver Code ; Function Call,"```java
import java.util.*;
public class MinimumCostEqualArray {

    static int minCost(int[] arr, int n) {
        Arrays.sort(arr);
        int m = arr[n / 2];
        int a = 0, r = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] < m) {
                a += m - arr[i];
            } else if (arr[i] > m) {
                r += arr[i] - m;
            }
        }
        return Math.min(a, r);
    }

    static int minCostToMakeEqual(int[] arr, int n) {
        if (n == 1) {
            return 0;
        }
        int cost = Integer.MAX_VALUE;
        int[] pref = new int[n];
        pref[0] = arr[0];
        for (int i = 1; i < n; i++) {
            pref[i] = pref[i - 1] + arr[i];
        }
        for (int i = 0; i < n; i++) {
            int left = 0, right = 0;
            if (i > 0) {
                left = pref[i - 1] - (i) * arr[i];
            }
            if (i < n - 1) {
                right = (n - i - 1) * arr[i] - (pref[n - 1] - pref[i]);
            }
            cost = Math.min(cost, Math.min(left + right, minCost(arr, n)));
        }
        return cost;
    }

    public static void main(String[] args) {
        int[] arr = {1, 10, 5};
        int n = arr.length;
        System.out.println(""Minimum cost to make all array elements equal: "" + minCostToMakeEqual(arr, n));
    }
}
```","```python
def minCostToMakeEqual(arr, n):
  arr.sort()
  m = arr[n // 2]
  a = 0
  r = 0
  pref = [0] * (n + 1)
  for i in range(n):
    pref[i + 1] = pref[i] + arr[i]
  minCost = float('inf')
  for i in range(n):
    if arr[i] < m:
      a += m - arr[i]
    else:
      r += arr[i] - m
  minCost = min(minCost, a + r)
  for i in range(n):
    a = m * (i + 1) - pref[i + 1]
    r = pref[n] - pref[i + 1] - m * (n - i - 1)
    minCost = min(minCost, a + r)
  return minCost

def printMinCost(arr, n):
  print(minCostToMakeEqual(arr, n))

arr = [1, 2, 3, 4, 5]
n = len(arr)
printMinCost(arr, n)
```"
65,Count of integers up to N which represent a Binary number | Java program to count the number of integers upto N which are of the form of binary representations ; Function to return the count ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver Code,"```java
public static int countBinaryIntegers(int n) {
    int ctr = 0;
    int ans = 0;
    while (n > 0) {
      if (n % 10 == 1) {
        ans += Math.pow(2, ctr - 1);
      }
      if (n % 10 > 1) {
        ans = (int) Math.pow(2, ctr) - 1;
      }
      n /= 10;
      ctr++;
    }
    return ans;
  }
```","```python
def count_binary_integers(n):
  ans = 0
  ctr = 0
  while n > 0:
    if n % 2 == 1:
      ans += 2**(ctr - 1)
    if n > 1:
      ans = 2**ctr - 1
    n //= 2
    ctr += 1
  return ans
```"
66,Count of integers up to N which represent a Binary number | Java program to count the number of integers upto N which are of the form of binary representations ; Function to return the count ; PreCompute and store the powers of 2 ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver Code,"```java
public static int countBinaryNumbers(int n) {
    int[] powersOf2 = new int[32];
    powersOf2[0] = 1;
    for (int i = 1; i < 32; i++) {
        powersOf2[i] = powersOf2[i - 1] * 2;
    }
    int answer = 0;
    int ctr = 0;
    while (n > 0) {
        if (n % 10 == 1) {
            answer += powersOf2[ctr - 1];
        }
        if (n % 10 > 1) {
            answer = powersOf2[ctr] - 1;
        }
        n /= 10;
        ctr++;
    }
    return answer;
}
```","```python
def count_binary_integers(n):
  powers_of_2 = [1]
  ctr = 1
  while powers_of_2[-1] <= n:
    powers_of_2.append(powers_of_2[-1] * 2)
    ctr += 1
  answer = 0
  for i in range(ctr - 1, -1, -1):
    if n % 2 == 1:
      answer += powers_of_2[i - 1]
    if n > 1:
      answer = powers_of_2[i] - 1
    n //= 2
  return answer
```"
67,Find the sum of the first Nth Centered Hexadecagonal Number | Java program to find the sum of the first N centred hexadecagonal numbers ; Centered_Hexadecagonal number function ; Formula to calculate nth Centered_Hexadecagonal number & return it into main function . ; Function to find the sum of the first N centered hexadecagonal number ; Variable to store the sum ; Loop to iterate through the first N numbers ; Finding the sum ; Driver Code ; Display first Nth Centered_Hexadecagonal number,"```java
public static int centeredHexadecagonalNumber(int n) {
    return 16 * n * (n - 1) + 1;
  }
  public static int sumOfCenteredHexadecagonalNumbers(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
      sum += centeredHexadecagonalNumber(i);
    }
    return sum;
  }
  public static void main(String[] args) {
    int n = 5;
    System.out.println(""Sum of the first "" + n + "" centered hexadecagonal numbers: "" + sumOfCenteredHexadecagonalNumbers(n));
  }
```","```python
def centered_hexadecagonal_number(n):
  return 16 * n * (n - 1) + 1

def sum_of_centered_hexadecagonal_numbers(n):
  sum = 0
  for i in range(1, n + 1):
    sum += centered_hexadecagonal_number(i)
  return sum
```"
68,Find the sum of the first N Centered heptagonal number | Java program to find the sum of the first N centered heptagonal numbers ; Function to find the N - th centered heptagonal number ; Formula to calculate nth centered heptagonal number ; Function to find the sum of the first N centered heptagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver Code,"```java
public static int sumOfCenteredHeptagonalNumbers(int N) {
    int sum = 0;
    for (int i = 1; i <= N; i++) {
        sum += (5 * i * i - 5 * i + 1) / 2;
    }
    return sum;
}
```","```python
def centered_heptagonal_sum(n):
  sum = 0
  for i in range(1, n + 1):
    sum += (5 * i * i - 3 * i + 1) // 2
  return sum
```"
69,Find the sum of the first N Centered Dodecagonal Number | Java program to find the sum of the first N centred dodecagonal number ; Function to find the N - th centered dodecagonal number ; Formula to calculate nth Centered_Dodecagonal number ; Function to find the sum of the first N Centered_Dodecagonal number ; Variable to store the sum ; Iterating from 1 to N ; Finding the sum ; Driver code,"```java
public static int sumOfFirstNCenteredDodecagonalNumbers(int N) {
    int sum = 0;
    for (int i = 1; i <= N; i++) {
      sum += (6 * i * i - 5 * i + 1);
    }
    return sum;
  }
```","```python
def sum_centered_dodecagonal(n):
  sum = 0
  for i in range(1, n + 1):
    sum += 6 * i * (i - 1) + 1
  return sum
```"
70,Find the sum of the first N Centered Octagonal Number | Java program to find the sum of the first N centered octagonal number ; Function to find N - th centered octagonal number ; Formula to calculate nth centered octagonal number ; Function to find the sum of the first N centered octagonal numbers ; Variable to store the sum ; Iterating through the first N numbers ; Driver code,"```java
public static int findSumOfCenteredOctagonalNumbers(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += findNthCenteredOctagonalNumber(i);
    }
    return sum;
}

public static int findNthCenteredOctagonalNumber(int n) {
    return 6 * n * (n - 1) + 1;
}
```","```python
def sum_centered_octagonal_numbers(n):
  sum = 0
  for i in range(1, n + 1):
    sum += 4 * i * i - 3 * i + 1
  return sum
```"
71,Find the sum of the first N Centered Decagonal Numbers | Java program to find the sum of the first N centred decagonal number ; Function to find the N - th centred decagonal number ; Formula to calculate nth centered_decagonal number & return it into main function . ; Function to find the sum of the first N centered decagonal numbers ; Variable to store the sum ; Iterating through the range ; Driver code ; Display first Nth centered_decagonal number,"```java
public static int centeredDecagonalNumber(int n) {
    return 5 * n * n - 4 * n + 1;
}

public static int sumOfCenteredDecagonalNumbers(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += centeredDecagonalNumber(i);
    }
    return sum;
}
```","```python
def centered_decagonal(n):
  return 5 * n * (n - 1) + 1

def sum_centered_decagonal(n):
  sum = 0
  for i in range(1, n + 1):
    sum += centered_decagonal(i)
  return sum
```"
72,Find the sum of the first N Centered Octadecagonal Numbers | Java program to find the sum of the first N centered octadecagonal numbers ; Function to find the N - th centered octadecagonal number ; Formula to calculate nth centered octadecagonal number ; Function to find the sum of the first N centered octadecagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver Code,"```java
public static int centeredOctadecagonalNumber(int n) {
    return 18 * n * n - 17 * n + 1;
}

public static int sumOfCenteredOctadecagonalNumbers(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += centeredOctadecagonalNumber(i);
    }
    return sum;
}
```","```python
def sum_centered_octadecagonal_numbers(n):
  sum = 0
  for i in range(1, n + 1):
    sum += 17 * i * i - 16 * i + 1
  return sum
```"
73,Find the sum of the first Nth Centered Pentadecagonal Number | Java program to find the sum of the first N centered pentadecagonal number ; Function to find the centered pentadecagonal number ; Formula to calculate N - th centered pentadecagonal number ; Function to find the sum of the first N centered pentadecagonal numbers ; Variable to store the sum ; Driver Code,"```java
public static int findCenteredPentadecagonalNumber(int n) {
    return 15 * n * (n - 1) / 2 + 1;
}

public static int sumOfCenteredPentadecagonalNumbers(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
      sum += findCenteredPentadecagonalNumber(i);
    }
    return sum;
  }
```","```python
def centered_pentadecagonal_number(n):
  return 15 * n * (n - 1) + 1

def sum_of_centered_pentadecagonal_numbers(n):
  sum = 0
  for i in range(1, n + 1):
    sum += centered_pentadecagonal_number(i)
  return sum
```"
74,Program to check if N is a Octagonal Number | Java program for the above approach ; Function to check if N is a octagonal number ; Condition to check if the number is a octagonal number ; Driver code ; Given Number ; Function call,"```java
public static boolean isOctagonal(int n) {
    return (Math.sqrt(1 + 8 * n) - 1) % 4 == 0;
}
```","```python
def is_octagonal(n):
  return (int((1 + (8 * n)**0.5)) / 4) * 4 == (1 + (8 * n)**0.5) 
```"
75,Program to check if N is a Pentadecagonal Number | Java program for the above approach ; Function to check if N is a pentadecagon number ; Condition to check if the number is a pentadecagon number ; Driver code ; Given Number ; Function call,"```java
public static boolean isPentadecagonal(int N) {
    int i = 1;
    while ((15 * i * i - 13 * i) / 2 < N) {
      i++;
    }
    return (15 * i * i - 13 * i) / 2 == N;
  }
```","```python
def is_pentadecagonal(n):
  return (1 + (8 * n)**0.5) / 4 == int((1 + (8 * n)**0.5) / 4)
```"
76,Program to check if N is a Tetradecagonal Number | Java program for the above approach ; Function to check if N is a tetradecagonal number ; Condition to check if the number is a tetradecagonal number ; Driver Code ; Given number ; Function call,"```java
public static boolean isTetradecagonal(int N) {
    int i = 1;
    while (i * (13 * i - 11) / 2 <= N) {
      if (i * (13 * i - 11) / 2 == N) {
        return true;
      }
      i++;
    }
    return false;
  }
```","```python
def is_tetradecagonal(n):
  return (1/2)*(n*(13*n - 11)) == int((1/2)*(n*(13*n - 11)))
```"
77,Find the sum of the first Nth Icosagonal Numbers | Java program to find the sum of the first N icosagonal number ; Function to calculate the N - th icosagonal number ; Formula to calculate nth icosagonal number & return it ; Function to find the sum of the first N icosagonal numbers ; Variable to store the sum ; Loop to iterate through the first N values and find the sum of first N icosagonal numbers ; Function to get the Icosagonal_num ; Driver code ; Display the sum of first N icosagonal number,"```java
public static int icosagonalNumber(int n) {
    return n * (18 * n - 17);
}

public static int sumOfIcosagonalNumbers(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += icosagonalNumber(i);
    }
    return sum;
}
```","```python
def icosagonal_num(n):
  return n * (18 * n - 17)

def sum_icosagonal_numbers(n):
  sum = 0
  for i in range(1, n + 1):
    sum += icosagonal_num(i)
  return sum
```"
78,Find the sum of the first N Centered Pentagonal Number | Java program to find the sum of the first N centered pentagonal numbers ; Function to find the Centered_Pentagonal number ; Formula to calculate nth Centered_Pentagonal number & return it into main function . ; Function to find the sum of the first N Centered_Pentagonal numbers ; To get the sum ; Iterating through the range 1 to N ; Driver Code ; Display first Nth Centered_Pentagonal number,"```java
public static int centeredPentagonal(int n) {
    return (5 * n * n - 5 * n + 1) / 2;
}

public static int sumOfCenteredPentagonal(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += centeredPentagonal(i);
    }
    return sum;
}
```","```python
def Centered_Pentagonal(n):
  return (5 * n * n - 5 * n + 1) // 2

def sum_Centered_Pentagonal(N):
  sum = 0
  for i in range(1, N + 1):
    sum += Centered_Pentagonal(i)
  return sum
```"
79,Find the sum of the first Nth Centered Tridecagonal Numbers | Java program to find the sum of the first Nth centered tridecagonal number ; Function to calculate the N - th centered tridecagonal number ; Formula to calculate Nth centered tridecagonal number & return it ; Function to find the sum of the first N centered tridecagonal numbers ; Variable to store the sum ; Loop to iterate and find the sum of first N centered tridecagonal numbers ; Driver code,"```java
public static int centeredTridecagonalNumber(int n) {
    return (13 * n * n - 11 * n + 3) / 2;
}

public static int sumOfCenteredTridecagonalNumbers(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += centeredTridecagonalNumber(i);
    }
    return sum;
}
```","```python
def centered_tridecagonal_number(n):
  return n * (13 * n - 11) // 2

def sum_of_centered_tridecagonal_numbers(n):
  sum = 0
  for i in range(1, n + 1):
    sum += centered_tridecagonal_number(i)
  return sum
```"
80,Program to check if N is a Concentric Hexagonal Number | Java program to check if N is a Concentric Hexagonal Number ; Function to check if the number is a Concentric hexagonal number ; Condition to check if the number is a Concentric hexagonal number ; Driver Code ; Function call,"```java
public static boolean isConcentricHexagonal(int n) {
    if (n <= 1) {
        return false;
    }
    for (int i = 1; i <= n; i++) {
        if (n == (i * (i + 1) * (2 * i + 1) / 2)) {
            return true;
        }
    }
    return false;
}
```","```python
def isConcentricHexagonal(n):
  if n <= 1:
    return False
  for i in range(1, n):
    if (i * (2 * i - 1)) == n:
      return True
  return False
```"
81,"Count Sexy Prime Pairs in the given array | Java program to count Sexy Prime pairs in array ; To store check the prime number ; A utility function that find the Prime Numbers till N ; Resize the Prime Number ; Loop till Math . sqrt ( N ) to find prime numbers and make their multiple false in the bool array Prime ; Function that returns the count of SPP ( Sexy Prime Pair ) Pairs ; Find the maximum element in the given array arr [ ] ; Function to calculate the prime numbers till N ; To store the count of pairs ; To store the frequency of element in the array arr [ ] ; Sort before traversing the array ; Traverse the array and find the pairs with SPP ( Sexy Prime Pair ) ; If current element is Prime , then check for ( current element + 6 ) ; Return the count of pairs ; Driver code ; Function call to find SPP ( Sexy Prime Pair ) pair","```java
import java.util.*;
public class SexyPrimePairs {
    public static int countSexyPrimePairs(int[] arr) {
        int max = findMax(arr);
        boolean[] prime = new boolean[max + 1];
        calculatePrimes(prime, max);
        int[] freq = new int[max + 1];
        for (int i = 0; i < arr.length; i++) {
            freq[arr[i]]++;
        }
        Arrays.sort(arr);
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            if (prime[arr[i]]) {
                if (prime[arr[i] + 6] && freq[arr[i] + 6] > 0) {
                    count++;
                }
            }
        }
        return count;
    }
    public static int findMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    }
    public static void calculatePrimes(boolean[] prime, int n) {
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;
        for (int i = 2; i * i <= n; i++) {
            if (prime[i]) {
                for (int j = i * i; j <= n; j += i) {
                    prime[j] = false;
                }
            }
        }
    }
}
```","```python
def count_sexy_prime_pairs(arr):
  n = len(arr)
  max_element = max(arr)
  primes = [True] * (max_element + 1)
  primes[0] = primes[1] = False
  for i in range(2, int(max_element**0.5) + 1):
    if primes[i]:
      for j in range(i * i, max_element + 1, i):
        primes[j] = False
  frequency = [0] * (max_element + 1)
  for i in range(n):
    frequency[arr[i]] += 1
  count = 0
  for i in range(n):
    if primes[arr[i]]:
      if primes[arr[i] + 6]:
        count += frequency[arr[i]] * frequency[arr[i] + 6]
  return count
```"
82,Count of ways to write N as a sum of three numbers | Java program to count the total number of ways to write N as a sum of three numbers ; Function to find the number of ways ; Check if number is less than 2 ; Calculate the sum ; Driver code,"```java
public static int countWays(int n) {
    if (n < 2) {
      return 0;
    }
    int count = 0;
    for (int i = 1; i <= n - 2; i++) {
      for (int j = i + 1; j <= n - 1; j++) {
        for (int k = j + 1; k <= n; k++) {
          if (i + j + k == n) {
            count++;
          }
        }
      }
    }
    return count;
  }
```","```python
def countWays(n):
  if n < 2:
    return 0
  count = 0
  for i in range(1, n):
    for j in range(1, n - i + 1):
      k = n - i - j
      if k > 0:
        count += 1
  return count
```"
83,Logarithm tricks for Competitive Programming | Java implementation to check that a integer is a power of Two ; Function to check if the number is a power of two ; Driver Code,"```java
public static boolean isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
```","```python
def isPowerOfTwo(n):
  return (n and (not(n & (n - 1))))
```"
84,"Count of pairs having bit size at most X and Bitwise OR equal to X | Java implementation to count number of possible pairs of ( a , b ) such that their Bitwise OR gives the value X ; Function to count the pairs ; Initializing answer with 1 ; Iterating through bits of x ; Check if bit is 1 ; Multiplying ans by 3 if bit is 1 ; Driver code","```java
public static long countPairs(long x) {
    long ans = 1;
    for (int i = 0; i < 63; i++) {
      if ((x & (1L << i)) != 0) {
        ans *= 3;
      }
    }
    return ans;
  }
```","```python
def countPairs(x):
  ans = 1
  for i in range(32):
    if (x >> i) & 1:
      ans *= 3
  return ans
```"
85,Find the Kth number which is not divisible by N | Java implementation for above approach ; Function to find the Kth not divisible by N ; Lowest possible value ; Highest possible value ; To store the Kth non divisible number of N ; Using binary search ; Calculating mid value ; Sol would have the value by subtracting all multiples of n till mid ; Check if sol is greater than k ; H should be reduced to find minimum possible value ; Check if sol is less than k then L will be mid + 1 ; Check if sol is equal to k ; ans will be mid ; H would be reduced to find any more possible value ; Print the answer ; Driver code ; Function Call,"```java
public static int findKthNotDivisibleByN(int k, int n) {
  int l = 1;
  int h = Integer.MAX_VALUE;
  int ans = -1;
  while (l <= h) {
    int mid = l + (h - l) / 2;
    int sol = mid - (mid / n);
    if (sol > k) {
      h = mid - 1;
    } else if (sol < k) {
      l = mid + 1;
    } else {
      ans = mid;
      h = mid - 1;
    }
  }
  return ans;
}
```","```python
def findKthNotDivisibleByN(k, n):
  l = 1
  h = k * n
  while l <= h:
    mid = (l + h) // 2
    sol = mid - (mid // n)
    if sol > k:
      h = mid - 1
    elif sol < k:
      l = mid + 1
    else:
      return mid
```"
86,Print any pair of integers with sum of GCD and LCM equals to N | Java implementation to print any pair of integers whose summation of GCD and LCM is equal to integer N ; Function to print the required pair ; Print the pair ; Driver code,"```java
public static void printPair(int N) {
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            if (gcd(i, j) + lcm(i, j) == N) {
                System.out.println(i + "" "" + j);
                return;
            }
        }
    }
}

public static int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}

public static int lcm(int a, int b) {
    return (a * b) / gcd(a, b);
}
```","```python
def print_pair(N):
  for i in range(1, N + 1):
    for j in range(i, N + 1):
      if gcd(i, j) + lcm(i, j) == N:
        print(i, j)
        return
  print(-1, -1)

def gcd(a, b):
  while b:
    a, b = b, a % b
  return a

def lcm(a, b):
  return (a * b) // gcd(a, b)
```"
87,Find the length of largest subarray in which all elements are Autobiographical Numbers | Java program to find the length of the largest subarray whose every element is an autobiographical number ; Function to check number is autobiographical ; Convert integer to string ; Iterate for every digit to check for their total count ; Check occurrence of every number and count them ; Check if any position mismatches with total count them return with false else continue with loop ; Function to return the length of the largest subarray whose every element is a Autobiographical number ; Utility function which checks every element of array for autobiographical number ; Check if element arr [ i ] is an autobiographical number ; Increment the current length ; Update max_length value ; Return the final result ; Driver code,"```java
public static int largestAutobiographicalSubarray(int[] arr) {
    int max_length = 0;
    int current_length = 0;
    for (int i = 0; i < arr.length; i++) {
        if (isAutobiographical(arr[i])) {
            current_length++;
            max_length = Math.max(max_length, current_length);
        } else {
            current_length = 0;
        }
    }
    return max_length;
}

public static boolean isAutobiographical(int num) {
    String str = String.valueOf(num);
    int[] count = new int[10];
    for (int i = 0; i < str.length(); i++) {
        count[str.charAt(i) - '0']++;
    }
    for (int i = 0; i < str.length(); i++) {
        if (count[i] != (str.charAt(i) - '0')) {
            return false;
        }
    }
    return true;
}
```","```python
def is_autobiographical(num):
  s = str(num)
  for i in range(len(s)):
    count = s.count(str(i))
    if int(s[i]) != count:
      return False
  return True

def largest_autobiographical_subarray_length(arr):
  max_length = 0
  current_length = 0
  for i in range(len(arr)):
    if is_autobiographical(arr[i]):
      current_length += 1
      max_length = max(max_length, current_length)
    else:
      current_length = 0
  return max_length
```"
88,"Euler 's Factorization method | Java program to implement Eulers Factorization algorithm ;  ; Recursive function to return gcd of a and b ; Function to return N as the sum of two squares in two possible ways ; Iterate a loop from 1 to Math . sqrt ( n ) ; If i * i is square check if there exists another integer such that h is a perfect square and i * i + h = n ; If h is perfect square ; Store in the sorted way ; If there is already a pair check if pairs are equal or not ; Insert the first pair ; If two pairs are found ; Function to find the factors ; Get pairs where a ^ 2 + b ^ 2 = n ; Number cannot be represented as sum of squares in two ways ; Assign a , b , c , d ; Swap if a < c because if a - c < 0 , GCD cant be computed . ; Compute the values of k , h , l , m using the formula mentioned in the approach ; Print the values of a , b , c , d and k , l , m , h ; Printing the factors ; Driver code","```java
import java.util.*;
public class EulerFactorization {
    public static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }
    public static List<List<Integer>> sumOfSquares(int n) {
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 1; i <= Math.sqrt(n); i++) {
            int h = n - i * i;
            if (Math.sqrt(h) == (int) Math.sqrt(h)) {
                List<Integer> pair = new ArrayList<>(Arrays.asList(i, (int) Math.sqrt(h)));
                Collections.sort(pair);
                if (result.isEmpty() || !result.get(0).equals(pair)) {
                    result.add(pair);
                } else if (result.size() == 1) {
                    result.add(pair);
                }
                if (result.size() == 2) {
                    break;
                }
            }
        }
        return result;
    }
    public static void findFactors(int a, int b, int c, int d) {
        if (a < c) {
            int temp = a;
            a = c;
            c = temp;
            temp = b;
            b = d;
            d = temp;
        }
        int k = (a + b) / 2;
        int h = (a - b) / 2;
        int l = (c + d) / 2;
        int m = (c - d) / 2;
        System.out.println(a + "" "" + b + "" "" + c + "" "" + d);
        System.out.println(k + "" "" + l + "" "" + m + "" "" + h);
        System.out.println(""Factors:"");
        for (int i = 1; i <= k; i++) {
            if (k % i == 0) {
                System.out.print(i + "" "");
            }
        }
        for (int i = 1; i <= h; i++) {
            if (h % i == 0) {
                System.out.print(i + "" "");
            }
        }
        for (int i = 1; i <= l; i++) {
            if (l % i == 0) {
                System.out.print(i + "" "");
            }
        }
        for (int i = 1; i <= m; i++) {
            if (m % i == 0) {
                System.out.print(i + "" "");
            }
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<List<Integer>> pairs = sumOfSquares(n);
        if (pairs.size() == 2) {
            int a = pairs.get(0).get(0);
            int b = pairs.get(0).get(1);
            int c = pairs.get(1).get(0);
            int d = pairs.get(1).get(1);
            findFactors(a, b, c, d);
        } else {
            System.out.println(""Number cannot be represented as sum of squares in two ways"");
        }
    }
}
```","```python
import math

def gcd(a, b):
  if b == 0:
    return a
  return gcd(b, a % b)

def sum_of_squares(n):
  for i in range(1, int(math.sqrt(n)) + 1):
    if int(math.sqrt(i * i)) == i:
      h = n - i * i
      if int(math.sqrt(h)) == math.sqrt(h):
        return [(i, int(math.sqrt(h))), (int(math.sqrt(h)), i)]
  return None

def find_factors(n):
  pairs = sum_of_squares(n)
  if pairs is None:
    print(""Number cannot be represented as sum of squares in two ways"")
    return
  a, b = pairs[0]
  c, d = pairs[1]
  if a < c:
    a, c = c, a
    b, d = d, b
  k = gcd(a - c, b - d)
  h = gcd(a + c, b + d)
  l = (a * b - c * d) // (k * h)
  m = (a * d + b * c) // (k * h)
  print(f""a = {a}, b = {b}, c = {c}, d = {d}"")
  print(f""k = {k}, l = {l}, m = {m}, h = {h}"")
  print(""Factors:"")
  print(f""{k * l + h * m}, {k * l - h * m}"")
```"
89,Print the nodes of the Binary Tree whose height is a Prime number | Java implementation of nodes at prime height in the given tree ; To store Prime Numbers ; To store height of each node ; Function to find the prime numbers till 10 ^ 5 ; Traverse all multiple of i and make it false ; Function to perform dfs ; Store the height of node ; Function to find the nodes at prime height ; To precompute prime number till 10 ^ 5 ; Check if height [ node ] is prime ; Driver code ; Number of nodes ; Edges of the tree,"```java
import java.util.*;
class Solution {
    static boolean[] prime = new boolean[100001];
    static int[] height = new int[100001];
    static ArrayList<Integer>[] adj;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        adj = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            adj[i] = new ArrayList<>();
        }
        for (int i = 0; i < n - 1; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            adj[u].add(v);
            adj[v].add(u);
        }
        precomputePrimes();
        dfs(1, 0);
        findNodesAtPrimeHeight(n);
    }
    static void precomputePrimes() {
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;
        for (int i = 2; i * i <= 100000; i++) {
            if (prime[i]) {
                for (int j = i * i; j <= 100000; j += i) {
                    prime[j] = false;
                }
            }
        }
    }
    static void dfs(int node, int par) {
        height[node] = height[par] + 1;
        for (int child : adj[node]) {
            if (child != par) {
                dfs(child, node);
            }
        }
    }
    static void findNodesAtPrimeHeight(int n) {
        for (int i = 1; i <= n; i++) {
            if (prime[height[i]]) {
                System.out.print(i + "" "");
            }
        }
    }
}
```","```python
import math

def find_primes(n):
  primes = [True] * (n + 1)
  primes[0] = primes[1] = False
  for i in range(2, int(math.sqrt(n)) + 1):
    if primes[i]:
      for j in range(i * i, n + 1, i):
        primes[j] = False
  return primes

def dfs(node, parent, height, heights):
  heights[node] = height
  for neighbor in graph[node]:
    if neighbor != parent:
      dfs(neighbor, node, height + 1, heights)

def find_nodes_at_prime_height(n, edges):
  global graph
  graph = [[] for _ in range(n + 1)]
  for u, v in edges:
    graph[u].append(v)
    graph[v].append(u)
  
  primes = find_primes(10 ** 5)
  heights = [0] * (n + 1)
  dfs(1, -1, 0, heights)

  for node in range(1, n + 1):
    if primes[heights[node]]:
      print(node, end=' ')
  print()

n = int(input())
edges = []
for _ in range(n - 1):
  u, v = map(int, input().split())
  edges.append((u, v))
find_nodes_at_prime_height(n, edges)
```"
90,"Find Prime Adam integers in the given range [ L , R ] | Java program to find all prime adam numbers in the given range ; reversing a number by taking remainder at a time ; Function to check if a number is a prime or not ; Iterating till the number ; Checking for factors ; Returning 1 if the there are no factors of the number other than 1 or itself ; Function to check whether a number is an adam number or not ; Reversing given number ; Squaring given number ; Squaring reversed number ; Reversing the square of the reversed number ; Checking if the square of the number and the square of its reverse are equal or not ; Function to find all the prime adam numbers in the given range ; If the first number is greater than the second number , print invalid ; Iterating through all the numbers in the given range ; Checking for prime number ; Checking for Adam number ; Driver code","```java
public static void findPrimeAdamNumbers(int L, int R) {
    if (L > R) {
        System.out.println(""Invalid"");
        return;
    }
    for (int i = L; i <= R; i++) {
        if (isPrime(i) && isAdam(i)) {
            System.out.print(i + "" "");
        }
    }
}

public static boolean isPrime(int num) {
    if (num <= 1) {
        return false;
    }
    for (int i = 2; i * i <= num; i++) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}

public static int reverseNumber(int num) {
    int reversed = 0;
    while (num > 0) {
        reversed = reversed * 10 + num % 10;
        num /= 10;
    }
    return reversed;
}

public static boolean isAdam(int num) {
    int reversed = reverseNumber(num);
    int squareOfNum = num * num;
    int squareOfReversed = reversed * reversed;
    return squareOfNum == reverseNumber(squareOfReversed);
}
```","```python
def find_prime_adam_numbers(L, R):
  if L > R:
    print(""Invalid"")
    return
  for num in range(L, R + 1):
    if is_prime(num) and is_adam(num):
      print(num)

def is_prime(num):
  if num <= 1:
    return False
  for i in range(2, int(num**0.5) + 1):
    if num % i == 0:
      return False
  return True

def is_adam(num):
  reversed_num = int(str(num)[::-1])
  square_num = num**2
  square_reversed_num = reversed_num**2
  reversed_square_reversed_num = int(str(square_reversed_num)[::-1])
  return square_num == reversed_square_reversed_num
```"
91,Determine whether the given integer N is a Peculiar Number or not | Java implementation to check if the number is peculiar ; Function to find sum of digits of a number ; Function to check if number is peculiar ; Store a duplicate of n ; Driver code,"```java
public static boolean isPeculiar(int n) {
    int sum = sumOfDigits(n);
    int temp = n;
    while (temp > 0) {
        if (temp % 10 == sum) {
            return true;
        }
        temp /= 10;
    }
    return false;
}

public static int sumOfDigits(int n) {
    int sum = 0;
    while (n > 0) {
        sum += n % 10;
        n /= 10;
    }
    return sum;
}
```","```python
def sum_of_digits(n):
  sum = 0
  while n > 0:
    sum += n % 10
    n //= 10
  return sum

def is_peculiar(n):
  temp = n
  while temp > 9:
    temp = sum_of_digits(temp)
  return temp == 1

def is_peculiar_number(n):
  return is_peculiar(n)
```"
92,Find N numbers such that a number and its reverse are divisible by sum of its digits | Java program to print the first N numbers such that every number and the reverse of the number is divisible by its sum of digits ; Function to calculate the sum of digits ; Loop to iterate through every digit of the number ; Returning the sum of digits ; Function to calculate the reverse of a number ; Loop to calculate the reverse of the number ; Return the reverse of the number ; Function to print the first N numbers such that every number and the reverse of the number is divisible by its sum of digits ; Loop to continuously check and generate number until there are n outputs ; Variable to hold the sum of the digit of the number ; Computing the reverse of the number ; Checking if the condition satisfies . Increment the count and print the number if it satisfies . ; Driver code,"```java
public static void printNumbers(int n) {
    int count = 0;
    int number = 1;
    while (count < n) {
      int sum = sumOfDigits(number);
      int reverse = reverseNumber(number);
      if (number % sum == 0 && reverse % sum == 0) {
        count++;
        System.out.print(number + "" "");
      }
      number++;
    }
  }

  public static int sumOfDigits(int number) {
    int sum = 0;
    while (number > 0) {
      sum += number % 10;
      number /= 10;
    }
    return sum;
  }

  public static int reverseNumber(int number) {
    int reverse = 0;
    while (number > 0) {
      reverse = reverse * 10 + number % 10;
      number /= 10;
    }
    return reverse;
  }
```","```python
def sum_of_digits(num):
  sum = 0
  while num > 0:
    sum += num % 10
    num //= 10
  return sum

def reverse_number(num):
  rev = 0
  while num > 0:
    rev = rev * 10 + num % 10
    num //= 10
  return rev

def print_numbers(n):
  count = 0
  num = 1
  while count < n:
    sum_digits = sum_of_digits(num)
    rev = reverse_number(num)
    if num % sum_digits == 0 and rev % sum_digits == 0:
      print(num)
      count += 1
    num += 1
```"
93,Split N natural numbers into two sets having GCD of their sums greater than 1 | Java program to split N natural numbers into two sets having GCD of their sums greater than 1 ; Function to create and print the two sets ; No such split possible for N <= 2 ; Print the first set consisting of even elements ; Print the second set consisting of odd ones ; Driver Code,"```java
public static void splitSets(int N) {
    if (N <= 2) {
        return;
    }
    System.out.print(""{"");
    for (int i = 2; i <= N; i += 2) {
        System.out.print(i);
        if (i < N) {
            System.out.print("", "");
        }
    }
    System.out.println(""}"");
    System.out.print(""{"");
    for (int i = 1; i <= N; i += 2) {
        System.out.print(i);
        if (i < N - 1) {
            System.out.print("", "");
        }
    }
    System.out.println(""}"");
}
```","```python
def split_sets(N):
  if N <= 2:
    return
  set1 = set(range(2, N + 1, 2))
  set2 = set(range(1, N + 1, 2))
  print(set1)
  print(set2)
```"
94,"Count the nodes in the given tree whose weight is a powerful number | Java implementation to Count the nodes in the given tree whose weight is a powerful number ; Function to check if the number is powerful ; First divide the number repeatedly by 2 ; Check if only 2 ^ 1 divides n , then return false ; Check if n is not a power of 2 then this loop will execute ; Find highest power of "" factor "" that divides n ; Check if only factor ^ 1 divides n , then return false ; n must be 1 now if it is not a prime number . Since prime numbers are not powerful , we return false if n is not 1. ; Function to perform dfs ; Check if weight of the current node is a powerful number ; Driver code ; Weights of the node ; Edges of the tree","```java
class Solution {
    public int countPowerfulNodes(int[] weights, int[][] edges) {
        int n = weights.length;
        List<Integer>[] adjList = new List[n];
        for (int i = 0; i < n; i++) {
            adjList[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            adjList[edge[0]].add(edge[1]);
            adjList[edge[1]].add(edge[0]);
        }
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (isPowerful(weights[i])) {
                count++;
            }
        }
        return count;
    }

    private boolean isPowerful(int n) {
        n /= 2;
        if (n == 1) {
            return false;
        }
        while (n > 1) {
            int factor = 2;
            while (n % factor == 0) {
                n /= factor;
            }
            if (n % factor == 0) {
                return false;
            }
            factor++;
        }
        return n == 1;
    }
}
```","```python
def isPowerful(n):
  n //= 2
  if n == 1:
    return False
  while n % 2 == 0:
    n //= 2
  if n == 1:
    return False
  factor = 3
  while n > 1:
    if n % factor == 0:
      highestPower = 0
      while n % factor == 0:
        n //= factor
        highestPower += 1
      if highestPower == 1:
        return False
    factor += 2
  return n == 1

def dfs(node, adj, weights, count):
  if isPowerful(weights[node]):
    count[0] += 1
  for neighbor in adj[node]:
    dfs(neighbor, adj, weights, count)

def countPowerfulNodes(weights, edges):
  n = len(weights)
  adj = [[] for _ in range(n)]
  for u, v in edges:
    adj[u].append(v)
    adj[v].append(u)
  count = [0]
  dfs(0, adj, weights, count)
  return count[0]

weights = [2, 3, 4, 5, 6, 7, 8, 9]
edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3, 7]]
result = countPowerfulNodes(weights, edges)
print(result) 
```"
95,Number of ways to color boundary of each block of M * N table | Java program to count the number of ways to color boundary of each block of M * N table . ; Function to compute all way to fill the boundary of all sides of the unit square ; Count possible ways to fill all upper and left side of the rectangle M * N ; Count possible ways to fill all side of the all squares unit size ; Driver code ; Number of rows ; Number of columns,"```java
public static int countWays(int M, int N) {
    int ways = 1;
    for (int i = 1; i <= M * N; i++) {
      ways *= 3;
    }
    return ways;
  }
```","```python
def count_ways(m, n):
  return (2 * (m + n - 2)) * 4**(m * n - m - n + 1)
```"
96,"Nth positive number whose absolute difference of adjacent digits is at most 1 | Java program to find Nth number with absolute difference between all adjacent digits at most 1. ; Return Nth number with absolute difference between all adjacent digits at most 1. ; To store all such numbers ; Enqueue all integers from 1 to 9 in increasing order . ; Perform the operation N times so that we can get all such N numbers . ; Store the front element of queue , in array and pop it from queue . ; If the last digit of dequeued integer is not 0 , then enqueue the next such number . ; Enqueue the next such number ; If the last digit of dequeued integer is not 9 , then enqueue the next such number . ; Driver Code","```java
public static int findNthNumber(int n) {
    Queue<Integer> queue = new LinkedList<>();
    for (int i = 1; i <= 9; i++) {
        queue.offer(i);
    }
    int[] result = new int[n];
    for (int i = 0; i < n; i++) {
        result[i] = queue.poll();
        int lastDigit = result[i] % 10;
        if (lastDigit != 0) {
            queue.offer(result[i] * 10 + lastDigit - 1);
        }
        queue.offer(result[i] * 10 + lastDigit);
        if (lastDigit != 9) {
            queue.offer(result[i] * 10 + lastDigit + 1);
        }
    }
    return result[n - 1];
}
```","```python
def find_nth_number(n):
  queue = [i for i in range(1, 10)]
  result = []
  for _ in range(n):
    number = queue.pop(0)
    result.append(number)
    if number % 10 != 0:
      queue.append(number * 10 + number % 10 + 1)
    if number % 10 != 9:
      queue.append(number * 10 + number % 10 - 1)
  return result[-1]
```"
97,Unique element in an array where all elements occur K times except one | Set 2 | Java program for the above approach ; Function that find the unique element in the array arr [ ] ; Store all unique element in set ; Sum of all element of the array ; Sum of element in the set ; Print the unique element using formula ; Driver code ; Function call,"```java
public static int findUniqueElement(int[] arr, int k) {
  Set<Integer> uniqueElements = new HashSet<>();
  int sumOfArray = 0;
  for (int element : arr) {
    sumOfArray += element;
    uniqueElements.add(element);
  }
  int sumOfUniqueElements = 0;
  for (int element : uniqueElements) {
    sumOfUniqueElements += element;
  }
  return (k * sumOfUniqueElements - sumOfArray) / (k - 1);
}
```","```python
def findUnique(arr, k):
  s = set()
  for i in range(len(arr)):
    s.add(arr[i])
  sum1 = 0
  for i in range(len(arr)):
    sum1 += arr[i]
  sum2 = 0
  for i in s:
    sum2 += i
  return (k * sum2 - sum1) // (k - 1)
```"
98,"Form the Cubic equation from the given roots | Java program for the approach ; Function to find the cubic equation whose roots are a , b and c ; Find the value of coefficient ; Print the equation as per the above coefficients ; Driver Code ; Function Call","```java
public static void findCubicEquation(double a, double b, double c) {
    double coeffC = -a * b * c;
    double coeffB = a * b + a * c + b * c;
    double coeffA = -(a + b + c);
    System.out.println(""The cubic equation is: x^3 + "" + coeffA + ""x^2 + "" + coeffB + ""x + "" + coeffC + "" = 0"");
}
```","```python
def cubic_equation(a, b, c):
  return [1, - (a + b + c), (a * b + a * c + b * c), - (a * b * c)]
```"
99,"Gill 's 4th Order Method to solve Differential Equations | Java program to implement Gill 's method ; A sample differential equation "" dy \/ dx ▁ = ▁ ( x ▁ - ▁ y ) \/2"" ; Finds value of y for a given x using step size h and initial value y0 at x0 ; Count number of iterations using step size or height h ; Value of K_i ; Initial value of y ( 0 ) ; Iterate for number of iteration ; Value of K1 ; Value of K2 ; Value of K3 ; Value of K4 ; Find the next value of y ( n + 1 ) using y ( n ) and values of K in the above steps ; Update next value of x ; Return the final value of dy \/ dx ; Driver Code","```java
public static double gillsMethod(double x0, double y0, double h, int iterations) {
    double x = x0;
    double y = y0;
    for (int i = 0; i < iterations; i++) {
        double k1 = (x - y) / 2;
        double k2 = (x + h / 2 - (y + h / 2 * k1)) / 2;
        double k3 = (x + h / 2 - (y + h / 2 * k2)) / 2;
        double k4 = (x + h - (y + h * k3)) / 2;
        y = y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4);
        x = x + h;
    }
    return (x - y) / 2;
}
```","```python
def gills_method(x0, y0, h, x):
  n = int((x - x0) / h)
  y = y0
  for i in range(n):
    k1 = (x0 - y) / 2
    k2 = (x0 + h / 2 - (y + h / 2 * k1)) / 2
    k3 = (x0 + h / 2 - (y + h / 2 * k2)) / 2
    k4 = (x0 + h - (y + h * k3)) / 2
    y = y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)
    x0 = x0 + h
  return (x0 - y) / 2
```"
100,Program to print numbers from N to 1 in reverse order | Java program to print all numbers between 1 to N in reverse order ; Recursive function to print from N to 1 ; Driver code,"```java
public static void printNumbersReverse(int n) {
    if (n > 0) {
      System.out.print(n + "" "");
      printNumbersReverse(n - 1);
    }
  }
```","```python
def print_reverse(N):
  if N > 0:
    print(N)
    print_reverse(N-1)
```"
101,Find count of numbers from 0 to n which satisfies the given equation for a value K | Java implementation to find the total count of all the numbers from 0 to n which satisfies the given equation for a value K ; Function to find the values ; Calculate the LCM ; Calculate the multiples of lcm ; Find the values which satisfies the given condition ; Subtract the extra values ; Return the final result ; Driver code,"```java
public static int countValues(int n, int k) {
    int count = 0;
    for (int i = 0; i <= n; i++) {
      if (lcm(i, k) == k) {
        count++;
      }
    }
    return count;
  }

  public static int lcm(int a, int b) {
    return (a * b) / gcd(a, b);
  }

  public static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
```","```python
def count_numbers(n, k):
  lcm = 1
  for i in range(2, k + 1):
    lcm = (lcm * i) // math.gcd(lcm, i)
  multiples = [i * lcm for i in range(1, n // lcm + 1)]
  count = len(multiples)
  for i in multiples:
    if i + k > n:
      count -= 1
  return count
```"
102,"Program to find if two numbers and their AM and HM are present in an array using STL | Java program to check if two numbers are present in an array then their AM and HM are also present . Finally , find the GM of the numbers ; Function to find the Arithmetic Mean of 2 numbers ; Function to find the Harmonic Mean of 2 numbers ; Following function checks and computes the desired results based on the means ; Calculate means ; Hash container ( HashMap ) to store elements ; Insertion of array elements in the Set ; Conditionals to check if numbers are present in array by Hashing ; Conditionals to check if the AM and HM of the numbers are present in array ; If all conditions are satisfied , the Geometric Mean is calculated ; If numbers are found but the respective AM and HM are not found in the array ; If none of the conditions are satisfied ; Driver code","```java
import java.util.*;
public class Solution {
    public static double arithmeticMean(double a, double b) {
        return (a + b) / 2;
    }
    public static double harmonicMean(double a, double b) {
        return 2 * a * b / (a + b);
    }
    public static void findMeans(double[] arr, double a, double b) {
        Set<Double> set = new HashSet<>();
        for (double element : arr) {
            set.add(element);
        }
        if (set.contains(a) && set.contains(b)) {
            double am = arithmeticMean(a, b);
            double hm = harmonicMean(a, b);
            if (set.contains(am) && set.contains(hm)) {
                System.out.println(""Numbers "" + a + "" and "" + b + "" are present in the array"");
                System.out.println(""Their AM and HM are also present in the array"");
                double gm = Math.sqrt(a * b);
                System.out.println(""The geometric mean is: "" + gm);
            } else {
                System.out.println(""Numbers "" + a + "" and "" + b + "" are present in the array"");
                System.out.println(""Their AM and HM are not present in the array"");
            }
        } else {
            System.out.println(""Numbers "" + a + "" and "" + b + "" are not present in the array"");
        }
    }
    public static void main(String[] args) {
        double[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        double a = 2;
        double b = 4;
        findMeans(arr, a, b);
    }
}
```","```python
from collections import defaultdict

def arithmetic_mean(a, b):
  return (a + b) / 2

def harmonic_mean(a, b):
  return 2 / (1/a + 1/b)

def check_means(arr, a, b):
  am = arithmetic_mean(a, b)
  hm = harmonic_mean(a, b)
  
  elements = defaultdict(lambda: False)
  for num in arr:
    elements[num] = True
  
  if elements[a] and elements[b] and elements[am] and elements[hm]:
    gm = (a * b)**0.5
    print(""Numbers found, AM, HM found, GM is:"", gm)
    return
  
  if elements[a] and elements[b]:
    print(""Numbers found, but AM, HM not found"")
    return
  
  print(""Numbers not found"")

def main():
  arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  a = 2
  b = 4
  check_means(arr, a, b)

if __name__ == ""__main__"":
  main()
```"
103,Minimum decrements to make integer A divisible by integer B | Java implementation to count total numbers moves to make integer A divisible by integer B ; Function that print number of moves required ; Calculate modulo ; Print the required answer ; Driver code ; Initialise A and B,"```java
public static void countMoves(int A, int B) {
    int moves = A % B;
    System.out.println(moves);
}
```","```python
def count_moves(A, B):
  return A % B 
```"
104,Pythagorean Triplet with given sum using single loop | Java program to find the Pythagorean Triplet with given sum ; Function to calculate the Pythagorean triplet in O ( n ) ; Iterate a from 1 to N - 1. ; Calculate value of b ; The value of c = n - a - b ; Driver Code ; Function call,"```java
public static void findPythagoreanTriplet(int n) {
    for (int a = 1; a < n - 1; a++) {
        int b = (n * n - 2 * n * a) / (2 * (n - a));
        int c = n - a - b;
        if (a * a + b * b == c * c) {
            System.out.println(""Pythagorean Triplet: "" + a + "" "" + b + "" "" + c);
            return;
        }
    }
    System.out.println(""No Pythagorean Triplet found for the given sum."");
}
```","```python
def find_pythagorean_triplet(n):
  for a in range(1, n):
    b = (n * n - 2 * a * n) // (2 * n - 2 * a)
    c = n - a - b
    if a * a + b * b == c * c:
      return (a, b, c)
  return None
```"
105,"Check if there exists a number with X factors out of which exactly K are prime | Java program to check if there exists a number with X factors out of which exactly K are prime ; Function to check if such number exists ; To store the sum of powers of prime factors of X which determines the maximum count of numbers whose product can form X ; Determining the prime factors of X ; To check if the number is prime ; If X is 1 , then we cannot form a number with 1 factor and K prime factor ( as K is atleast 1 ) ; If X itself is prime then it can be represented as a power of only 1 prime factor which is X itself so we return true ; If sum of the powers of prime factors of X is greater than or equal to K , which means X can be represented as a product of K numbers , we return true ; In any other case , we return false as we cannot form a number with X factors and K prime factors ; Driver code","```java
public static boolean checkNumber(int X, int K) {
    if (X == 1) {
      return false;
    }
    if (isPrime(X)) {
      return true;
    }
    int sumOfPowers = 0;
    for (int i = 2; i * i <= X; i++) {
      if (isPrime(i) && X % i == 0) {
        int power = 0;
        while (X % i == 0) {
          power++;
          X /= i;
        }
        sumOfPowers += power;
      }
    }
    if (X > 1) {
      sumOfPowers++;
    }
    return sumOfPowers >= K;
  }
  private static boolean isPrime(int num) {
    if (num <= 1) {
      return false;
    }
    for (int i = 2; i * i <= num; i++) {
      if (num % i == 0) {
        return false;
      }
    }
    return true;
  }
```","```python
def check_number_exists(X, K):
  if X == 1:
    return False
  if is_prime(X):
    return True
  sum_powers = 0
  for i in range(2, int(X**0.5) + 1):
    if X % i == 0:
      power = 0
      while X % i == 0:
        X //= i
        power += 1
      sum_powers += power
  if X > 1:
    sum_powers += 1
  return sum_powers >= K

def is_prime(num):
  if num <= 1:
    return False
  for i in range(2, int(num**0.5) + 1):
    if num % i == 0:
      return False
  return True
```"
106,"Print all Coprime path of a Binary Tree | Java program for printing Co - prime paths of binary Tree ; A Tree node ; Utility function to create a new node ; Vector to store all the prime numbers ; Function to store all the prime numbers in an array ; Create a boolean array "" prime [ 0 . . N ] "" and initialize all the entries in it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiples of p and are less than p ^ 2 are already marked . ; Function to check whether Path is Co - prime or not ; Iterating through the array to find the maximum element in the array ; Incrementing the variable if any of the value has a factor ; If not co - prime ; Function to print a Co - Prime path ; Function to find co - prime paths of binary tree ; Base case ; Store the value in path vector ; Recursively call for left sub tree ; Recursively call for right sub tree ; Condition to check , if leaf node ; Condition to check , if path co - prime or not ; Print co - prime path ; Remove the last element from the path vector ; Function to find Co - Prime paths In a given binary tree ; To save all prime numbers ; Function call ; Driver Code ; Create Binary Tree as shown ; Print Co - Prime Paths","```java
import java.util.*;

class Node {
    int data;
    Node left, right;

    Node(int data) {
        this.data = data;
        left = right = null;
    }
}

class CoPrimePath {

    static Vector<Integer> prime = new Vector<>();

    static void sieveOfEratosthenes(int n) {
        boolean[] prime = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * p; i <= n; i += p)
                    prime[i] = false;
            }
        }
        for (int i = 2; i <= n; i++) {
            if (prime[i])
                prime.add(i);
        }
    }

    static boolean isCoPrime(int[] path) {
        int max = path[0];
        for (int i = 1; i < path.length; i++) {
            if (path[i] > max)
                max = path[i];
        }
        int count = 0;
        for (int i = 0; i < path.length; i++) {
            for (int j = 2; j <= Math.sqrt(path[i]); j++) {
                if (path[i] % j == 0) {
                    count++;
                    break;
                }
            }
        }
        if (count > 0)
            return false;
        return true;
    }

    static void printCoPrimePath(Node root, Vector<Integer> path) {
        if (root == null)
            return;
        path.add(root.data);
        printCoPrimePath(root.left, path);
        printCoPrimePath(root.right, path);
        if (root.left == null && root.right == null) {
            if (isCoPrime(path.stream().mapToInt(Integer::intValue).toArray())) {
                for (int i = 0; i < path.size(); i++)
                    System.out.print(path.get(i) + "" "");
                System.out.println();
            }
        }
        path.remove(path.size() - 1);
    }

    static void findCoPrimePaths(Node root) {
        sieveOfEratosthenes(100);
        Vector<Integer> path = new Vector<>();
        printCoPrimePath(root, path);
    }

    public static void main(String[] args) {
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.right.left = new Node(6);
        root.right.right = new Node(7);
        System.out.println(""Co-Prime Paths are : "");
        findCoPrimePaths(root);
    }
}
```","```python
def print_coprime_paths(root):
    prime = [True] * (1000 + 1)
    primes = []
    for p in range(2, 1001):
        if prime[p]:
            primes.append(p)
            for i in range(p * p, 1001, p):
                prime[i] = False
    path = []
    def is_coprime(arr):
        max_val = max(arr)
        count = 0
        for i in range(2, max_val + 1):
            for j in arr:
                if j % i == 0:
                    count += 1
        return count == len(arr)
    def print_coprime_path(root, path):
        if not root:
            return
        path.append(root.data)
        print_coprime_path(root.left, path)
        print_coprime_path(root.right, path)
        if not root.left and not root.right:
            if is_coprime(path):
                print(path)
        path.pop()
    print_coprime_path(root, path)

```"
107,"Number of subsets with same AND , OR and XOR values in an Array | Java implementation to find the number of subsets with equal bitwise AND , OR and XOR values ; Function to find the number of subsets with equal bitwise AND , OR and XOR values ; Traverse through all the subsets ; Finding the subsets with the bits of ' i ' which are set ; Computing the bitwise AND ; Computing the bitwise OR ; Computing the bitwise XOR ; Comparing all the three values ; Driver Code","```java
public static int countSubsets(int[] arr) {
    int count = 0;
    for (int i = 0; i < (1 << arr.length); i++) {
        int and = 0, or = 0, xor = 0;
        for (int j = 0; j < arr.length; j++) {
            if ((i & (1 << j)) != 0) {
                and &= arr[j];
                or |= arr[j];
                xor ^= arr[j];
            }
        }
        if (and == or && or == xor) {
            count++;
        }
    }
    return count;
}
```","```python
def count_subsets(arr):
  n = len(arr)
  count = 0
  for i in range(1 << n):
    and_val = 0
    or_val = 0
    xor_val = 0
    for j in range(n):
      if (i >> j) & 1:
        and_val &= arr[j]
        or_val |= arr[j]
        xor_val ^= arr[j]
    if and_val == or_val and or_val == xor_val:
      count += 1
  return count
```"
108,Count of Subsets containing only the given value K | Java implementation to find the number of subsets formed by the given value K ; Function to find the number of subsets formed by the given value K ; Count is used to maintain the number of continuous K 's ; Iterating through the array ; If the element in the array is equal to K ; count * ( count + 1 ) \/ 2 is the total number of subsets with only K as their element ; Change count to 0 because other element apart from K has been found ; To handle the last set of K 's ; Driver code,"```java
public static int countSubsetsWithK(int[] arr, int k) {
    int count = 0;
    int result = 0;
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == k) {
        count++;
      } else {
        result += count * (count + 1) / 2;
        count = 0;
      }
    }
    result += count * (count + 1) / 2;
    return result;
  }
```","```python
def countSubsetsWithK(arr, K):
  count = 0
  result = 0
  for i in range(len(arr)):
    if arr[i] == K:
      count += 1
    else:
      result += count * (count + 1) // 2
      count = 0
  result += count * (count + 1) // 2
  return result
```"
109,"Ternary number system or Base 3 numbers | Java program to convert decimal number to ternary number ; Function to convert a decimal number to a ternary number ; Base case ; Finding the remainder when N is divided by 3 ; Recursive function to call the function for the integer division of the value N \/ 3 ; Handling the negative cases ; Function to convert the decimal to ternary ; If the number is greater than 0 , compute the ternary representation of the number ; Driver Code","```java
public static String toTernary(int N) {
    if (N == 0) {
      return ""0"";
    }
    if (N < 0) {
      return ""-"" + toTernary(-N);
    }
    return toTernary(N / 3) + (N % 3);
  }
```","```python
def decimalToTernary(N):
  if N == 0:
    return ""0""
  if N < 0:
    return ""-"" + decimalToTernary(-N)
  result = """"
  while N > 0:
    result = str(N % 3) + result
    N //= 3
  return result
```"
110,"Largest number less than or equal to Z that leaves a remainder X when divided by Y | Java implementation to Find the largest non - negative number that is less than or equal to integer Z and leaves a remainder X when divided by Y ; Function to get the number ; remainder can ' t ▁ be ▁ larger ▁ ▁ than ▁ the ▁ largest ▁ number , ▁ ▁ if ▁ so ▁ then ▁ answer ▁ doesn ' t exist . ; reduce number by x ; finding the possible number that is divisible by y ; this number is always <= x as we calculated over z - x ; Driver Code ; initialise the three integers","```java
public static int findLargestNumber(int z, int x, int y) {
    if (x > z) {
      return -1;
    }
    return (z - x) / y * y + x;
  }
```","```python
def largest_number(z, x, y):
  if x >= y:
    return -1
  return z - x - ((z - x) % y)
```"
111,Find the conjugate of a Complex number | Java implementation to Find the conjugate of a complex number ; Function to find conjugate of a complex number ; store index of ' + ' ; store index of ' - ' ; print the result ; Driver code ; initialise the complex number,"```java
public static String findConjugate(String complexNumber) {
    int plusIndex = complexNumber.indexOf('+');
    int minusIndex = complexNumber.indexOf('-');
    if (plusIndex != -1) {
        return complexNumber.substring(0, plusIndex) + ""-"" + complexNumber.substring(plusIndex + 1);
    } else if (minusIndex != -1) {
        return complexNumber.substring(0, minusIndex) + ""+"" + complexNumber.substring(minusIndex + 1);
    } else {
        return complexNumber;
    }
}
```","```python
def conjugate(complex_num):
  plus_index = complex_num.find('+')
  minus_index = complex_num.find('-')
  if plus_index != -1:
    return complex_num[:plus_index] + complex_num[plus_index:].replace('+', '-')
  elif minus_index != -1:
    return complex_num[:minus_index] + complex_num[minus_index:].replace('-', '+')
  else:
    return complex_num
```"
112,Count of greater elements for each element in the Array | Java implementation of the above approach ; Store the frequency of the array elements ; Store the sum of frequency of elements greater than the current element ; Driver code,"```java
public static int[] countGreaterElements(int[] arr) {
    int n = arr.length;
    int[] frequency = new int[n];
    int[] result = new int[n];
    for (int i = 0; i < n; i++) {
      frequency[arr[i]]++;
    }
    for (int i = 0; i < n; i++) {
      for (int j = arr[i] + 1; j < n; j++) {
        result[i] += frequency[j];
      }
    }
    return result;
  }
```","```python
def count_greater_elements(arr):
  n = len(arr)
  freq = [0] * (n + 1)
  for i in range(n):
    freq[arr[i]] += 1
  result = [0] * n
  for i in range(n):
    sum_freq = 0
    for j in range(arr[i] + 1, n + 1):
      sum_freq += freq[j]
    result[i] = sum_freq
  return result
```"
113,"Minimum operations required to make two numbers equal | Java program to find minimum operations required to make two numbers equal ; Function to return the minimum operations required ; Keeping B always greater ; Reduce B such that gcd ( A , B ) becomes 1. ; Driver code","```java
public static int minOperations(int A, int B) {
    if (A > B) {
      int temp = A;
      A = B;
      B = temp;
    }
    while (gcd(A, B) != 1) {
      B -= A;
    }
    return B - A;
  }
  
  private static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
```","```python
def minOperations(A, B):
  if A > B:
    A, B = B, A
  while A != 1:
    B = B % A
    if B == 0:
      return A - 1
    A, B = B, A
  return B - 1
```"
114,Program to determine the Quadrant of a Complex number | Java program to determine the quadrant of a complex number ; Function to determine the quadrant of a complex number ; Storing the index of ' + ' ; Storing the index of ' - ' ; Finding the real part of the complex number ; Finding the imaginary part of the complex number ; Driver code,"```java
public static int quadrant(String complexNumber) {
    int plusIndex = complexNumber.indexOf('+');
    int minusIndex = complexNumber.indexOf('-');
    int realPart = Integer.parseInt(complexNumber.substring(0, plusIndex));
    int imaginaryPart = Integer.parseInt(complexNumber.substring(plusIndex + 1, minusIndex));
    if (realPart > 0 && imaginaryPart > 0) {
        return 1;
    } else if (realPart < 0 && imaginaryPart > 0) {
        return 2;
    } else if (realPart < 0 && imaginaryPart < 0) {
        return 3;
    } else if (realPart > 0 && imaginaryPart < 0) {
        return 4;
    } else {
        return 0;
    }
}
```","```python
def quadrant(complex_number):
  plus_index = complex_number.find('+')
  minus_index = complex_number.find('-')
  real_part = int(complex_number[:plus_index or minus_index])
  imaginary_part = int(complex_number[plus_index + 1 or minus_index + 1:-1])
  if real_part > 0 and imaginary_part > 0:
    return 1
  elif real_part < 0 and imaginary_part > 0:
    return 2
  elif real_part < 0 and imaginary_part < 0:
    return 3
  elif real_part > 0 and imaginary_part < 0:
    return 4
  else:
    return 0
```"
115,Sum and Product of all Fibonacci Nodes of a Singly Linked List | Java implementation to find the sum and product of all of the Fibonacci nodes in a singly linked list ; Node of the singly linked list ; Function to insert a node at the beginning of the singly Linked List ; Allocate new node ; Insert the data ; Link the old list to the new node ; Move the head to point the new node ; Function that returns the largest element from the linked list . ; Declare a max variable and initialize with Integer . MIN_VALUE ; Check loop while head not equal to null ; If max is less then head . data then assign value of head . data to max otherwise node points to next node . ; Function to create a hash table to check Fibonacci numbers ; Inserting the first two numbers in the hash ; Loop to add Fibonacci numbers upto the maximum element present in the linked list ; Function to find the required sum and product ; Find the largest node value in Singly Linked List ; Creating a set containing all the fibonacci numbers upto the maximum data value in the Singly Linked List ; Traverse the linked list ; If current node is fibonacci ; Find the sum and the product ; Driver code ; Create the linked list 15.16 . 8.6 .13,"```java
public static int[] sumAndProductFibonacciNodes(Node head) {
  int max = Integer.MIN_VALUE;
  while (head != null) {
    if (max < head.data) {
      max = head.data;
    }
    head = head.next;
  }
  Set<Integer> fibonacciNumbers = createFibonacciSet(max);
  int sum = 0;
  int product = 1;
  head = head;
  while (head != null) {
    if (fibonacciNumbers.contains(head.data)) {
      sum += head.data;
      product *= head.data;
    }
    head = head.next;
  }
  return new int[]{sum, product};
}

private static Set<Integer> createFibonacciSet(int max) {
  Set<Integer> fibonacciNumbers = new HashSet<>();
  fibonacciNumbers.add(0);
  fibonacciNumbers.add(1);
  int a = 0;
  int b = 1;
  while (b <= max) {
    int c = a + b;
    fibonacciNumbers.add(c);
    a = b;
    b = c;
  }
  return fibonacciNumbers;
}
```","```python
def sum_and_product_of_fibonacci_nodes(head):
  max_value = float('-inf')
  curr = head
  while curr:
    if curr.data > max_value:
      max_value = curr.data
    curr = curr.next
  
  fibonacci_set = set()
  fibonacci_set.add(0)
  fibonacci_set.add(1)
  a = 0
  b = 1
  while b <= max_value:
    c = a + b
    fibonacci_set.add(c)
    a = b
    b = c
  
  sum = 0
  product = 1
  curr = head
  while curr:
    if curr.data in fibonacci_set:
      sum += curr.data
      product *= curr.data
    curr = curr.next
  return sum, product
```"
116,Product of all Subarrays of an Array | Java program to find product of all subarray of an array ; Function to find product of all subarrays ; Variable to store the product ; Compute the product while traversing for subarrays ; Printing product of all subarray ; Driver code ; Function call,"```java
public static long productOfSubarrays(int[] arr) {
    long product = 1;
    for (int i = 0; i < arr.length; i++) {
      for (int j = i; j < arr.length; j++) {
        for (int k = i; k <= j; k++) {
          product *= arr[k];
        }
      }
    }
    return product;
  }
```","```python
def product_of_subarrays(arr):
  product = 1
  for i in range(len(arr)):
    for j in range(i, len(arr)):
      for k in range(i, j + 1):
        product *= arr[k]
  return product
```"
117,"Check if a N base number is Even or Odd | Java code to check if a Octal number is Even or Odd ; To return value of a char . ; Function to convert a number from N base to decimal ; power of base ; Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 1 ] * base + str [ len - 1 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Returns true if n is even , else odd ; Driver code","```java
public static boolean isEven(String str, int base) {
    int len = str.length();
    int decimal = 0;
    for (int i = 0; i < len; i++) {
      int digit = Character.getNumericValue(str.charAt(i));
      if (digit >= base) {
        return false;
      }
      decimal += digit * Math.pow(base, len - i - 1);
    }
    return decimal % 2 == 0;
  }
```","```python
def is_even_n_base(n, base):
  n = str(n)
  len = len(n)
  decimal = 0
  for i in range(len):
    decimal += int(n[i]) * (base ** (len - i - 1))
  return decimal % 2 == 0
```"
118,Find the next Factorial greater than N | Java implementation of the above approach ; Array that stores the factorial till 20 ; Function to pre - compute the factorial till 20 ; Precomputing factorials ; Function to return the next factorial number greater than N ; Traverse the factorial array ; Find the next just greater factorial than N ; Driver Code ; Function to precalculate the factorial till 20 ; Function call,"```java
public class NextFactorial {

    static long[] factorial = new long[21];

    public static void precomputeFactorial() {
        factorial[0] = 1;
        for (int i = 1; i <= 20; i++) {
            factorial[i] = factorial[i - 1] * i;
        }
    }

    public static long nextFactorial(long N) {
        for (int i = 0; i < factorial.length; i++) {
            if (factorial[i] > N) {
                return factorial[i];
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        precomputeFactorial();
        long N = 10;
        long nextFact = nextFactorial(N);
        System.out.println(""Next Factorial greater than "" + N + "" is: "" + nextFact);
    }
}
```","```python
def next_factorial(n):
  factorials = [1]
  for i in range(1, 21):
    factorials.append(factorials[i - 1] * i)
  for i in range(len(factorials)):
    if factorials[i] > n:
      return factorials[i]
```"
119,Find K distinct positive odd integers with sum N | Java implementation to find K odd positive integers such that their sum is equal to given number ; Function to find K odd positive integers such that their sum is N ; Condition to check if there are enough values to check ; Driver Code,"```java
public static boolean findKDistinctOddIntegers(int N, int K) {
    if (N < K || (N - K) % 2 != 0 || N <= 0 || K <= 0) {
        return false;
    }
    int[] result = new int[K];
    int currentSum = 0;
    for (int i = 0; i < K; i++) {
        result[i] = 1 + 2 * i;
        currentSum += result[i];
    }
    int remainingSum = N - currentSum;
    for (int i = 0; i < K && remainingSum > 0; i++) {
        int increment = Math.min(remainingSum, 2);
        result[i] += increment;
        remainingSum -= increment;
    }
    return remainingSum == 0;
}
```","```python
def find_k_odd_integers(N, K):
  if K <= 0 or N <= 0 or N % 2 != K % 2 or N < K:
    return []
  result = []
  for i in range(K):
    result.append(2 * i + 1)
  result[K - 1] = N - sum(result[:-1])
  return result
```"
120,Minimum number of operations to convert array A to array B by adding an integer into a subarray | Java implementation to find the minimum number of operations in which the array A can be converted to another array B ; Function to find the minimum number of operations in which array A can be converted to array B ; Loop to iterate over the array ; if both elements are equal then move to next element ; Calculate the difference between two elements ; loop while the next pair of elements have same difference ; Increase the number of operations by 1 ; Print the number of operations required ; Driver Code,"```java
public static int minOperations(int[] A, int[] B) {
    int operations = 0;
    for (int i = 0; i < A.length; i++) {
      if (A[i] == B[i]) {
        continue;
      }
      int diff = B[i] - A[i];
      int j = i + 1;
      while (j < A.length && B[j] - A[j] == diff) {
        j++;
      }
      operations++;
      i = j - 1;
    }
    return operations;
  }
```","```python
def minOperations(A, B):
  n = len(A)
  operations = 0
  i = 0
  while i < n:
    if A[i] == B[i]:
      i += 1
      continue
    diff = B[i] - A[i]
    j = i + 1
    while j < n and B[j] - A[j] == diff:
      j += 1
    operations += 1
    i = j
  return operations
```"
121,"Perfect Cube | Java program to check if a number is a perfect cube using prime factors ; Inserts the prime factor in the Hash Map if not present If present updates it 's frequency ; A utility function to find all prime factors of a given number N ; Insert the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ; While i divides n , insert i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to check if a number is a perfect cube ; Using values ( ) for iteration over keys ; Driver Code ; Function to check if N is perfect cube or not","```java
import java.util.*;
class Solution {
    public boolean isPerfectCube(int N) {
        if (N == 0) {
            return true;
        }
        if (N < 0) {
            N = -N;
        }
        HashMap<Integer, Integer> primeFactors = new HashMap<>();
        primeFactors = primeFactors(N);
        for (Integer key : primeFactors.values()) {
            if (key % 3 != 0) {
                return false;
            }
        }
        return true;
    }
    public HashMap<Integer, Integer> primeFactors(int n) {
        HashMap<Integer, Integer> primeFactors = new HashMap<>();
        if (n % 2 == 0) {
            primeFactors.put(2, 0);
            while (n % 2 == 0) {
                primeFactors.put(2, primeFactors.get(2) + 1);
                n /= 2;
            }
        }
        for (int i = 3; i * i <= n; i += 2) {
            if (n % i == 0) {
                primeFactors.put(i, 0);
                while (n % i == 0) {
                    primeFactors.put(i, primeFactors.get(i) + 1);
                    n /= i;
                }
            }
        }
        if (n > 2) {
            primeFactors.put(n, 1);
        }
        return primeFactors;
    }
    public static void main(String[] args) {
        Solution ob = new Solution();
        int N = 27;
        if (ob.isPerfectCube(N)) {
            System.out.println(N + "" is a perfect cube"");
        } else {
            System.out.println(N + "" is not a perfect cube"");
        }
    }
}
```","```python
def isPerfectCube(n):
  primeFactors = {}
  def primeFactorsOfNumber(n):
    if n % 2 == 0:
      primeFactors[2] = primeFactors.get(2, 0) + 1
      n //= 2
    i = 3
    while i * i <= n:
      if n % i == 0:
        primeFactors[i] = primeFactors.get(i, 0) + 1
        n //= i
      else:
        i += 2
    if n > 2:
      primeFactors[n] = primeFactors.get(n, 0) + 1
  primeFactorsOfNumber(n)
  for key in primeFactors.keys():
    if primeFactors[key] % 3 != 0:
      return False
  return True

n = int(input())
if isPerfectCube(n):
  print(""Yes"")
else:
  print(""No"")
```"
122,Count ways to reach the Nth stair using multiple 1 or 2 steps and a single step 3 | Java implementation to find the number the number of ways to reach Nth stair by taking 1 or 2 steps at a time and 3 rd step exactly once ; Single line to find factorial ; Function to find the number of ways ; Base Case ; Count of 2 - steps ; Count of 1 - steps ; Initial length of sequence ; Expected count of 2 - steps ; Loop to find the ways for every possible sequence ; Driver Code,"```java
public static int countWays(int n) {
    if (n < 0) {
        return 0;
    }
    if (n == 0) {
        return 1;
    }
    int count = 0;
    for (int i = 0; i <= n / 2; i++) {
        int twoSteps = i;
        int oneSteps = n - 2 * i - 1;
        if (oneSteps >= 0) {
            count += factorial(n - i) / (factorial(i) * factorial(oneSteps));
        }
    }
    return count;
}

public static int factorial(int n) {
    if (n == 0) {
        return 1;
    }
    return n * factorial(n - 1);
}
```","```python
def countWays(n):
  if n == 0:
    return 1
  elif n < 0:
    return 0
  else:
    count_2_steps = 0
    count_1_steps = 0
    for i in range(n//2 + 1):
      count_2_steps = count_2_steps + countWays(n - (2*i + 1))
    for i in range(n//3 + 1):
      count_1_steps = count_1_steps + countWays(n - (3 + i))
    return count_2_steps + count_1_steps
```"
123,Find N from the value of N ! | Java program to find a number such that the factorial of that number is given ; Map to precompute and store the factorials of the numbers ; Function to precompute factorial ; Calculating the factorial for each i and storing in a map ; Driver code ; Precomputing the factorials,"```java
import java.util.HashMap;
import java.util.Map;

public class FactorialFinder {

    public static int findN(long factorial) {
        Map<Integer, Long> factorialMap = precomputeFactorials(20);
        for (Map.Entry<Integer, Long> entry : factorialMap.entrySet()) {
            if (entry.getValue() == factorial) {
                return entry.getKey();
            }
        }
        return -1; 
    }

    private static Map<Integer, Long> precomputeFactorials(int n) {
        Map<Integer, Long> factorialMap = new HashMap<>();
        factorialMap.put(0, 1L);
        for (int i = 1; i <= n; i++) {
            factorialMap.put(i, factorialMap.get(i - 1) * i);
        }
        return factorialMap;
    }
}
```","```python
def find_n_from_factorial(factorial):
  factorials = {0: 1}
  i = 1
  while factorials[i - 1] < factorial:
    factorials[i] = factorials[i - 1] * i
    i += 1
  if factorials[i - 1] == factorial:
    return i - 1
  else:
    return -1 
```"
124,"Count of Leap Years in a given year range | Java implementation to find the count of leap years in given range of the year ; Function to calculate the number of leap years in range of ( 1 , year ) ; Function to calculate the number of leap years in given range ; Driver Code","```java
public static int countLeapYears(int year) {
    int count = 0;
    for (int i = 1; i <= year; i++) {
        if ((i % 4 == 0 && i % 100 != 0) || i % 400 == 0) {
            count++;
        }
    }
    return count;
}

public static int countLeapYearsInRange(int startYear, int endYear) {
    return countLeapYears(endYear) - countLeapYears(startYear - 1);
}

public static void main(String[] args) {
    int startYear = 1900;
    int endYear = 2023;
    int count = countLeapYearsInRange(startYear, endYear);
    System.out.println(""Number of leap years between "" + startYear + "" and "" + endYear + "": "" + count);
}
```","```python
def countLeapYears(year):
  return year // 4 - year // 100 + year // 400

def countLeapYearsInRange(startYear, endYear):
  return countLeapYears(endYear) - countLeapYears(startYear - 1)
```"
125,Ternary representation of Cantor set | Java implementation to find the cantor set for n levels and for a given start_num and end_num ; The Linked List Structure for the Cantor Set ; Function to initialize the Cantor Set List ; Function to propogate the list by adding new nodes for the next levels ; Modifying the start and end values for the next level ; Changing the pointers to the next node ; Recursively call the function to generate the Cantor Set for the entire level ; Function to print a level of the Set ; Function to build and display the Cantor Set for each level ; Driver code,"```java
import java.util.*;
class Node {
    int start;
    int end;
    Node next;
    Node(int start, int end) {
        this.start = start;
        this.end = end;
        this.next = null;
    }
}
class CantorSet {
    Node head;
    public CantorSet(int start_num, int end_num) {
        this.head = new Node(start_num, end_num);
    }
    public void propogate(int level) {
        if (level == 0) {
            return;
        }
        Node current = head;
        Node prev = null;
        while (current != null) {
            int mid = (current.start + current.end) / 3;
            Node newNode1 = new Node(current.start, mid);
            Node newNode2 = new Node(mid + (current.end - mid) / 3, current.end);
            if (prev != null) {
                prev.next = newNode1;
            }
            newNode1.next = newNode2;
            newNode2.next = current.next;
            prev = newNode2;
            current = current.next;
        }
        propogate(level - 1);
    }
    public void printLevel(int level) {
        Node current = head;
        for (int i = 0; i < level; i++) {
            current = current.next;
        }
        while (current != null) {
            System.out.print(""("" + current.start + "", "" + current.end + "") "");
            current = current.next;
        }
        System.out.println();
    }
    public void buildAndDisplay(int levels) {
        propogate(levels);
        for (int i = 0; i <= levels; i++) {
            System.out.print(""Level "" + i + "": "");
            printLevel(i);
        }
    }
}
public class CantorSetMain {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print(""Enter start number: "");
        int start_num = sc.nextInt();
        System.out.print(""Enter end number: "");
        int end_num = sc.nextInt();
        System.out.print(""Enter number of levels: "");
        int levels = sc.nextInt();
        CantorSet cantorSet = new CantorSet(start_num, end_num);
        cantorSet.buildAndDisplay(levels);
    }
}
```","```python
class Node:
    def __init__(self, start, end):
        self.start = start
        self.end = end
        self.next = None

def initialize_cantor_set(start_num, end_num):
    head = Node(start_num, end_num)
    return head

def propagate_list(head, level):
    if level == 0:
        return
    current = head
    while current:
        new_node = Node(current.start + (current.end - current.start) / 3, current.start + 2 * (current.end - current.start) / 3)
        new_node.next = current.next
        current.next = new_node
        current = new_node.next
        current = current.next
    propagate_list(head, level - 1)

def modify_start_end(head, level):
    if level == 0:
        return
    current = head
    while current:
        current.start = current.start + (current.end - current.start) / 3
        current.end = current.end - (current.end - current.start) / 3
        current = current.next
    modify_start_end(head, level - 1)

def print_level(head):
    current = head
    while current:
        print(f""[{current.start:.2f}, {current.end:.2f}]"", end=' ')
        current = current.next
    print()

def build_and_display_cantor_set(start_num, end_num, levels):
    head = initialize_cantor_set(start_num, end_num)
    for i in range(levels):
        print(f""Level {i+1}:"", end=' ')
        print_level(head)
        propagate_list(head, i + 1)
        modify_start_end(head, i + 1)

def main():
    start_num = 0
    end_num = 1
    levels = 4
    build_and_display_cantor_set(start_num, end_num, levels)

if __name__ == ""__main__"":
    main()
```"
126,Find sum of f ( s ) for all the chosen sets from the given array | Java implementation of the approach ; To store the factorial and the factorial mod inverse of a number ; Function to find ( a ^ m1 ) % mod ; Function to find factorial of all the numbers ; Function to find the factorial mod inverse of all the numbers ; Function to return nCr ; Function to find sum of f ( s ) for all the chosen sets from the given array ; Sort the given array ; Calculate the factorial and modinverse of all elements ; For all the possible sets Calculate max ( S ) and min ( S ) ; Driver code,"```java
import java.util.*;
public class Solution {
    static final int MOD = 1000000007;
    static long[] fact, ifact;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        Arrays.sort(a);
        fact = new long[n + 1];
        ifact = new long[n + 1];
        precomputeFactorial(n);
        long ans = 0;
        for (int i = 0; i < (1 << n); i++) {
            int max = 0, min = Integer.MAX_VALUE;
            for (int j = 0; j < n; j++) {
                if ((i & (1 << j)) != 0) {
                    max = Math.max(max, a[j]);
                    min = Math.min(min, a[j]);
                }
            }
            ans = (ans + f(max, min)) % MOD;
        }
        System.out.println(ans);
    }
    static long f(int max, int min) {
        return modPow(max, min, MOD);
    }
    static void precomputeFactorial(int n) {
        fact[0] = 1;
        for (int i = 1; i <= n; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        ifact[n] = modInverse(fact[n], MOD);
        for (int i = n - 1; i >= 0; i--) {
            ifact[i] = (ifact[i + 1] * (i + 1)) % MOD;
        }
    }
    static long modInverse(long a, long m) {
        return modPow(a, m - 2, m);
    }
    static long modPow(long a, long m, long mod) {
        long res = 1;
        while (m > 0) {
            if ((m & 1) == 1) {
                res = (res * a) % mod;
            }
            a = (a * a) % mod;
            m >>= 1;
        }
        return res;
    }
    static long nCr(int n, int r) {
        if (r < 0 || r > n) {
            return 0;
        }
        return (fact[n] * ifact[r] % MOD * ifact[n - r] % MOD) % MOD;
    }
}
```","```python
def find_sum_of_f_s(arr, mod):
  n = len(arr)
  arr.sort()
  fact = [1] * (n + 1)
  inv_fact = [1] * (n + 1)
  for i in range(1, n + 1):
    fact[i] = (fact[i - 1] * i) % mod
    inv_fact[i] = pow(fact[i], mod - 2, mod)
  sum = 0
  for i in range(1 << n):
    max_s = -1
    min_s = 10**9
    for j in range(n):
      if (i >> j) & 1:
        max_s = max(max_s, arr[j])
        min_s = min(min_s, arr[j])
    if max_s != -1 and min_s != 10**9:
      sum = (sum + (fact[n] * inv_fact[max_s - min_s + 1] * inv_fact[n - (max_s - min_s + 1)]) % mod) % mod
  return sum
```"
127,Length of Smallest subarray in range 1 to N with sum greater than a given value | Java implementation of the above implementation ; Function to return the count of minimum elements such that the sum of those elements is > S . ; Initialize currentSum = 0 ; Loop from N to 1 to add the numbers and check the condition . ; Driver code,"```java
public static int minSubArrayLen(int S, int[] nums) {
    int minLen = Integer.MAX_VALUE;
    int currentSum = 0;
    int j = 0;
    for (int i = 0; i < nums.length; i++) {
        currentSum += nums[i];
        while (currentSum >= S) {
            minLen = Math.min(minLen, i - j + 1);
            currentSum -= nums[j];
            j++;
        }
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}
```","```python
def minSubArrayLen(s, nums):
  n = len(nums)
  minLen = float('inf')
  currentSum = 0
  start = 0
  for end in range(n):
    currentSum += nums[end]
    while currentSum >= s:
      minLen = min(minLen, end - start + 1)
      currentSum -= nums[start]
      start += 1
  return minLen if minLen != float('inf') else 0
```"
128,Next Number with distinct digits | Java program to find next consecutive Number with all distinct digits ; Function to count distinct digits in a number ; To count the occurrence of digits in number from 0 to 9 ; Iterate over the digits of the number Flag those digits as found in the array ; Traverse the array arr and count the distinct digits in the array ; Function to return the total number of digits in the number ; Iterate over the digits of the number ; Function to return the next number with distinct digits ; Count the distinct digits in N + 1 ; Count the total number of digits in N + 1 ; Return the next consecutive number ; Increment Number by 1 ; Driver code,"```java
public static int nextDistinctDigitsNumber(int N) {
    int next = N + 1;
    while (true) {
        if (countDistinctDigits(next) == countDigits(next)) {
            return next;
        }
        next++;
    }
}

private static int countDistinctDigits(int num) {
    int[] arr = new int[10];
    while (num > 0) {
        arr[num % 10]++;
        num /= 10;
    }
    int count = 0;
    for (int i = 0; i < 10; i++) {
        if (arr[i] > 0) {
            count++;
        }
    }
    return count;
}

private static int countDigits(int num) {
    int count = 0;
    while (num > 0) {
        count++;
        num /= 10;
    }
    return count;
}
```","```python
def next_number_with_distinct_digits(N):
    def count_distinct_digits(num):
        arr = [0] * 10
        while num > 0:
            digit = num % 10
            arr[digit] += 1
            num //= 10
        distinct_count = 0
        for i in range(10):
            if arr[i] > 0:
                distinct_count += 1
        return distinct_count

    def count_total_digits(num):
        count = 0
        while num > 0:
            count += 1
            num //= 10
        return count

    N += 1
    while True:
        distinct_digits = count_distinct_digits(N)
        total_digits = count_total_digits(N)
        if distinct_digits == total_digits:
            return N
        N += 1
```"
129,Minimum possible sum of array B such that AiBi = AjBj for all 1 â ‰¤ i < j â ‰¤ N | Java implementation of the approach ; To store least prime factors of all the numbers ; Function to find the least prime factor of all the numbers ; Function to return the ( ( a ^ m1 ) % mod ) ; Function to return the sum of elements of array B ; Find the prime factors of all the numbers ; To store each prime count in lcm ; Current number ; Map to store the prime count of a single number ; Basic way to calculate all prime factors ; If it is the first number in the array ; Take the maximum count of prime in a number ; Calculate lcm of given array ; Calculate sum of elements of array B ; Driver code,"```java
import java.util.*;
public class Solution {
    static int[] spf;
    public static void sieve(int n) {
        spf = new int[n + 1];
        for (int i = 2; i * i <= n; i++) {
            if (spf[i] == 0) {
                for (int j = i * i; j <= n; j += i) {
                    if (spf[j] == 0) {
                        spf[j] = i;
                    }
                }
            }
        }
        for (int i = 2; i <= n; i++) {
            if (spf[i] == 0) {
                spf[i] = i;
            }
        }
    }
    public static int getSmallestPrimeFactor(int x) {
        return spf[x];
    }
    public static int power(int a, int m1, int mod) {
        int res = 1;
        while (m1 > 0) {
            if ((m1 & 1) == 1) {
                res = (res * a) % mod;
            }
            a = (a * a) % mod;
            m1 >>= 1;
        }
        return res;
    }
    public static int sumArray(int[] b) {
        int sum = 0;
        for (int i = 0; i < b.length; i++) {
            sum += b[i];
        }
        return sum;
    }
    public static int findMinSum(int[] a) {
        int n = a.length;
        sieve(1000000);
        int lcm = 1;
        Map<Integer, Integer> primeCount = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int currNum = a[i];
            while (currNum > 1) {
                int prime = getSmallestPrimeFactor(currNum);
                if (i == 0) {
                    primeCount.put(prime, 1);
                } else {
                    if (primeCount.containsKey(prime)) {
                        primeCount.put(prime, Math.max(primeCount.get(prime), 1));
                    } else {
                        primeCount.put(prime, 1);
                    }
                }
                currNum /= prime;
            }
        }
        for (Map.Entry<Integer, Integer> entry : primeCount.entrySet()) {
            lcm = (lcm * power(entry.getKey(), entry.getValue(), 1000000007)) % 1000000007;
        }
        int[] b = new int[n];
        for (int i = 0; i < n; i++) {
            b[i] = lcm / a[i];
        }
        return sumArray(b);
    }
    public static void main(String[] args) {
        int[] a = {2, 4, 6};
        System.out.println(findMinSum(a));
    }
}
```","```python
def minSum(arr, n):
  def leastPrimeFactor(n):
    prime = [True] * (n + 1)
    p = 2
    while p * p <= n:
      if prime[p]:
        for i in range(p * p, n + 1, p):
          prime[i] = False
      p += 1
    return prime

  def power(a, m1, mod):
    res = 1
    a %= mod
    while m1 > 0:
      if m1 & 1:
        res = (res * a) % mod
      a = (a * a) % mod
      m1 >>= 1
    return res

  def sumOfArray(arr, n):
    sum = 0
    for i in range(n):
      sum += arr[i]
    return sum

  prime = leastPrimeFactor(1000000)
  lcm = [0] * (1000000 + 1)
  for i in range(n):
    current = arr[i]
    count = {}
    while current > 1:
      p = prime[current]
      if p in count:
        count[p] += 1
      else:
        count[p] = 1
      current //= p
    if i == 0:
      for p in count:
        lcm[p] = count[p]
    else:
      for p in count:
        lcm[p] = max(lcm[p], count[p])
  b = [0] * (1000000 + 1)
  for p in range(1, 1000000 + 1):
    if lcm[p] > 0:
      b[p] = power(p, lcm[p], 1000000007)
  return sumOfArray(b, 1000000 + 1)
```"
130,"Find Number of Even cells in a Zero Matrix after Q queries | Java program find Number of Even cells in a Zero Matrix after Q queries ; Function to find the number of even cell in a 2D matrix ; Maintain two arrays , one for rows operation and one for column operation ; Increment operation on row [ i ] ; Increment operation on col [ i ] ; Count odd and even values in both arrays and multiply them ; Count of rows having even numbers ; Count of rows having odd numbers ; Count of columns having even numbers ; Count of columns having odd numbers ; Driver code","```java
public static int findEvenCells(int[][] matrix, int[][] queries) {
    int[] rows = new int[matrix.length];
    int[] cols = new int[matrix[0].length];
    for (int[] query : queries) {
        rows[query[0]]++;
        cols[query[1]]++;
    }
    int evenRows = 0, oddRows = 0, evenCols = 0, oddCols = 0;
    for (int i = 0; i < rows.length; i++) {
        if (rows[i] % 2 == 0) {
            evenRows++;
        } else {
            oddRows++;
        }
    }
    for (int i = 0; i < cols.length; i++) {
        if (cols[i] % 2 == 0) {
            evenCols++;
        } else {
            oddCols++;
        }
    }
    return evenRows * evenCols + oddRows * oddCols;
}
```","```python
def countEvenCells(matrix, queries):
  rows = [0] * len(matrix)
  cols = [0] * len(matrix[0])
  for i, j in queries:
    rows[i] += 1
    cols[j] += 1
  evenRows = rows.count(0) + rows.count(2) + rows.count(4) 
  oddRows = rows.count(1) + rows.count(3)
  evenCols = cols.count(0) + cols.count(2) + cols.count(4) 
  oddCols = cols.count(1) + cols.count(3)
  return evenRows * evenCols + oddRows * oddCols
```"
131,Find maximum unreachable height using two ladders | Java implementation of the approach ; Function to return the maximum height which can 't be reached ; Driver code,"```java
public static double maxUnreachableHeight(double x1, double y1, double x2, double y2) {
    double maxReach = 0;
    double currentHeight = 0;
    while (currentHeight <= x1 + y1 || currentHeight <= x2 + y2) {
      maxReach = currentHeight;
      if (x1 + y1 > x2 + y2) {
        currentHeight += x1;
        x1 = 0;
      } else {
        currentHeight += x2;
        x2 = 0;
      }
    }
    return maxReach;
  }
```","```python
def maxUnreachableHeight(A, B, C):
  return max(A + B - C, A + C - B, B + C - A)
```"
132,"Fermat 's Factorization Method | Java implementation of fermat 's factorization ; This function finds the value of a and b and returns a + b and a - b ; since fermat 's factorization applicable  for odd positive integers only ; check if n is a even number ; if n is a perfect root , then both its square roots are its factors ; Driver Code","```java
public static int[] fermatFactorization(int n) {
    if (n % 2 == 0) {
        return null;
    }
    int a = (int) Math.ceil(Math.sqrt(n));
    int b = 0;
    while (a * a - b * b != n) {
      a++;
      b = (int) Math.sqrt(a * a - n);
    }
    return new int[] { a + b, a - b };
  }
```","```python
import math

def fermat_factorization(n):
  if n % 2 == 0:
    return None
  a = math.ceil(math.sqrt(n))
  b_squared = a * a - n
  b = int(math.sqrt(b_squared))
  if b * b == b_squared:
    return a + b, a - b
  return None
```"
133,Append two elements to make the array satisfy the given condition | Java implementation of the approach ; Function to find the required numbers ; Find the sum and xor ; Print the required elements ; Driver code,"```java
public static void findElements(int[] arr, int n, int sum, int xor) {
    int sumArr = 0;
    int xorArr = 0;
    for (int i = 0; i < n; i++) {
      sumArr += arr[i];
      xorArr ^= arr[i];
    }
    int x = (sum - sumArr) / 2;
    int y = (xor ^ xorArr) ^ x;
    System.out.println(x + "" "" + y);
  }
```","```python
def find_elements(arr, target_sum, target_xor):
  n = len(arr)
  sum_arr = sum(arr)
  xor_arr = 0
  for i in range(n):
    xor_arr ^= arr[i]
  required_sum = target_sum - sum_arr
  required_xor = target_xor ^ xor_arr
  print(required_sum, required_xor)
```"
134,"Satisfy the parabola when point ( A , B ) and the equation is given | Java implementation of the approach ; Function to find the required values ; Driver code","```java
public static boolean satisfyParabola(double a, double b, double[] coeff) {
    return Math.pow(a, 2) * coeff[0] + a * coeff[1] + coeff[2] == b;
}
```","```python
def parabola(a, b, equation):
  """"""
  This function takes a point (a, b) and an equation of a parabola as input,
  and returns a list containing the values of 'c' and 'd' for the parabola,
  if the point lies on the parabola, else returns an empty list.
  """"""
  try:
    # Extract coefficients from the equation
    parts = equation.split(""="")
    if len(parts) != 2:
      return []
    right_side = parts[1].strip()
    if right_side.startswith(""x^2""):
      coefficient_x_squared = int(right_side[1:right_side.index(""x^2"")].strip())
    else:
      return []
    if ""+"" in right_side:
      coefficient_x = int(right_side[right_side.index(""+"") + 1:right_side.index(""x"")].strip())
    elif ""-"" in right_side:
      coefficient_x = int(right_side[right_side.index(""-"") + 1:right_side.index(""x"")].strip())
    else:
      coefficient_x = 0
    coefficient_c = int(right_side[right_side.index("" "") + 1:].strip())

    # Substitute the values of 'a' and 'b' in the equation
    left_side = coefficient_x_squared * a * a + coefficient_x * a + coefficient_c
    if left_side == b:
      # Calculate the value of 'd'
      d = coefficient_c - coefficient_x * a
      return [coefficient_c, d]
    else:
      return []
  except:
    return []
```"
135,Largest number dividing maximum number of elements in the array | Java implementation of the approach ; Function to return the largest number that divides the maximum elements from the given array ; Finding gcd of all the numbers in the array ; Driver code,"```java
public static int largestDivisor(int[] arr) {
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    int gcd = arr[0];
    for (int i = 1; i < arr.length; i++) {
        gcd = gcd(gcd, arr[i]);
    }
    return gcd;
}

private static int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}
```","```python
def largest_divisor(arr):
  n = len(arr)
  max_num = max(arr)
  gcd = arr[0]
  for i in range(1, n):
    gcd =  math.gcd(gcd, arr[i])
  return gcd
```"
136,Check if the sum of digits of N is palindrome | Java implementation of the approach ; Function to return the sum of digits of n ; Function that returns true if n is palindrome ; Find the appropriate divisor to extract the leading digit ; If first and last digit not same return false ; Removing the leading and trailing digit from number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Function that returns true if the digit sum of n is palindrome ; Sum of the digits of n ; If the digit sum is palindrome ; Driver code,"```java
public static boolean isSumOfDigitsPalindrome(int n) {
    return isPalindrome(sumOfDigits(n));
}

public static int sumOfDigits(int n) {
    int sum = 0;
    while (n > 0) {
        sum += n % 10;
        n /= 10;
    }
    return sum;
}

public static boolean isPalindrome(int n) {
    if (n < 10) {
        return true;
    }
    int divisor = 1;
    while (n / divisor >= 10) {
        divisor *= 10;
    }
    if (n / divisor != n % 10) {
        return false;
    }
    n = (n % divisor) / 10;
    divisor /= 100;
    return isPalindrome(n);
}

public static void main(String[] args) {
    int n = 12321;
    if (isSumOfDigitsPalindrome(n)) {
        System.out.println(""The sum of digits of "" + n + "" is a palindrome."");
    } else {
        System.out.println(""The sum of digits of "" + n + "" is not a palindrome."");
    }
}
```","```python
def sum_of_digits(n):
  sum = 0
  while n > 0:
    sum += n % 10
    n //= 10
  return sum

def is_palindrome(n):
  divisor = 1
  while n // divisor >= 10:
    divisor *= 10
  if n // divisor != n % 10:
    return False
  n = (n % divisor) // 10
  divisor //= 2
  return n == 0 or is_palindrome(n)

def is_digit_sum_palindrome(n):
  sum = sum_of_digits(n)
  return is_palindrome(sum)

n = int(input())
if is_digit_sum_palindrome(n):
  print(""The sum of digits of"", n, ""is a palindrome."")
else:
  print(""The sum of digits of"", n, ""is not a palindrome."")
```"
137,Find the value of N XOR 'ed to itself K times | Java implementation of the approach ; Function to return n ^ n ^ ... k times ; If k is odd the answer is the number itself ; Else the answer is 0 ; Driver code,"```java
public static int xorKTimes(int n, int k) {
    if (k % 2 == 1) {
        return n;
    } else {
        return 0;
    }
}
```","```python
def xor_k_times(n, k):
  if k % 2 == 1:
    return n
  else:
    return 0
```"
138,Find the sum of the costs of all possible arrangements of the cells | Java implementation of the approach ; To store the factorials and factorial mod inverse of the numbers ; Function to return ( a ^ m1 ) % mod ; Function to find the factorials of all the numbers ; Function to find factorial mod inverse of all the numbers ; Function to return nCr ; Function to return the sum of the costs of all the possible arrangements of the cells ; For all possible X 's ; For all possible Y 's ; Driver code,"```java
import java.util.*;
import java.lang.*;

class Solution {
    static final int mod = 1000000007;
    static long[] fact, ifact;

    public static long power(long a, long m1) {
        long res = 1;
        while (m1 > 0) {
            if (m1 % 2 == 1) {
                res = (res * a) % mod;
            }
            a = (a * a) % mod;
            m1 /= 2;
        }
        return res;
    }

    public static void factorial(int n) {
        fact = new long[n + 1];
        fact[0] = 1;
        for (int i = 1; i <= n; i++) {
            fact[i] = (fact[i - 1] * i) % mod;
        }
    }

    public static void modInverse(int n) {
        ifact = new long[n + 1];
        ifact[n] = power(fact[n], mod - 2);
        for (int i = n - 1; i >= 0; i--) {
            ifact[i] = (ifact[i + 1] * (i + 1)) % mod;
        }
    }

    public static long nCr(int n, int r) {
        if (r > n) {
            return 0;
        }
        return (fact[n] * ifact[r] % mod * ifact[n - r] % mod) % mod;
    }

    public static long findSumOfCosts(int[][] cost) {
        int n = cost.length, m = cost[0].length;
        long sum = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                sum = (sum + (nCr(n - 1 + m - 1, i + j) * cost[i][j]) % mod) % mod;
            }
        }
        return sum;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        int[][] cost = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cost[i][j] = sc.nextInt();
            }
        }
        factorial(n + m - 2);
        modInverse(n + m - 2);
        System.out.println(findSumOfCosts(cost));
    }
}
```","```python
def power(a, m, mod):
  res = 1
  while m > 0:
    if m % 2 == 1:
      res = (res * a) % mod
    m //= 2
    a = (a * a) % mod
  return res

def factorial(n):
  fact = [1] * (n + 1)
  for i in range(2, n + 1):
    fact[i] = (fact[i - 1] * i) % mod
  return fact

def factorial_mod_inverse(n, fact, mod):
  inverse = [1] * (n + 1)
  inverse[n] = power(fact[n], mod - 2, mod)
  for i in range(n - 1, -1, -1):
    inverse[i] = (inverse[i + 1] * (i + 1)) % mod
  return inverse

def nCr(n, r, fact, inverse, mod):
  if r > n:
    return 0
  return ((fact[n] * inverse[r]) % mod * inverse[n - r]) % mod

def sum_of_costs(X, Y, fact, inverse, mod):
  total_cost = 0
  for i in range(1, X + 1):
    for j in range(1, Y + 1):
      cost = (nCr(i + j - 2, i - 1, fact, inverse, mod) * (i * j)) % mod
      total_cost = (total_cost + cost) % mod
  return total_cost

mod = 1000000007
X = 5
Y = 3
fact = factorial(X + Y)
inverse = factorial_mod_inverse(X + Y, fact, mod)
result = sum_of_costs(X, Y, fact, inverse, mod)
print(result)
```"
139,Find the Nth digit in the proper fraction of two numbers | Java implementation of the approach ; Function to print the Nth digit in the fraction ( p \/ q ) ; To store the resultant digit ; While N > 0 compute the Nth digit by dividing p and q and store the result into variable res and go to next digit ; Driver code,"```java
public static int findNthDigit(int p, int q, int N) {
    int res = 0;
    while (N > 0) {
        res = (p * 10) / q;
        p = (p * 10) % q;
        N--;
    }
    return res;
}
```","```python
def findNthDigit(p, q, N):
  res = 0
  while N > 0:
    res = (p * 10) // q
    p = (p * 10) % q
    N -= 1
  return res
```"
140,Sum of the updated array after performing the given operation | Java implementation of the approach ; Utility function to return the sum of the array ; Function to return the sum of the modified array ; Subtract the subarray sum ; Sum of subarray arr [ i ... n - 1 ] ; Return the sum of the modified array ; Driver code,"```java
public static int sumOfUpdatedArray(int[] arr, int i, int n) {
    int sum = 0;
    for (int j = i; j < n; j++) {
        sum += arr[j];
    }
    return sum;
}

public static int sumOfModifiedArray(int[] arr, int i, int n) {
    int sum = 0;
    for (int j = 0; j < i; j++) {
        sum += arr[j];
    }
    sum += sumOfUpdatedArray(arr, i, n);
    return sum;
}
```","```python
def sum_of_updated_array(arr, n, i, k):
  subarray_sum = 0
  for j in range(i, n):
    subarray_sum += arr[j]
  for j in range(i, n):
    arr[j] -= k
  return sum(arr) 
```"
141,Find closest integer with the same weight | Java implementation of the approach ; Function to return the number closest to x which has equal number of set bits as x ; Loop for each bit in x and compare with the next bit ; Driver code,"```java
public static int closestIntegerWithSameWeight(int x) {
    for (int i = 0; i < 31; i++) {
        if (((x >> i) & 1) != ((x >> (i + 1)) & 1)) {
            return x ^ (1 << i) ^ (1 << (i + 1));
        }
    }
    return x;
}
```","```python
def find_closest_with_same_weight(x):
  for i in range(32):
    if (x >> i) & 1 != (x >> (i + 1)) & 1:
      return x ^ (1 << i) ^ (1 << (i + 1))
  return x
```"
142,Cake Distribution Problem | Java implementation of the approach ; Function to return the remaining count of cakes ; Sum for 1 cycle ; no . of full cycle and remainder ; Driver Code,"```java
public static int distributeCake(int n, int k) {
    int sum = 0;
    int cycle = n / k;
    int remainder = n % k;
    return remainder;
  }
```","```python
def distributeCake(n, k):
  full_cycles = n // k
  remainder = n % k
  return remainder
```"
143,Find the number of squares inside the given square grid | Java implementation of the approach ; Function to return the number of squares inside an n * n grid ; Driver code,"```java
public static int countSquares(int n) {
    return n * (n + 1) * (2 * n + 1) / 6;
}
```","```python
def countSquares(n):
  return n * (n + 1) * (2 * n + 1) // 6
```"
144,Find all palindrome numbers of given digits | Java implementation of the approach ; Function to return the reverse of num ; Function that returns true if num is palindrome ; If the number is equal to the reverse of it then it is a palindrome ; Function to print all the d - digit palindrome numbers ; Smallest and the largest d - digit numbers ; Starting from the smallest d - digit number till the largest ; If the current number is palindrome ; Driver code,"```java
public static void printPalindromes(int d) {
    int smallest = (int) Math.pow(10, d - 1);
    int largest = (int) Math.pow(10, d) - 1;
    for (int i = smallest; i <= largest; i++) {
        if (isPalindrome(i)) {
            System.out.print(i + "" "");
        }
    }
}

public static int reverse(int num) {
    int rev = 0;
    while (num != 0) {
        rev = rev * 10 + num % 10;
        num /= 10;
    }
    return rev;
}

public static boolean isPalindrome(int num) {
    return num == reverse(num);
}
```","```python
def reverse(num):
  rev = 0
  while num > 0:
    dig = num % 10
    rev = rev * 10 + dig
    num //= 10
  return rev

def isPalindrome(num):
  return num == reverse(num)

def printPalindromes(d):
  smallest = 10**(d-1)
  largest = 10**d - 1
  for i in range(smallest, largest + 1):
    if isPalindrome(i):
      print(i, end="" "")
```"
145,Find X and Y intercepts of a line passing through the given points | Java implementation of the approach ; Function to find the X and Y intercepts of the line passing through the given points ; if line is parallel to y axis ; x - intercept will be p [ 0 ] ; y - intercept will be infinity ; if line is parallel to x axis ; x - intercept will be infinity ; y - intercept will be p [ 1 ] ; Slope of the line ; y = mx + c in where c is unknown Use any of the given point to find c ; For finding the x - intercept put y = 0 ; For finding the y - intercept put x = 0 ; Driver code,"```java
public static void findIntercepts(int[] p, int[] q) {
    if (p[0] == q[0]) {
        System.out.println(""X-intercept: "" + p[0]);
        System.out.println(""Y-intercept: Infinity"");
    } else if (p[1] == q[1]) {
        System.out.println(""X-intercept: Infinity"");
        System.out.println(""Y-intercept: "" + p[1]);
    } else {
        double m = (double) (q[1] - p[1]) / (q[0] - p[0]);
        double c = p[1] - m * p[0];
        double xIntercept = -c / m;
        double yIntercept = c;
        System.out.println(""X-intercept: "" + xIntercept);
        System.out.println(""Y-intercept: "" + yIntercept);
    }
}
```","```python
def find_intercepts(p1, p2):
  if p1[0] == p2[0]:
    return (p1[0], float('inf')) if p1[1] != p2[1] else (float('inf'), p1[1])
  m = (p2[1] - p1[1]) / (p2[0] - p1[0])
  c = p1[1] - m * p1[0]
  x_intercept = -c / m
  y_intercept = c
  return (x_intercept, y_intercept)
```"
146,"Minimum number of moves to reach N starting from ( 1 , 1 ) | Java implementation of the approach ; Function to return the minimum number of moves required to reach the cell containing N starting from ( 1 , 1 ) ; To store the required answer ; For all possible values of divisors ; If i is a divisor of n ; Get the moves to reach n ; Return the required answer ; Driver code","```java
public static int minMoves(int n) {
    int ans = Integer.MAX_VALUE;
    for (int i = 1; i * i <= n; i++) {
      if (n % i == 0) {
        ans = Math.min(ans, i - 1 + n / i - 1);
        if (i != n / i) {
          ans = Math.min(ans, n / i - 1 + i - 1);
        }
      }
    }
    return ans;
  }
```","```python
def minMoves(n):
  ans = float('inf')
  for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
      ans = min(ans, abs(i - 1) + abs(n // i - 1))
  return ans
```"
147,Minimum possible value of ( i * j ) % 2019 | Java implementation of the approach ; Function to return the minimum possible value of ( i * j ) % 2019 ; If we can get a number divisible by 2019 ; Find the minimum value by running nested loops ; Driver code,"```java
public static int minPossibleValue(int i, int j) {
    int min = Integer.MAX_VALUE;
    for (int x = 1; x <= i; x++) {
        for (int y = 1; y <= j; y++) {
            min = Math.min(min, (x * y) % 2019);
        }
    }
    return min;
}
```","```python
def min_possible_value(n):
  min_val = 2019
  for i in range(1, n + 1):
    for j in range(1, n + 1):
      if (i * j) % 2019 < min_val:
        min_val = (i * j) % 2019
  return min_val
```"
148,Represent ( 2 \/ N ) as the sum of three distinct positive integers of the form ( 1 \/ m ) | Java implementation of the approach ; Function to find the required fractions ; Base condition ; For N > 1 ; Driver code,"```java
public static boolean findFractions(int N, int[] result) {
    if (N <= 1) {
        return false;
    }
    for (int i = 1; i < N; i++) {
        for (int j = i + 1; j < N; j++) {
            for (int k = j + 1; k <= N; k++) {
                if ((double) 1 / i + (double) 1 / j + (double) 1 / k == (double) 2 / N) {
                    result[0] = i;
                    result[1] = j;
                    result[2] = k;
                    return true;
                }
            }
        }
    }
    return false;
}
```","```python
def find_fractions(N):
  if N > 1:
    return [1 / (N - 1), 1 / 2, 1 / (N * (N - 1) / 2)]
  else:
    return []
```"
149,Count the pairs in an array such that the difference between them and their indices is equal | Java implementation of the approach ; Function to return the count of all valid pairs ; To store the frequencies of ( arr [ i ] - i ) ; To store the required count ; If cnt is the number of elements whose difference with their index is same then ( ( cnt * ( cnt - 1 ) ) \/ 2 ) such pairs are possible ; Driver code,"```java
public static int countPairs(int[] arr) {
    int[] freq = new int[2 * arr.length + 1];
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
      freq[arr[i] - i + arr.length]++;
    }
    for (int i = 0; i < freq.length; i++) {
      count += freq[i] * (freq[i] - 1) / 2;
    }
    return count;
  }
```","```python
def countPairs(arr):
  freq = {}
  count = 0
  for i in range(len(arr)):
    diff = arr[i] - i
    if diff in freq:
      freq[diff] += 1
    else:
      freq[diff] = 1
  for cnt in freq.values():
    count += (cnt * (cnt - 1)) // 2
  return count
```"
150,Minimum possible number with the given operation | Function to return the minimum possible integer that can be obtained from the given integer after performing the given operations ; For every digit ; Digits less than 5 need not to be changed as changing them will lead to a larger number ; The resulting integer cannot have leading zero ; Driver code,"```java
public static int minPossibleNumber(int num) {
    String str = String.valueOf(num);
    StringBuilder sb = new StringBuilder();
    if (str.charAt(0) == '0') {
        sb.append('0');
        for (int i = 1; i < str.length(); i++) {
            if (str.charAt(i) < '5') {
                sb.append(str.charAt(i));
            } else {
                sb.append('9');
            }
        }
    } else {
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) < '5') {
                sb.append(str.charAt(i));
            } else {
                sb.append('9');
            }
        }
    }
    return Integer.parseInt(sb.toString());
}
```","```python
def min_possible_integer(n):
  s = str(n)
  res = []
  for i in range(len(s)):
    if int(s[i]) < 5:
      res.append(s[i])
    else:
      res.append(str(10 - int(s[i])))
  if res[0] == '0':
    res = res[1:]
  return int("""".join(res))
```"
151,Reduce N to 1 with minimum number of given operations | Java implementation of the approach ; Function to return the minimum number of given operations required to reduce n to 1 ; To store the count of operations ; To store the digit ; If n is already then no operation is required ; Extract all the digits except the first digit ; Store the maximum of that digits ; for each digit ; First digit ; Add the value to count ; Driver code,"```java
public static int reduceTo1(int n) {
    int count = 0;
    int digit;
    if (n == 1) {
      return 0;
    }
    String str = String.valueOf(n);
    int max = Integer.parseInt(str.substring(1));
    for (int i = 1; i < str.length(); i++) {
      digit = Integer.parseInt(String.valueOf(str.charAt(i)));
      max = Math.max(max, digit);
    }
    count += Integer.parseInt(String.valueOf(str.charAt(0)));
    count += max;
    return count;
  }
```","```python
def minOperations(n):
  count = 0
  digit = 0
  if n == 1:
    return 0
  s = str(n)
  digit = max(int(x) for x in s[1:])
  for i in s:
    if i == s[0]:
      count += int(i)
  return count
```"
152,Find the largest number that can be formed by changing at most K digits | Java implementation of the approach ; Function to return the maximum number that can be formed by changing at most k digits in str ; For every digit of the number ; If no more digits can be replaced ; If current digit is not already 9 ; Replace it with 9 ; One digit has been used ; Driver code,"```java
public static String findMax(String str, int k) {
    StringBuilder sb = new StringBuilder(str);
    for (int i = 0; i < sb.length(); i++) {
        if (k == 0) {
            break;
        }
        if (sb.charAt(i) != '9') {
            sb.setCharAt(i, '9');
            k--;
        }
    }
    return sb.toString();
}
```","```python
def find_max(str, k):
  n = len(str)
  for i in range(n):
    if k == 0:
      break
    if str[i] != '9':
      str = str[:i] + '9' + str[i+1:]
      k -= 1
  return str
```"
153,Number of occurrences of a given angle formed using 3 vertices of a n | Java implementation of the approach ; Function that calculates occurrences of given angle that can be created using any 3 sides ; Maximum angle in a regular n - gon is equal to the interior angle If the given angle is greater than the interior angle then the given angle cannot be created ; The given angle times n should be divisible by 180 else it cannot be created ; Initialise answer ; Calculate the frequency of given angle for each vertex ; Multiply answer by frequency . ; Multiply answer by the number of vertices . ; Driver code,"```java
public static int countAngleOccurrences(int n, int angle) {
    int interiorAngle = (n - 2) * 180 / n;
    if (angle > interiorAngle || (angle * n) % 180 != 0) {
      return 0;
    }
    int answer = 1;
    int frequency = (angle * n) / 180 - 1;
    answer *= frequency;
    answer *= n;
    return answer;
  }
```","```python
def count_angle_occurrences(n, angle):
  interior_angle = (n - 2) * 180 / n
  if angle > interior_angle or (angle * n) % 180 != 0:
    return 0
  answer = 1
  frequency = n // (360 // angle)
  answer *= frequency
  answer *= n
  return answer
```"
154,Find third number such that sum of all three number becomes prime | Java implementation of the approach ; Function that will check whether number is prime or not ; Function to print the 3 rd number ; If the sum is odd ; If sum is not prime ; Driver code,"```java
public static boolean isPrime(int num) {
    if (num <= 1) {
        return false;
    }
    for (int i = 2; i * i <= num; i++) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}

public static void printThirdNumber(int num1, int num2) {
    int sum = num1 + num2;
    if (sum % 2 == 1) {
        for (int i = 1; i <= sum; i++) {
            if (isPrime(sum + i)) {
                System.out.println(i);
                return;
            }
        }
    } else {
        System.out.println(-1);
    }
}
```","```python
def is_prime(n):
  if n <= 1:
    return False
  for i in range(2, int(n**0.5) + 1):
    if n % i == 0:
      return False
  return True

def find_third_number(a, b):
  for i in range(1, 10000):
    sum = a + b + i
    if sum % 2 != 0:
      if is_prime(sum):
        return i

def main():
  a = int(input())
  b = int(input())
  third_number = find_third_number(a, b)
  if third_number is not None:
    print(third_number)
  else:
    print(-1)

if __name__ == ""__main__"":
  main()
```"
155,Total ways of selecting a group of X men from N men with or without including a particular man | Java implementation of the approach ; Function to return the value of nCr ; Initialize the answer ; Divide simultaneously by i to avoid overflow ; Function to return the count of ways ; Driver code,"```java
public static long nCr(int n, int r) {
    if (r > n) {
        return 0;
    }
    long result = 1;
    for (int i = 1; i <= r; i++) {
        result *= (n - i + 1);
        result /= i;
    }
    return result;
}

public static long countWays(int n, int x, boolean include) {
    long answer = 0;
    if (include) {
        answer = nCr(n - 1, x - 1);
    } else {
        answer = nCr(n - 1, x);
    }
    return answer;
}

public static void main(String[] args) {
    int n = 5, x = 3;
    System.out.println(countWays(n, x, true) + countWays(n, x, false));
}
```","```python
def nCr(n, r):
  if r > n:
    return 0
  result = 1
  for i in range(1, r + 1):
    result = result * (n - i + 1) // i
  return result

def countWays(n, x, p):
  ans = nCr(n, x) + nCr(n - 1, x - 1) - nCr(n - p, x - 1)
  return ans
```"
156,Compute the maximum power with a given condition | Java program for Compute maximum power to which K can be raised so that given condition remains true ; Function to return the largest power ; If n is greater than given M ; If n == m ; Checking for the next power ; Driver Code,"```java
public static int maxPower(int n, int k, int m) {
    if (n > m) {
      return -1;
    }
    if (n == m) {
      return 0;
    }
    int power = 1;
    while (Math.pow(k, power) <= m) {
      power++;
    }
    return power - 1;
  }
```","```python
def maxPower(n, k, m):
  if n > m:
    return 0
  if n == m:
    return 1
  power = 0
  while (k**power <= m):
    power += 1
  return power - 1
```"
157,Program to find the number from given holes | Java implementation of the above approach ; Function that will find out the number ; If number of holes equal 0 then return 1 ; If number of holes equal 0 then return 0 ; If number of holes is more than 0 or 1. ; If number of holes is odd ; Driver code ; Calling Function,"```java
public static int findNumber(int holes) {
    if (holes == 0) {
        return 1;
    } else if (holes == 1) {
        return 0;
    } else if (holes > 1) {
        if (holes % 2 != 0) {
            return 8;
        } else {
            return 2;
        }
    }
    return -1;
}
```","```python
def find_number(holes):
  if holes == 0:
    return 1
  if holes == 1:
    return 0
  if holes > 1:
    if holes % 2 == 1:
      return 8
    else:
      return 2
```"
158,Minimum cost to make all array elements equal | Java implementation of the approach ; Function to return the minimum cost to make each array element equal ; To store the count of even numbers present in the array ; To store the count of odd numbers present in the array ; Iterate through the array and find the count of even numbers and odd numbers ; Driver code,"```java
public static int minCostToMakeEqual(int[] arr) {
    int evenCount = 0;
    int oddCount = 0;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] % 2 == 0) {
            evenCount++;
        } else {
            oddCount++;
        }
    }
    return Math.min(evenCount, oddCount);
}
```","```python
def minCostToMakeEqual(arr):
  evenCount = 0
  oddCount = 0
  for num in arr:
    if num % 2 == 0:
      evenCount += 1
    else:
      oddCount += 1
  return min(evenCount, oddCount)
```"
159,Number of Subarrays with positive product | Java implementation of the approach ; Function to return the count of subarrays with negative product ; Replace current element with 1 if it is positive else replace it with - 1 instead ; Take product with previous element to form the prefix product ; Count positive and negative elements in the prefix product array ; Return the required count of subarrays ; Function to return the count of subarrays with positive product ; Total subarrays possible ; Count to subarrays with negative product ; Return the count of subarrays with positive product ; Driver code,"```java
public static int countSubarraysWithPositiveProduct(int[] arr) {
    int n = arr.length;
    int[] prefixProduct = new int[n];
    prefixProduct[0] = arr[0] > 0 ? 1 : -1;
    for (int i = 1; i < n; i++) {
        prefixProduct[i] = prefixProduct[i - 1] * (arr[i] > 0 ? 1 : -1);
    }
    int positiveCount = 0;
    int negativeCount = 0;
    for (int i = 0; i < n; i++) {
        if (prefixProduct[i] > 0) {
            positiveCount++;
        } else {
            negativeCount++;
        }
    }
    return (n * (n + 1) / 2) - negativeCount;
}
```","```python
def countSubarraysWithPositiveProduct(arr):
  n = len(arr)
  prefix_product = [0] * n
  prefix_product[0] = 1 if arr[0] > 0 else -1
  for i in range(1, n):
    prefix_product[i] = prefix_product[i - 1] * (1 if arr[i] > 0 else -1)
  positive_count = prefix_product.count(1)
  negative_count = prefix_product.count(-1)
  return n * (n + 1) // 2 - negative_count * (negative_count - 1) // 2
```"
160,"Find the XOR of first N Prime Numbers | Java implementation of the approach ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; Function to return the xor of 1 st N prime numbers ; Count of prime numbers ; XOR of prime numbers ; If the number is prime xor it ; Increment the count ; Get to the next number ; Driver code ; Create the sieve ; Find the xor of 1 st n prime numbers","```java
public static int xorOfFirstNPrimes(int n) {
    boolean[] prime = new boolean[n + 1];
    Arrays.fill(prime, true);
    int count = 0;
    int xor = 0;
    for (int p = 2; p * p <= n; p++) {
      if (prime[p]) {
        for (int i = p * p; i <= n; i += p) {
          prime[i] = false;
        }
      }
    }
    for (int p = 2; p <= n; p++) {
      if (prime[p]) {
        xor ^= p;
        count++;
        if (count == n) {
          break;
        }
      }
    }
    return xor;
  }
```","```python
def find_xor_of_first_n_primes(n):
  prime = [True] * (n + 1)
  count = 0
  xor = 0
  for p in range(2, n + 1):
    if prime[p]:
      xor ^= p
      count += 1
      for i in range(p * p, n + 1, p):
        prime[i] = False
  return xor
```"
161,Sum of all natural numbers from L to R ( for large values of L and R ) | Java implementation of the approach ; Value of inverse modulo 2 with 10 ^ 9 + 7 ; Function to return num % 1000000007 where num is a large number ; Initialize result ; One by one process all the digits of string ' num ' ; Function to return the sum of the longegers from the given range modulo 1000000007 ; a stores the value of L modulo 10 ^ 9 + 7 ; b stores the value of R modulo 10 ^ 9 + 7 ; l stores the sum of natural numbers from 1 to ( a - 1 ) ; r stores the sum of natural numbers from 1 to b ; If the result is negative ; Driver code,"```java
public static long sumOfNaturalNumbers(long L, long R) {
    long a = L % 1000000007;
    long b = R % 1000000007;
    long l = (a * (a - 1)) / 2;
    long r = (b * (b + 1)) / 2;
    long result = (r - l) % 1000000007;
    if (result < 0) {
      result += 1000000007;
    }
    return result;
  }
```","```python
def sum_of_natural_numbers(L, R):
  a = L % 1000000007
  b = R % 1000000007
  l = (a * (a - 1)) // 2
  r = (b * (b + 1)) // 2
  result = (r - l) % 1000000007
  if result < 0:
    result += 1000000007
  return result
```"
162,"Maximum subsequence sum such that all elements are K distance apart | Java implementation of the approach ; Function to return the maximum subarray sum for the array { a [ i ] , a [ i + k ] , a [ i + 2 k ] , ... } ; Function to return the sum of the maximum required subsequence ; To store the result ; Run a loop from 0 to k ; Find the maximum subarray sum for the array { a [ i ] , a [ i + k ] , a [ i + 2 k ] , ... } ; Return the maximum value ; Driver code","```java
public static int maxSubsequenceSumKDistance(int[] a, int k) {
    int maxSum = 0;
    for (int i = 0; i < k; i++) {
      int currentSum = 0;
      for (int j = i; j < a.length; j += k) {
        currentSum += a[j];
      }
      maxSum = Math.max(maxSum, currentSum);
    }
    return maxSum;
  }
```","```python
def max_subsequence_sum(a, k):
  max_sum = 0
  for i in range(k):
    current_sum = 0
    j = i
    while j < len(a):
      current_sum += a[j]
      j += k
    max_sum = max(max_sum, current_sum)
  return max_sum
```"
163,"Generate N integers satisfying the given conditions | Java implementation of the approach ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; Function to find the first n odd prime numbers ; To store the current count of prime numbers ; Starting with 3 as 2 is an even prime number ; If i is prime ; Print i and increment count ; Driver code ; Create the sieve","```java
public static void findFirstNOddPrimes(int n) {
    boolean[] prime = new boolean[n + 1];
    Arrays.fill(prime, true);
    int count = 0;
    for (int i = 3; count < n; i += 2) {
        if (prime[i]) {
            System.out.print(i + "" "");
            count++;
            for (int j = i * i; j <= n; j += i) {
                prime[j] = false;
            }
        }
    }
}
```","```python
def generate_primes(n):
  prime = [True] * (n + 1)
  count = 0
  i = 3
  while count < n:
    if prime[i]:
      print(i)
      count += 1
      for j in range(i * i, n + 1, 2 * i):
        prime[j] = False
    i += 2
```"
164,Probability that a N digit number is palindrome | Java code of above approach ; Find the probability that a n digit number is palindrome ; Denominator ; Assign 10 ^ ( floor ( n \/ 2 ) ) to denominator ; Display the answer ; Driver code,"```java
public static double palindromeProbability(int n) {
    double denominator = Math.pow(10, Math.floor(n / 2));
    return 1 / denominator;
}
```","```python
def palindrome_probability(n):
  denominator = 10 ** (n // 2)
  return 1 / denominator
```"
165,Ways to choose balls such that at least one ball is chosen | Java implementation of the approach ; Function to return the count of ways to choose the balls ; Calculate ( 2 ^ n ) % MOD ; Subtract the only where no ball was chosen ; Driver code,"```java
public static int countWays(int n, int MOD) {
    long res = 1;
    for (int i = 0; i < n; i++) {
      res = (res * 2) % MOD;
    }
    return (int) ((res - 1 + MOD) % MOD);
  }
```","```python
def count_ways(n, MOD):
  return (pow(2, n, MOD) - 1) % MOD 
```"
166,Minimize the sum of the array according the given condition | Java implementation of the above approach ; Function to return the minimum sum ; sort the array to find the minimum element ; finding the number to divide ; Checking to what instance the sum has decreased ; getting the max difference ; Driver Code,"```java
public static int minimizeSum(int[] arr, int k) {
    Arrays.sort(arr);
    int n = arr.length;
    int numToDivide = arr[0];
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    int minSum = sum;
    int maxDiff = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] == numToDivide) {
            arr[i] = arr[i] / k;
            int currentSum = 0;
            for (int j = 0; j < n; j++) {
                currentSum += arr[j];
            }
            if (currentSum < minSum) {
                minSum = currentSum;
                maxDiff = sum - currentSum;
            }
            arr[i] = arr[i] * k;
        }
    }
    return minSum;
}
```","```python
def minimizeSum(arr, n):
  arr.sort()
  min_element = arr[0]
  num_to_divide = 1
  while num_to_divide <= min_element:
    sum = 0
    for i in range(n):
      sum += abs(arr[i] - num_to_divide)
    num_to_divide += 1
  return sum
```"
167,Print all the permutation of length L using the elements of an array | Iterative | Java implementation for above approach ; Convert the number to Lth base and print the sequence ; Sequence is of length L ; Print the ith element of sequence ; Print all the permuataions ; There can be ( len ) ^ l permutations ; Convert i to len th base ; Driver code ; function call,"```java
public static void printPermutations(int[] arr, int L) {
    int len = arr.length;
    for (int i = 0; i < Math.pow(len, L); i++) {
        int[] sequence = new int[L];
        int temp = i;
        for (int j = L - 1; j >= 0; j--) {
            sequence[j] = temp % len;
            temp /= len;
        }
        for (int j = 0; j < L; j++) {
            System.out.print(arr[sequence[j]] + "" "");
        }
        System.out.println();
    }
}
```","```python
def print_permutations(arr, L):
  n = len(arr)
  for i in range(n**L):
    sequence = []
    temp = i
    for j in range(L):
      digit = temp % n
      sequence.append(arr[digit])
      temp //= n
    print(sequence)
```"
168,Number of possible permutations when absolute difference between number of elements to the right and left are given | Java implementation of the above approach ; Function to find the number of permutations possible of the original array to satisfy the given absolute differences ; To store the count of each a [ i ] in a map ; if n is odd ; check the count of each whether it satisfy the given criteria or not ; there is only 1 way for middle element . ; for others there are 2 ways . ; now find total ways ; When n is even . ; there will be no middle element so for each a [ i ] there will be 2 ways ; Driver Code,"```java
public static long countPermutations(int[] a, int[] diff) {
    int n = a.length;
    Map<Integer, Integer> count = new HashMap<>();
    for (int i = 0; i < n; i++) {
      count.put(a[i], count.getOrDefault(a[i], 0) + 1);
    }
    long ways = 1;
    if (n % 2 == 1) {
      for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
        if (entry.getValue() != diff[entry.getKey()]) {
          return 0;
        }
      }
      ways = 2;
      for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
        if (entry.getKey() != (n - 1) / 2) {
          ways *= 2;
        }
      }
    } else {
      for (Map.Entry<Integer, Integer> entry : count.entrySet()) {
        ways *= 2;
      }
    }
    return ways;
  }
```","```python
def countPermutations(a, diff):
  n = len(a)
  count = {}
  for i in range(n):
    if a[i] in count:
      count[a[i]] += 1
    else:
      count[a[i]] = 1
  totalWays = 1
  if n % 2 == 1:
    for key, value in count.items():
      if value != diff[key]:
        return 0
    for i in range(n):
      if i != n // 2:
        totalWays *= 2
  else:
    for key, value in count.items():
      if value != diff[key] and value != diff[key] + 1:
        return 0
      totalWays *= 2
  return totalWays
```"
169,Proizvolov 's Identity | Java program to implement proizvolov 's identity ; Function to implement proizvolov 's identity ; According to proizvolov 's identity ; Driver code ; Function call,"```java
public static double proizvolovIdentity(double a, double b, double c, double d) {
    return (a * d - b * c) / (c * d);
}
```","```python
def proizvolov_identity(n):
  return (n * (n + 1) * (n + 2)) // 6
```"
170,Find the ln ( X ) and log10X with the help of expansion | Java code to Find the ln x and log < sub > 10 < \/ sub > x with the help of expansion ; Function to calculate ln x using expansion ; terminating value of the loop can be increased to improve the precision ; Function to calculate log10 x ; Driver Code ; setprecision ( 3 ) is used to display the output up to 3 decimal places,"```java
import java.util.Scanner;

public class LogarithmExpansion {

    public static double ln(double x) {
        if (x <= 0) {
            return Double.NaN;
        }
        double result = 0;
        double term = 1;
        for (int i = 1; i <= 10; i++) {
            term *= (x - 1) / i;
            result += term;
        }
        return result;
    }

    public static double log10(double x) {
        if (x <= 0) {
            return Double.NaN;
        }
        return ln(x) / Math.log(10);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a number: "");
        double x = scanner.nextDouble();
        System.out.printf(""ln(%.3f) = %.3f\n"", x, ln(x));
        System.out.printf(""log10(%.3f) = %.3f\n"", x, log10(x));
    }
}
```","```python
import math

def ln(x, precision=10):
  if x <= 0:
    return float('inf')
  result = 0
  term = 1
  for i in range(1, precision + 1):
    result += term * (x - 1)**i / i
    term *= -1
  return result

def log10(x, precision=10):
  if x <= 0:
    return float('inf')
  return ln(x, precision) / ln(10, precision)
```"
171,Find the sum of elements of the Matrix generated by the given rules | JAVA implementation of the approach ; Function to return the required sum ; To store the sum ; For every row ; Update the sum as A appears i number of times in the current row ; Update A for the next row ; Return the sum ; Driver code,"```java
public static int findSum(int n) {
    int sum = 0;
    int A = 1;
    for (int i = 1; i <= n; i++) {
        sum += A * i;
        A += i;
    }
    return sum;
}
```","```python
def sum_matrix_elements(n):
  sum = 0
  A = 1
  for i in range(n):
    sum += A * i
    A += 1
  return sum
```"
172,Euclidâ €“ Mullin Sequence | Java implementation of the approach ; Function to return the smallest prime factor of n ; Initialize i = 2 ; While i <= sqrt ( n ) ; If n is divisible by i ; Increment i ; Function to print the first n terms of the required sequence ; To store the product of the previous terms ; Traverse the prime numbers ; Current term will be smallest prime factor of ( 1 + product of all previous terms ) ; Print the current term ; Update the product ; Driver code ; Find the first 14 terms of the sequence,"```java
public static void printEuclidMullinSequence(int n) {
    long product = 1;
    for (int i = 1; i <= n; i++) {
      long currentTerm = smallestPrimeFactor(1 + product);
      System.out.print(currentTerm + "" "");
      product *= currentTerm;
    }
  }
  
  public static long smallestPrimeFactor(long n) {
    long i = 2;
    while (i * i <= n) {
      if (n % i == 0) {
        return i;
      }
      i++;
    }
    return n;
  }
```","```python
def smallest_prime_factor(n):
  i = 2
  while i <= n**0.5:
    if n % i == 0:
      return i
    i += 1
  return n

def euclid_mullin_sequence(n):
  product = 1
  for i in range(n):
    current_term = smallest_prime_factor(1 + product)
    print(current_term)
    product *= current_term

euclid_mullin_sequence(14)
```"
173,"Count total set bits in all numbers from 1 to n | Set 2 | Java implementation of the approach ; Function to return the sum of the count of set bits in the integers from 1 to n ; Ignore 0 as all the bits are unset ; To store the powers of 2 ; To store the result , it is initialized with n \/ 2 because the count of set least significant bits in the integers from 1 to n is n \/ 2 ; Loop for every bit required to represent n ; Total count of pairs of 0 s and 1 s ; totalPairs \/ 2 gives the complete count of the pairs of 1 s Multiplying it with the current power of 2 will give the count of 1 s in the current bit ; If the count of pairs was odd then add the remaining 1 s which could not be groupped together ; Next power of 2 ; Return the result ; Driver code","```java
public static int countSetBits(int n) {
    int powersOfTwo = 1;
    int result = n / 2;
    for (int i = 1; i <= n; i <<= 1) {
        int totalPairs = n / (i << 1);
        result += totalPairs * powersOfTwo;
        if ((n / i) % 2 == 1) {
            result += powersOfTwo;
        }
        powersOfTwo <<= 1;
    }
    return result;
}
```","```python
def countSetBits(n):
    powersOf2 = 1
    result = n // 2
    for i in range(1, n.bit_length()):
        totalPairs = n // (powersOf2 * 2)
        result += totalPairs * powersOf2
        if (n // powersOf2) % 2:
            result += n % powersOf2
        powersOf2 *= 2
    return result
```"
174,Find the height of a right | Java implementation of the approach ; Function to return the height of the right - angled triangle whose area is X times its base ; Driver code,"```java
public static double findHeight(double X, double base) {
    return 2 * X * base;
  }
```","```python
def triangle_height(area, base):
  return (2 * area) / base
```"
175,Find sum of inverse of the divisors when sum of divisors and the number is given | Java implementation of above approach ; Function to return the sum of inverse of divisors ; Calculating the answer ; Return the answer ; Driver code ; Function call,"```java
import java.util.*;
class Solution {
    public static double sumOfInverseOfDivisors(int num, int sumOfDivisors) {
        double sum = 0;
        for (int i = 1; i <= num; i++) {
            if (num % i == 0) {
                sum += 1.0 / i;
                sumOfDivisors -= i;
            }
            if (sumOfDivisors == 0) {
                break;
            }
        }
        return sum;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        int sumOfDivisors = sc.nextInt();
        System.out.println(sumOfInverseOfDivisors(num, sumOfDivisors));
    }
}
```","```python
def sum_of_inverse_of_divisors(n, sum_of_divisors):
  answer = 0
  for i in range(1, n + 1):
    if n % i == 0:
      answer += 1 / i
  return answer
```"
176,Number of triplets such that each value is less than N and each pair sum is a multiple of K | Java implementation of the approach ; Function to return the number of triplets ; Initializing the count array ; Storing the frequency of each modulo class ; If K is odd ; If K is even ; Driver Code ; Function Call,"```java
public static int countTriplets(int N, int K, int[] arr) {
    int[] count = new int[K];
    for (int i = 0; i < arr.length; i++) {
      count[arr[i] % K]++;
    }
    if (K % 2 == 1) {
      return (count[0] * (count[0] - 1) * (count[0] - 2) / 6) + (count[0] * (count[K / 2] * (count[K / 2] - 1)) / 2);
    } else {
      return (count[0] * (count[0] - 1) * (count[0] - 2) / 6) + (count[K / 2] * (count[K / 2] - 1) * (count[K / 2] - 2) / 6) + (count[0] * count[K / 2] * (count[K / 2] - 1)) / 2;
    }
  }
```","```python
def countTriplets(N, K):
  count = [0] * K
  for i in range(N):
    count[i % K] += 1
  if K % 2 == 1:
    return (count[0] * (count[0] - 1) * (count[0] - 2) // 6) + (count[0] * (count[K // 2] * (count[K // 2] - 1)) // 2)
  else:
    return (count[0] * (count[0] - 1) * (count[0] - 2) // 6) + (count[K // 2] * (count[K // 2] - 1) * (count[K // 2] - 2) // 6) + (count[0] * count[K // 2] * (count[K // 2] - 1) // 2)
```"
177,Find a number containing N | Java implementation of the approach ; Function to compute number using our deduced formula ; Initialize num to n - 1 ; Driver code,"```java
public static long findNumber(int n) {
    long num = n - 1;
    return num;
}
```","```python
def find_number_containing_n(n):
  num = n - 1
  return num
```"
178,"Find XOR of numbers from the range [ L , R ] | Java implementation of the approach ; Function to return the XOR of elements from the range [ 1 , n ] ; If n is a multiple of 4 ; If n % 4 gives remainder 1 ; If n % 4 gives remainder 2 ; If n % 4 gives remainder 3 ; Function to return the XOR of elements from the range [ l , r ] ; Driver code","```java
public static int xorFrom1ToN(int n) {
    if (n % 4 == 0) {
        return n;
    } else if (n % 4 == 1) {
        return 1;
    } else if (n % 4 == 2) {
        return n + 1;
    } else {
        return 0;
    }
}

public static int xorFromLToR(int l, int r) {
    return xorFrom1ToN(r) ^ xorFrom1ToN(l - 1);
}

public static void main(String[] args) {
    int l = 3, r = 9;
    System.out.println(xorFromLToR(l, r));
}
```","```python
def xorRange(l, r):
  return xorTillN(r) ^ xorTillN(l - 1)

def xorTillN(n):
  if n % 4 == 0:
    return n
  elif n % 4 == 1:
    return 1
  elif n % 4 == 2:
    return n + 1
  else:
    return 0

# Driver code
l = 2
r = 5
print(xorRange(l, r))
```"
179,Number of elements from the array which are reachable after performing given operations on D | Java implementation of the approach ; Function to return the GCD of a and b ; Function to return the count of reachable integers from the given array ; GCD of A and B ; To store the count of reachable integers ; If current element can be reached ; Return the count ; Driver code,"```java
static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
  
  static int countReachable(int[] arr, int D) {
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
      if (gcd(arr[i], D) == 1) {
        count++;
      }
    }
    return count;
  }
```","```python
def gcd(a, b):
  while b:
    a, b = b, a % b
  return a

def countReachable(arr, d):
  count = 0
  for i in range(len(arr)):
    if gcd(arr[i], d) == 1:
      count += 1
  return count
```"
180,"Number of trees whose sum of degrees of all the vertices is L | Java implementation of the approach ; Iterative Function to calculate ( x ^ y ) in O ( log y ) ; Initialize result ; If y is odd , multiply x with result ; y must be even now y = y \/ 2 ; Function to return the count of required trees ; number of nodes ; Return the result ; Driver code","```java
public static int countTrees(int n, int L) {
    if (L == 0 || L == n - 1) {
        return 1;
    }
    if (L < n - 1 || L > 2 * (n - 1)) {
        return 0;
    }
    return countTrees(n - 1, L - 1) + countTrees(n - 1, L - 2);
}
```","```python
def count_trees(n, L):
  result = 1
  if L % 2 != 0:
    result *= n
  while L > 1:
    L //= 2
    result *= n
  return result
```"
181,Change one element in the given array to make it an Arithmetic Progression | Java program to change one element of an array such that the resulting array is in arithmetic progression . ; Finds the initial term and common difference and prints the resulting array . ; Check if the first three elements are in arithmetic progression ; Check if the first element is not in arithmetic progression ; The first and fourth element are in arithmetic progression ; Print the arithmetic progression ; Driver code,"```java
public static void changeOneElement(int[] arr) {
    if (arr.length < 3) {
        System.out.println(""Array length is less than 3"");
        return;
    }
    if (2 * arr[1] == arr[0] + arr[2]) {
        System.out.println(""The array is already an arithmetic progression"");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "" "");
        }
        return;
    }
    if (2 * arr[0] != arr[1] + arr[2]) {
        arr[0] = 2 * arr[1] - arr[2];
        System.out.println(""The modified array is:"");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "" "");
        }
        return;
    }
    if (2 * arr[3] == arr[2] + arr[4]) {
        System.out.println(""The modified array is:"");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "" "");
        }
        return;
    }
    arr[3] = 2 * arr[2] - arr[1];
    System.out.println(""The modified array is:"");
    for (int i = 0; i < arr.length; i++) {
        System.out.print(arr[i] + "" "");
    }
}
```","```python
def change_one_element(arr):
  n = len(arr)
  if n <= 2:
    return arr
  if (arr[1] - arr[0]) == (arr[2] - arr[1]):
    return arr
  if (arr[1] - arr[0]) != (arr[2] - arr[1]):
    d = (arr[2] - arr[0]) / 2
    arr[0] = arr[1] - d
    return arr
  if (arr[3] - arr[1]) == (arr[2] - arr[0]):
    d = (arr[3] - arr[1])
    arr[2] = arr[1] + d
    return arr
```"
182,"Find if nCr is divisible by the given prime | Java Implementation of above approach ; Function to return the highest power of p that divides n ! implementing Legendre Formula ; Return the highest power of p which divides n ! ; Function to return N digits number which is divisible by D ; Find the highest powers of p that divide n ! , r ! and ( n - r ) ! ; If nCr is divisible by p ; Driver code","```java
import java.math.BigInteger;

class Solution {
    public static int highestPowerOfP(int n, int p) {
        int x = 0;
        while (n > 0) {
            n /= p;
            x += n;
        }
        return x;
    }

    public static BigInteger findNdigitNumber(int n, int d) {
        BigInteger num = BigInteger.TEN.pow(n - 1);
        while (!num.mod(BigInteger.valueOf(d)).equals(BigInteger.ZERO)) {
            num = num.add(BigInteger.ONE);
        }
        return num;
    }

    public static boolean isDivisibleByP(int n, int r, int p) {
        int hpn = highestPowerOfP(n, p);
        int hpr = highestPowerOfP(r, p);
        int hpnr = highestPowerOfP(n - r, p);
        return hpn >= hpr + hpnr;
    }

    public static void main(String[] args) {
        int n = 5, r = 2, p = 3;
        if (isDivisibleByP(n, r, p)) {
            System.out.println(""nCr is divisible by p"");
        } else {
            System.out.println(""nCr is not divisible by p"");
        }
    }
}
```","```python
def is_nCr_divisible_by_p(n, r, p):
  def highest_power(n, p):
    x = 0
    while n >= p:
      x += n // p
      n //= p
    return x
  return highest_power(n, p) - highest_power(r, p) - highest_power(n-r, p) >= 0
```"
183,"Check if the number is even or odd whose digits and base ( radix ) is given | Java implementation of the approach ; Function that returns true if the number represented by arr [ ] is even in base r ; If the base is even , then the last digit is checked ; If base is odd , then the number of odd digits are checked ; To store the count of odd digits ; Number is odd ; Driver code","```java
public static boolean isEven(int[] arr, int r) {
    if (r % 2 == 0) {
      return arr[arr.length - 1] % 2 == 0;
    } else {
      int oddCount = 0;
      for (int i = 0; i < arr.length; i++) {
        if (arr[i] % 2 != 0) {
          oddCount++;
        }
      }
      return oddCount % 2 == 0;
    }
  }
```","```python
def isEven(arr, r):
  if r % 2 == 0:
    return arr[-1] % 2 == 0
  else:
    count = 0
    for i in arr:
      if i % 2 != 0:
        count += 1
    return count % 2 == 0
```"
184,Bitwise AND of sub | Java implementation of the approach ; Function to return the minimum possible value of | K - X | where X is the bitwise AND of the elements of some sub - array ; Check all possible sub - arrays ; Find the overall minimum ; No need to perform more AND operations as | k - X | will increase ; Driver code,"```java
public static int minDiff(int[] arr, int k) {
    int min = Integer.MAX_VALUE;
    for (int i = 0; i < arr.length; i++) {
        int x = arr[i];
        for (int j = i + 1; j < arr.length; j++) {
            x &= arr[j];
            min = Math.min(min, Math.abs(k - x));
        }
    }
    return min;
}
```","```python
def min_diff(arr, k):
    n = len(arr)
    min_diff = float('inf')
    for i in range(n):
        x = arr[i]
        for j in range(i + 1, n + 1):
            x &= arr[j - 1]
            min_diff = min(min_diff, abs(k - x))
    return min_diff
```"
185,"Count of quadruplets from range [ L , R ] having GCD equal to K | Java implementation of the approach ; Function to return the gcd of a and b ; Function to return the count of quadruplets having gcd = k ; Count the frequency of every possible gcd value in the range ; To store the required count ; Calculate the answer using frequency values ; Return the required count ; Driver code","```java
static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
  
  static int countQuadruplets(int L, int R, int K) {
    int[] freq = new int[R + 1];
    for (int i = L; i <= R; i++) {
      for (int j = i + 1; j <= R; j++) {
        for (int k = j + 1; k <= R; k++) {
          for (int l = k + 1; l <= R; l++) {
            freq[gcd(gcd(gcd(i, j), k), l)]++;
          }
        }
      }
    }
    int count = 0;
    for (int i = K; i <= R; i++) {
      if (i % K == 0) {
        count += freq[i];
      }
    }
    return count;
  }
```","```python
def gcd(a, b):
  while b:
    a, b = b, a % b
  return a

def countQuadruplets(L, R, K):
  freq = [0] * (R + 1)
  for i in range(L, R + 1):
    for j in range(i + 1, R + 1):
      for k in range(j + 1, R + 1):
        for l in range(k + 1, R + 1):
          freq[gcd(gcd(gcd(i, j), k), l)] += 1
  return freq[K]
```"
186,"Rearrange the array to maximize the number of primes in prefix sum of the array | Java implementation of the approach ; Function to print the re - arranged array ; Count the number of ones and twos in a [ ] ; If the array element is 1 ; Array element is 2 ; If it has at least one 2 Fill up first 2 ; Decrease the cnt of ones if even ; Fill up with odd count of ones ; Fill up with remaining twos ; If even ones , then fill last position ; Print the rearranged array ; Driver code","```java
public static void rearrangeArray(int[] a) {
    int ones = 0;
    int twos = 0;
    for (int i = 0; i < a.length; i++) {
      if (a[i] == 1) {
        ones++;
      } else if (a[i] == 2) {
        twos++;
      }
    }
    if (twos >= 1) {
      int i = 0;
      while (i < 2 && twos > 0) {
        a[i] = 2;
        twos--;
        i++;
      }
      if (ones % 2 == 0) {
        ones = ones / 2;
      } else {
        ones = (ones + 1) / 2;
      }
      while (i < a.length && ones > 0) {
        a[i] = 1;
        ones--;
        i++;
      }
      while (i < a.length && twos > 0) {
        a[i] = 2;
        twos--;
        i++;
      }
      if (ones % 2 == 0 && i < a.length) {
        a[i] = 1;
      }
    }
    for (int i = 0; i < a.length; i++) {
      System.out.print(a[i] + "" "");
    }
    System.out.println();
  }
```","```python
def rearrange_array(a):
  ones = 0
  twos = 0
  for i in range(len(a)):
    if a[i] == 1:
      ones += 1
    elif a[i] == 2:
      twos += 1
  if twos >= 1:
    for i in range(2):
      if twos > 0:
        a[i] = 2
        twos -= 1
      else:
        break
    if ones % 2 == 0:
      ones -= 1
    for i in range(2, ones + 2):
      a[i] = 1
    for i in range(ones + 2, len(a)):
      if twos > 0:
        a[i] = 2
        twos -= 1
      else:
        break
    if ones % 2 == 0:
      a[len(a) - 1] = 1
  print(a)
```"
187,Generate an Array in which count of even and odd sum sub | Java implementation of the approach ; Function to generate and print the required array ; Find the number of odd prefix sums ; If no odd prefix sum found ; Calculating the number of even prefix sums ; Stores the current prefix sum ; If current prefix sum is even ; Print 0 until e = EvenPreSums - 1 ; Print 1 when e = EvenPreSums ; Print 0 for rest of the values ; Driver code,"```java
public static void generateArray(int n) {
    int oddPreSums = 0;
    for (int i = 1; i <= n; i++) {
        if ((i & 1) == 1) {
            oddPreSums++;
        }
    }
    if (oddPreSums == 0) {
        System.out.print(0 + "" "");
        for (int i = 1; i < n; i++) {
            System.out.print(0 + "" "");
        }
    } else {
        int EvenPreSums = n - oddPreSums;
        int preSum = 0;
        for (int i = 1; i <= n; i++) {
            preSum += i;
            if ((preSum & 1) == 0) {
                EvenPreSums--;
            }
        }
        for (int e = 0; e < EvenPreSums; e++) {
            System.out.print(0 + "" "");
        }
        System.out.print(1 + "" "");
        for (int e = EvenPreSums + 1; e <= n; e++) {
            System.out.print(0 + "" "");
        }
    }
}
```","```python
def generate_array(n):
  OddPreSums = 0
  EvenPreSums = 0
  prefix_sum = 0
  arr = []
  for i in range(n):
    if i == 0:
      arr.append(1)
      prefix_sum = 1
      OddPreSums = 1
    else:
      if prefix_sum % 2 == 0:
        EvenPreSums += 1
        arr.append(0)
      else:
        OddPreSums += 1
        arr.append(1)
      prefix_sum += arr[i]
  e = 0
  for i in range(n):
    if e < EvenPreSums:
      print(0, end=' ')
      e += 1
    elif e == EvenPreSums:
      print(1, end=' ')
      e += 1
    else:
      print(0, end=' ')
```"
188,"Minimum operations required to change the array such that | arr [ i ] | Java implementation of the approach ; Function to return the minimum number of operations required ; Minimum and maximum elements from the array ; To store the minimum number of operations required ; To store the number of operations required to change every element to either ( num - 1 ) , num or ( num + 1 ) ; If current element is not already num ; Add the count of operations required to change arr [ i ] ; Update the minimum operations so far ; Driver code","```java
public static int minOperations(int[] arr) {
    int min = Integer.MAX_VALUE;
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < arr.length; i++) {
      min = Math.min(min, arr[i]);
      max = Math.max(max, arr[i]);
    }
    int operations = 0;
    int minOperations = Integer.MAX_VALUE;
    for (int num = min; num <= max; num++) {
      operations = 0;
      for (int i = 0; i < arr.length; i++) {
        if (arr[i] != num) {
          operations += Math.abs(arr[i] - num);
        }
      }
      minOperations = Math.min(minOperations, operations);
    }
    return minOperations;
  }
```","```python
def minOperations(arr, n):
  minimum = min(arr)
  maximum = max(arr)
  minOperations = float('inf')
  for num in range(minimum, maximum + 1):
    operations = 0
    for i in range(n):
      if arr[i] != num:
        operations += abs(arr[i] - num)
    minOperations = min(minOperations, operations)
  return minOperations
```"
189,Choose X such that ( A xor X ) + ( B xor X ) is minimized | Java implementation of the approach ; Function to return the integer X such that ( A xor X ) + ( B ^ X ) is minimized ; While either A or B is non - zero ; Position at which both A and B have a set bit ; Inserting a set bit in x ; Right shifting both numbers to traverse all the bits ; Driver code,"```java
public static int getX(int A, int B) {
    int X = 0;
    while (A != 0 || B != 0) {
      int pos = Integer.numberOfTrailingZeros(A | B);
      X |= 1 << pos;
      A >>= 1;
      B >>= 1;
    }
    return X;
  }
```","```python
def find_x(A, B):
  x = 0
  while A or B:
    pos = 0
    while (A & 1) == 0 and (B & 1) == 0 and A and B:
      A >>= 1
      B >>= 1
      pos += 1
    x |= 1 << pos
    A >>= 1
    B >>= 1
  return x
```"
190,Choose X such that ( A xor X ) + ( B xor X ) is minimized | Java implementation of above approach ; finding X ; finding Sum ; Driver Code,"```java
public static int findX(int A, int B) {
    int X = 0;
    for (int i = 0; i < 32; i++) {
        if (((A >> i) & 1) != ((B >> i) & 1)) {
            X |= (1 << i);
        }
    }
    return X;
}

public static int findSum(int A, int B, int X) {
    return (A ^ X) + (B ^ X);
}

public static void main(String[] args) {
    int A = 5;
    int B = 10;
    int X = findX(A, B);
    int sum = findSum(A, B, X);
    System.out.println(""X: "" + X);
    System.out.println(""Sum: "" + sum);
}
```","```python
def find_x(A, B):
  return A ^ B
```"
191,Compare sum of first N | Java implementation of the approach ; Function that returns true if sum of first n - 1 elements of the array is equal to the last element ; Find the sum of first n - 1 elements of the array ; If sum equals to the last element ; Driver code,"```java
public static boolean compareSum(int[] arr, int n) {
  int sum = 0;
  for (int i = 0; i < n - 1; i++) {
    sum += arr[i];
  }
  return sum == arr[n - 1];
}
```","```python
def checkSum(arr, n):
  sum = 0
  for i in range(n - 1):
    sum += arr[i]
  return sum == arr[n - 1]
```"
192,Count number of 1 s in the array after N moves | Java implementation of the above approach ; Function to count number of perfect squares ; Counting number of perfect squares between a and b ; Function to count number of 1 s in array after N moves ; Driver Code ; Initialize array size ; Initialize all elements to 0,"```java
public static int countOnes(int[] arr, int n) {
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == 1) {
        count++;
      }
    }
    return count;
  }
```","```python
def count_ones(n, moves):
  arr = [0] * n
  for i in range(moves):
    for j in range(n):
      if arr[j] == 1:
        arr[j] = 0
      else:
        arr[j] = 1
  count = 0
  for i in range(n):
    if arr[i] == 1:
      count += 1
  return count
```"
193,Find the position of box which occupies the given ball | Java implementation of the approach ; Function to print the position of each boxes where a ball has to be placed ; Find the cumulative sum of array A [ ] ; Find the position of box for each ball ; Row number ; Column ( position of box in particular row ) ; Row + 1 denotes row if indexing of array start from 1 ; Driver code,"```java
public static void findBallPositions(int[] A) {
    int n = A.length;
    int[] cumSum = new int[n + 1];
    cumSum[0] = 0;
    for (int i = 1; i <= n; i++) {
      cumSum[i] = cumSum[i - 1] + A[i - 1];
    }
    for (int i = 1; i <= n; i++) {
      int row = 0;
      int pos = 0;
      for (int j = 1; j <= n; j++) {
        if (cumSum[j] >= i) {
          row = j;
          pos = i - cumSum[j - 1];
          break;
        }
      }
      System.out.println(""Ball "" + i + "": Row "" + (row + 1) + "", Column "" + pos);
    }
  }
```","```python
def find_box_positions(A, balls):
  n = len(A)
  cumulative_sum = [0] * (n + 1)
  for i in range(n):
    cumulative_sum[i + 1] = cumulative_sum[i] + A[i]
  positions = []
  for ball in balls:
    for i in range(n + 1):
      if cumulative_sum[i] >= ball:
        positions.append((i, ball - cumulative_sum[i - 1]))
        break
  return positions
```"
194,"Highest power of a number that divides other number | Java program to implement the above approach ; Function to get the prime factors and its count of times it divides ; Count the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , count i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to return the highest power ; Initialize two arrays ; Get the prime factors of n and m ; Iterate and find the maximum power ; If i not a prime factor of n and m ; If i is a prime factor of n and m If count of i dividing m is more than i dividing n , then power will be 0 ; If i is a prime factor of M ; get the maximum power ; Drivers code","```java
public static int highestPower(int n, int m) {
    int[] primeFactorsN = getPrimeFactors(n);
    int[] primeFactorsM = getPrimeFactors(m);
    int[] powerN = new int[primeFactorsN.length];
    int[] powerM = new int[primeFactorsM.length];
    for (int i = 0; i < primeFactorsN.length; i++) {
      powerN[i] = countDivisibility(n, primeFactorsN[i]);
    }
    for (int i = 0; i < primeFactorsM.length; i++) {
      powerM[i] = countDivisibility(m, primeFactorsM[i]);
    }
    int maxPower = 0;
    int j = 0;
    int k = 0;
    while (j < primeFactorsN.length && k < primeFactorsM.length) {
      if (primeFactorsN[j] < primeFactorsM[k]) {
        j++;
      } else if (primeFactorsN[j] > primeFactorsM[k]) {
        k++;
      } else {
        if (powerN[j] < powerM[k]) {
          maxPower = 0;
        } else {
          maxPower = powerN[j];
        }
        j++;
        k++;
      }
    }
    return maxPower;
  }
  public static int[] getPrimeFactors(int n) {
    int count = 0;
    for (int i = 2; i * i <= n; i++) {
      while (n % i == 0) {
        n /= i;
        count++;
      }
    }
    if (n > 1) {
      count++;
    }
    int[] primeFactors = new int[count];
    int i = 0;
    n = countDivisibility(n, 2);
    for (int j = 2; j * j <= n; j++) {
      while (n % j == 0) {
        n /= j;
        primeFactors[i++] = j;
      }
    }
    if (n > 1) {
      primeFactors[i] = n;
    }
    return primeFactors;
  }
  public static int countDivisibility(int n, int i) {
    int count = 0;
    if (i == 2) {
      while (n % 2 == 0) {
        n /= 2;
        count++;
      }
    } else {
      while (n % i == 0) {
        n /= i;
        count++;
      }
    }
    return count;
  }
  public static void main(String[] args) {
    int n = 24;
    int m = 36;
    System.out.println(highestPower(n, m));
  }
```","```python
def highestPower(n, m):
  def primeFactors(num):
    factors = {}
    count = 0
    if num % 2 == 0:
      while num % 2 == 0:
        count += 1
        num //= 2
      factors[2] = count
    i = 3
    while i * i <= num:
      if num % i == 0:
        count = 0
        while num % i == 0:
          count += 1
          num //= i
        factors[i] = count
      i += 2
    if num > 1:
      factors[num] = 1
    return factors

  factorsN = primeFactors(n)
  factorsM = primeFactors(m)
  powers = [0] * len(factorsM)
  i = 0
  for prime in factorsM:
    if prime not in factorsN:
      powers[i] = 0
    elif prime in factorsN:
      if factorsM[prime] > factorsN[prime]:
        powers[i] = 0
      else:
        powers[i] = factorsN[prime]
    i += 1
  maxPower = max(powers)
  return maxPower

```"
195,"Find the number of divisors of all numbers in the range [ 1 , n ] | Java implementation of the approach ; Function to find the number of divisors of all numbers in the range [ 1 , n ] ; Array to store the count of divisors ; For every number from 1 to n ; Increase divisors count for every number divisible by i ; Print the divisors ; Driver code","```java
public static int[] countDivisors(int n) {
    int[] divisors = new int[n + 1];
    for (int i = 1; i <= n; i++) {
      for (int j = i; j <= n; j += i) {
        divisors[j]++;
      }
    }
    return divisors;
  }
```","```python
def countDivisors(n):
  divisors = [1] * (n + 1)
  for i in range(2, n + 1):
    for j in range(i, n + 1, i):
      divisors[j] += 1
  return divisors
```"
196,Predict the winner of the game on the basis of absolute difference of sum by selecting numbers | Java implementation of the approach ; Function to decide the winner ; Iterate for all numbers in the array ; If mod gives 0 ; If mod gives 1 ; If mod gives 2 ; If mod gives 3 ; Check the winning condition for X ; Driver code,"```java
public static char winner(int[] arr) {
    int sum1 = 0;
    int sum2 = 0;
    for (int i = 0; i < arr.length; i++) {
        if (i % 4 == 0) {
            sum1 += arr[i];
        } else if (i % 4 == 1) {
            sum2 += arr[i];
        } else if (i % 4 == 2) {
            sum1 += arr[i];
        } else if (i % 4 == 3) {
            sum2 += arr[i];
        }
    }
    if (Math.abs(sum1 - sum2) == 0) {
        return 'D';
    } else if (sum1 > sum2) {
        return 'X';
    } else {
        return 'Y';
    }
}
```","```python
def predict_winner(arr):
  sum_x = 0
  sum_y = 0
  for i in range(len(arr)):
    if i % 4 == 0:
      sum_x += arr[i]
    elif i % 4 == 1:
      sum_y += arr[i]
    elif i % 4 == 2:
      sum_x += arr[i]
    elif i % 4 == 3:
      sum_y += arr[i]
  if abs(sum_x - sum_y) > 10:
    return 'X'
  else:
    return 'Y'
```"
197,"Count all prefixes of the given binary array which are divisible by x | Java implementation of the approach ; Function to return the count of total binary prefix which are divisible by x ; Initialize with zero ; Instead of converting all prefixes to decimal , take reminder with x ; If number is divisible by x then reminder = 0 ; Driver code","```java
public static int countPrefixes(int[] arr, int x) {
    int count = 0;
    int rem = 0;
    for (int i = 0; i < arr.length; i++) {
      rem = (rem * 2 + arr[i]) % x;
      if (rem == 0) {
        count++;
      }
    }
    return count;
  }
```","```python
def count_divisible_prefixes(arr, x):
  count = 0
  rem = 0
  for i in range(len(arr)):
    rem = (rem * 2 + arr[i]) % x
    if rem == 0:
      count += 1
  return count
```"
198,"Length of the smallest number which is divisible by K and formed by using 1 's only | Java implementation of the approach ; Function to return length of the resultant number ; If K is a multiple of 2 or 5 ; Instead of generating all possible numbers 1 , 11 , 111 , 111 , ... , K 1 's  Take remainder with K ; If number is divisible by k then remainder will be 0 ; Driver code","```java
public static int smallestDivisibleByK(int k) {
    if (k % 2 == 0 || k % 5 == 0) {
        return -1;
    }
    int count = 1;
    int num = 1 % k;
    while (num != 0) {
        num = (num * 10 + 1) % k;
        count++;
    }
    return count;
}
```","```python
def smallestDivisibleByK(k):
  if k % 2 == 0 or k % 5 == 0:
    return -1
  n = 1
  rem = 1
  while rem != 0:
    n += 1
    rem = (rem * 10 + 1) % k
  return n
```"
199,Sum of multiplication of triplet of divisors of a number | Java implementation of the approach ; Global array declaration ; Function to find the sum of multiplication of every triplet in the divisors of a number ; sum1 [ x ] represents the sum of all the divisors of x ; Adding i to sum1 [ j ] because i is a divisor of j ; sum2 [ x ] represents the sum of all the divisors of x ; Here i is divisor of j and sum1 [ j ] - i represents sum of all divisors of j which do not include i so we add i * ( sum1 [ j ] - i ) to sum2 [ j ] ; In the above implementation we have considered every pair two times so we have to divide every sum2 array element by 2 ; Here i is the divisor of j and we are trying to add the sum of multiplication of all triplets of divisors of j such that one of the divisors is i ; In the above implementation we have considered every triplet three times so we have to divide every sum3 array element by 3 ; Print the results ; Driver code ; Precomputing,"```java
import java.util.*;
public class Solution {
    static int[] sum1 = new int[1000001];
    static int[] sum2 = new int[1000001];
    static int[] sum3 = new int[1000001];
    public static void main(String[] args) {
        precompute();
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            System.out.println(sum3[n]);
        }
    }
    static void precompute() {
        for (int i = 1; i <= 1000000; i++) {
            for (int j = i; j <= 1000000; j += i) {
                sum1[j] += i;
            }
        }
        for (int i = 1; i <= 1000000; i++) {
            for (int j = i; j <= 1000000; j += i) {
                sum2[j] += i * (sum1[j] - i);
            }
        }
        for (int i = 1; i <= 1000000; i++) {
            for (int j = i; j <= 1000000; j += i) {
                sum3[j] += i * sum2[j];
            }
        }
        for (int i = 1; i <= 1000000; i++) {
            sum2[i] /= 2;
            sum3[i] /= 3;
        }
    }
}
```","```python
def sum_of_multiplication_of_triplet_of_divisors(n):
  sum1 = [0] * (n + 1)
  sum2 = [0] * (n + 1)
  sum3 = [0] * (n + 1)
  for i in range(1, n + 1):
    for j in range(i, n + 1, i):
      sum1[j] += i
      sum2[j] += i * (sum1[j] - i)
  for i in range(1, n + 1):
    sum2[i] //= 2
    for j in range(i, n + 1, i):
      sum3[j] += i * sum2[j]
  for i in range(1, n + 1):
    sum3[i] //= 3
  return sum3
```"
200,Sum of Fibonacci Numbers in a range | Java implementation of the approach ; Function to return the nth Fibonacci number ; Function to return the required sum ; Using our deduced result ; Driver code,"```java
public static int fib(int n) {
    if (n <= 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
}

public static int sumFibInRange(int low, int high) {
    int sum = 0;
    for (int i = low; i <= high; i++) {
        sum += fib(i);
    }
    return sum;
}

public static void main(String[] args) {
    int low = 5;
    int high = 10;
    System.out.println(sumFibInRange(low, high));
}
```","```python
def fibonacci(n):
  if n <= 1:
    return n
  else:
    return fibonacci(n-1) + fibonacci(n-2)

def sum_fibonacci(m, n):
  sum = 0
  for i in range(m, n + 1):
    sum += fibonacci(i)
  return sum

m = 5
n = 10
print(sum_fibonacci(m, n))
```"
201,Print the balanced bracket expression using given brackets | Java implementation of the above approach ; Function to print balanced bracket expression if it is possible ; If the condition is met ; Print brackets of type - 1 ; Print brackets of type - 3 ; Print brackets of type - 4 ; Print brackets of type - 2 ; If the condition is not met ; Driver code,"```java
public static void printBalancedBrackets(int n) {
    if (n % 2 == 0) {
        System.out.print(""[-1][-3][-4][-2]"");
    }
}
```","```python
def print_balanced_brackets(n1, n2, n3, n4):
  if n1 == n2 and n3 == n4:
    print(""("", end="""")
    print("")"", end="""")
    print(""["", end="""")
    print(""]"", end="""")
    print(""{"", end="""")
    print(""}"", end="""")
  else:
    print(""Not possible"")
```"
202,Count numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros | Java implementation of the approach ; Function to return the factorial of a number ; Function to return the count of distinct ( N + M ) digit numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros ; Driver code,"```java
static int factorial(int n) {
    if (n == 0) {
      return 1;
    }
    return n * factorial(n - 1);
  }
  static int countNumbers(int n, int m) {
    if (n < 0 || m < 0) {
      return 0;
    }
    if (n == 0 && m == 0) {
      return 1;
    }
    if (n == 0) {
      return 1;
    }
    return factorial(n + m) / (factorial(n) * factorial(m));
  }
  public static void main(String[] args) {
    int n = 2;
    int m = 3;
    System.out.println(countNumbers(n, m));
  }
```","```python
def factorial(n):
  fact = 1
  for i in range(1, n + 1):
    fact = fact * i
  return fact

def countNumbers(N, M):
  if N == 0 and M == 0:
    return 0
  if N == 0:
    return 1
  return factorial(N + M) // (factorial(N) * factorial(M))
```"
203,Maximum value of | arr [ 0 ] | Java implementation of the approach ; Function to return the maximum required value ; Driver code,"```java
public static int maximumValue(int[] arr) {
    int max = Math.abs(arr[0]);
    for (int i = 1; i < arr.length; i++) {
      if (Math.abs(arr[i]) > max) {
        max = Math.abs(arr[i]);
      }
    }
    return max;
  }
```","```python
def maxAbsVal(arr):
  maxVal = abs(arr[0])
  for i in range(1, len(arr)):
    if abs(arr[i]) > maxVal:
      maxVal = abs(arr[i])
  return maxVal
```"
204,"Count of a , b & c after n seconds for given reproduction rate | Java implementation of the approach ; Function to print the count of a , b and c after n seconds ; Number of multiples of 60 below n ; Multiple of 60 nearest to n ; Change all a to b ; Change all b to c ; Change each c to two a ; Print the updated values of a , b and c ; Driver code","```java
public static void countABC(int a, int b, int c, int n) {
    int multiplesOf60 = n / 60;
    int nearestMultipleOf60 = multiplesOf60 * 60;
    for (int i = 0; i < multiplesOf60; i++) {
      a = b;
      b = c;
      c = 2 * a;
    }
    System.out.println(""a: "" + a);
    System.out.println(""b: "" + b);
    System.out.println(""c: "" + c);
  }
```","```python
def count_abc(a, b, c, n):
  seconds_passed = 0
  while seconds_passed < n:
    seconds_passed += 60
    a, b, c = b, c, 2 * a
  print(a, b, c)
```"
205,Find GCD of factorial of elements of given array | Java implementation of the above approach ; Implementation of factorial function ; Function to find GCD of factorial of elements from array ; find the minimum element of array ; return the factorial of minimum element ; Driver Code,"```java
public static int findGCDofFactorials(int[] arr) {
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] < min) {
            min = arr[i];
        }
    }
    return factorial(min);
}

public static int factorial(int n) {
    if (n == 0) {
        return 1;
    }
    return n * factorial(n - 1);
}
```","```python
def gcd_factorial_array(arr):
  def factorial(n):
    if n == 0:
      return 1
    return n * factorial(n - 1)

  def gcd(a, b):
    if b == 0:
      return a
    return gcd(b, a % b)

  min_element = min(arr)
  return factorial(min_element)
```"
206,Sum of the series 1 ^ 1 + 2 ^ 2 + 3 ^ 3 + ... . . + n ^ n using recursion | Java implementation of the approach ; Recursive function to return the sum of the given series ; 1 ^ 1 = 1 ; Recursive call ; Driver code,"```java
public static int sumSeries(int n) {
    if (n == 1) {
      return 1;
    } else {
      return (int) Math.pow(n, n) + sumSeries(n - 1);
    }
  }
```","```python
def sum_series(n):
  if n == 1:
    return 1
  return n**n + sum_series(n-1)
```"
207,Count permutations that are first decreasing then increasing . | Java implementation of the above approach ; Function to compute a ^ n % mod ; Function to count permutations that are first decreasing and then increasing ; For n = 1 return 0 ; Calculate and return result ; Driver code,"```java
public static long countPermutations(int n) {
    if (n == 1) {
        return 0;
    }
    long result = 1;
    for (int i = 2; i <= n; i++) {
        result = (result * i) % MOD;
    }
    return result;
}
```","```python
def count_permutations(n):
  if n == 1:
    return 0
  result = 1
  for i in range(2, n + 1):
    result = (result * i) % 1000000007
  return result
```"
208,"Find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . | Java program to find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . ; Function to find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . ; Driver code","```java
public static int countNumbers(int N) {
    return (int) Math.pow(2, N);
}
```","```python
def countNumbers(N):
  return 2**N
```"
209,Ways to place 4 items in n ^ 2 positions such that no row \/ column contains more than one | Java implementation of the approach ; Function to return the number of ways to place 4 items in n ^ 2 positions ; Driver code,"```java
public static int countWays(int n) {
    if (n < 2) {
      return 0;
    }
    int ways = 0;
    for (int i = 0; i < n * n; i++) {
      for (int j = i + 1; j < n * n; j++) {
        for (int k = j + 1; k < n * n; k++) {
          for (int l = k + 1; l < n * n; l++) {
            if (isValidPlacement(i, j, k, l, n)) {
              ways++;
            }
          }
        }
      }
    }
    return ways;
  }
  private static boolean isValidPlacement(int i, int j, int k, int l, int n) {
    return (i / n != j / n && i / n != k / n && i / n != l / n &&
            j / n != k / n && j / n != l / n && k / n != l / n &&
            i % n != j % n && i % n != k % n && i % n != l % n &&
            j % n != k % n && j % n != l % n && k % n != l % n);
  }
```","```python
def count_arrangements(n):
  if n < 2:
    return 0
  return 4 * (n - 1) * (n - 2) * (n - 3)
```"
210,"Find Nth term of the series 1 , 6 , 18 , 40 , 75 , ... . | Java code to generate ' Nth ' term of this sequence ; Function to generate a fixed number ; ( N ^ 2 * ( N + 1 ) ) \/ 2 ; Driver Method","```java
public static int findNthTerm(int n) {
    return (n * n * (n + 1)) / 2;
}
```","```python
def nth_term(n):
  return (n**2 * (n + 1)) // 2
```"
211,Print n numbers such that their sum is a perfect square | Java implementation of the approach ; Function to print n numbers such that their sum is a perfect square ; Print ith odd number ; Driver code,"```java
public static void printNumbersWithPerfectSquareSum(int n) {
    int sum = 0;
    for (int i = 1; i <= 2 * n; i += 2) {
        System.out.print(i + "" "");
        sum += i;
    }
    System.out.println(""\nSum: "" + sum);
}
```","```python
def print_n_numbers_with_perfect_square_sum(n):
  sum = 0
  for i in range(n):
    sum += 2 * i + 1
    print(2 * i + 1, end="" "")
  print(""\nThe sum of the numbers is:"", sum)
```"
212,Missing even and odd elements from the given arrays | Java implementation of the approach ; Function to find the missing numbers ; To store the minimum and the maximum odd and even elements from the arrays ; To store the sum of the array elements ; Get the minimum and the maximum even elements from the array ; Get the minimum and the maximum odd elements from the array ; To store the total terms in the series and the required sum of the array ; Total terms from 2 to minEven ; Sum of all even numbers from 2 to minEven ; Total terms from 2 to maxEven ; Sum of all even numbers from 2 to maxEven ; Required sum for the even array ; Missing even number ; Total terms from 1 to minOdd ; Sum of all odd numbers from 1 to minOdd ; Total terms from 1 to maxOdd ; Sum of all odd numbers from 1 to maxOdd ; Required sum for the odd array ; Missing odd number ; Driver code,"```java
public static void findMissing(int[] arr1, int[] arr2) {
    int minEven = Math.min(arr1[0], arr2[0]);
    int maxEven = Math.max(arr1[arr1.length - 1], arr2[arr2.length - 1]);
    int minOdd = Math.min(arr1[1], arr2[1]);
    int maxOdd = Math.max(arr1[arr1.length - 2], arr2[arr2.length - 2]);
    int sumArr1 = 0;
    int sumArr2 = 0;
    for (int i = 0; i < arr1.length; i++) {
        sumArr1 += arr1[i];
    }
    for (int i = 0; i < arr2.length; i++) {
        sumArr2 += arr2[i];
    }
    int totalTermsEven1 = (minEven / 2) - 1;
    int sumEven1 = totalTermsEven1 * (minEven + 2) / 2;
    int totalTermsEven2 = (maxEven / 2) - 1;
    int sumEven2 = totalTermsEven2 * (maxEven + 2) / 2;
    int requiredSumEven = sumEven2 - sumEven1;
    int missingEven = requiredSumEven - (sumArr1 + sumArr2);
    int totalTermsOdd1 = (minOdd - 1) / 2;
    int sumOdd1 = totalTermsOdd1 * (minOdd + 1) / 2;
    int totalTermsOdd2 = (maxOdd - 1) / 2;
    int sumOdd2 = totalTermsOdd2 * (maxOdd + 1) / 2;
    int requiredSumOdd = sumOdd2 - sumOdd1;
    int missingOdd = requiredSumOdd - (sumArr1 + sumArr2);
    System.out.println(""Missing even number: "" + missingEven);
    System.out.println(""Missing odd number: "" + missingOdd);
}
```","```python
def find_missing_numbers(arr1, arr2):
  minEven = min(min(arr1), min(arr2))
  maxEven = max(max(arr1), max(arr2))
  minOdd = min(min([x for x in arr1 if x % 2 != 0]), min([x for x in arr2 if x % 2 != 0]))
  maxOdd = max(max([x for x in arr1 if x % 2 != 0]), max([x for x in arr2 if x % 2 != 0]))
  sumArr1 = sum(arr1)
  sumArr2 = sum(arr2)
  totalTermsEven1 = (minEven // 2) - 1
  sumEven1 = totalTermsEven1 * (totalTermsEven1 + 1)
  totalTermsEven2 = (maxEven // 2)
  sumEven2 = totalTermsEven2 * (totalTermsEven2 + 1)
  requiredSumEven = sumEven2 - sumEven1
  missingEven = requiredSumEven - (sumArr1 + sumArr2)
  totalTermsOdd1 = (minOdd - 1) // 2
  sumOdd1 = totalTermsOdd1 * (totalTermsOdd1 + 1)
  totalTermsOdd2 = (maxOdd - 1) // 2
  sumOdd2 = totalTermsOdd2 * (totalTermsOdd2 + 1)
  requiredSumOdd = sumOdd2 - sumOdd1
  missingOdd = requiredSumOdd - (sumArr1 + sumArr2)
  return missingEven, missingOdd
```"
213,Minimum matches the team needs to win to qualify | Java implementation of the approach ; Function to return the minimum number of matches to win to qualify for next round ; Do a binary search to find ; Find mid element ; Check for condition to qualify for next round ; Driver Code,"```java
public static int minimumMatchesToQualify(int n, int k, int[] matches) {
    int low = 0, high = n;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (matches[mid] >= k) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return low;
}
```","```python
def min_matches_to_win(n, k, matches_won):
    low = 0
    high = n
    while low <= high:
        mid = (low + high) // 2
        if matches_won + mid >= k:
            high = mid - 1
        else:
            low = mid + 1
    return low
```"
214,Check if product of digits of a number at even and odd places is equal | Java implementation of the approach ; To store the respective product ; Converting integer to String ; Traversing the String ; Driver code,"```java
public static boolean checkProduct(int num) {
    int evenProduct = 1;
    int oddProduct = 1;
    String str = String.valueOf(num);
    for (int i = 0; i < str.length(); i++) {
        if (i % 2 == 0) {
            evenProduct *= Integer.parseInt(String.valueOf(str.charAt(i)));
        } else {
            oddProduct *= Integer.parseInt(String.valueOf(str.charAt(i)));
        }
    }
    return evenProduct == oddProduct;
}
```","```python
def check_product_of_digits(num):
  even_product = 1
  odd_product = 1
  num_str = str(num)
  for i in range(len(num_str)):
    if i % 2 == 0:
      even_product *= int(num_str[i])
    else:
      odd_product *= int(num_str[i])
  return even_product == odd_product
```"
215,"Count of all even numbers in the range [ L , R ] whose sum of digits is divisible by 3 | Java implementation of the approach ; Function to return the sum of digits of x ; Function to return the count of required numbers ; If i is divisible by 2 and sum of digits of i is divisible by 3 ; Return the required count ; Driver code","```java
public static int sumOfDigits(int x) {
  int sum = 0;
  while (x > 0) {
    sum += x % 10;
    x /= 10;
  }
  return sum;
}

public static int countEvenNumbersDivisibleBy3(int L, int R) {
  int count = 0;
  for (int i = L; i <= R; i++) {
    if (i % 2 == 0 && sumOfDigits(i) % 3 == 0) {
      count++;
    }
  }
  return count;
}
```","```python
def sum_of_digits(x):
  sum = 0
  while x > 0:
    sum += x % 10
    x //= 10
  return sum

def count_even_divisible_by_3(L, R):
  count = 0
  for i in range(L, R + 1):
    if i % 2 == 0 and sum_of_digits(i) % 3 == 0:
      count += 1
  return count
```"
216,Sum of minimum element of all subarrays of a sorted array | Java implementation of the above approach ; Function to find the sum of minimum of all subarrays ; Driver code,"```java
public static long sumOfMinimums(int[] arr, int n) {
    long sum = 0;
    for (int i = 0; i < n; i++) {
        sum += (long) arr[i] * (i + 1) * (n - i);
    }
    return sum;
}
```","```python
def sum_of_minimums(arr):
  n = len(arr)
  sum = 0
  for i in range(n):
    sum += arr[i] * (i + 1) * (n - i)
  return sum
```"
217,Longest Sub | Java implementation of the approach ; Function to return the max length of the sub - array that have the maximum average ( average value of the elements ) ; Finding the maximum value ; If consecutive maximum found ; Find the max length of consecutive max ; Driver code,"```java
public static int longestSub(int[] arr) {
    if (arr.length == 0) {
      return 0;
    }
    int maxLen = 1;
    int currLen = 1;
    int maxVal = arr[0];
    for (int i = 1; i < arr.length; i++) {
      if (arr[i] > maxVal) {
        maxVal = arr[i];
        currLen = 1;
      } else if (arr[i] == maxVal) {
        currLen++;
      }
      maxLen = Math.max(maxLen, currLen);
    }
    return maxLen;
  }
```","```python
def longestSub(arr):
  n = len(arr)
  max_val = arr[0]
  max_len = 1
  curr_len = 1
  for i in range(1, n):
    if arr[i] > max_val:
      max_val = arr[i]
      curr_len = 1
    elif arr[i] == max_val:
      curr_len += 1
      max_len = max(max_len, curr_len)
    else:
      curr_len = 1
  return max_len
```"
218,Minimum possible sum of array elements after performing the given operation | Java implementation of the approach ; Function to return the minimized sum ; To store the largest element from the array which is divisible by x ; Sum of array elements before performing any operation ; If current element is divisible by x and it is maximum so far ; Update the minimum element ; If no element can be reduced then there 's no point in performing the  operation as we will end up increasing  the sum when an element is multiplied by x ; Subtract the chosen elements from the sum and then add their updated values ; Return the minimized sum ; Driver code,"```java
public static int minimizeSum(int[] arr, int x) {
    int maxDivisibleByX = 0;
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
        sum += arr[i];
        if (arr[i] % x == 0 && arr[i] > maxDivisibleByX) {
            maxDivisibleByX = arr[i];
        }
    }
    if (maxDivisibleByX == 0) {
        return sum;
    }
    sum -= maxDivisibleByX;
    sum += maxDivisibleByX / x;
    return sum;
}
```","```python
def minimize_sum(arr, x):
  max_divisible_by_x = -1
  sum_of_elements = 0
  for element in arr:
    sum_of_elements += element
    if element % x == 0 and (max_divisible_by_x == -1 or element > max_divisible_by_x):
      max_divisible_by_x = element
  if max_divisible_by_x == -1:
    return sum_of_elements
  else:
    return sum_of_elements - max_divisible_by_x + max_divisible_by_x * x
```"
219,"Maximum Bitwise AND pair from given range | Java implementation of the approach ; Function to return the maximum bitwise AND possible among all the possible pairs ; If there is only a single value in the range [ L , R ] ; If there are only two values in the range [ L , R ] ; Driver code","```java
public static int maxBitwiseAND(int L, int R) {
    if (L == R) {
        return L;
    }
    if (L + 1 == R) {
        return L & R;
    }
    int max = 0;
    for (int i = L; i <= R; i++) {
        for (int j = i + 1; j <= R; j++) {
            max = Math.max(max, i & j);
        }
    }
    return max;
}
```","```python
def maxBitwiseAND(L, R):
  if L == R:
    return L
  if R - L == 1:
    return L & R
  return (R - 1) & R
```"
220,"Smallest Special Prime which is greater than or equal to a given number | Java program to find the Smallest Special Prime which is greater than or equal to a given number ; Function to check whether the number is a special prime or not ; While number is not equal to zero ; If the number is not prime return false . ; Else remove the last digit by dividing the number by 10. ; If the number has become zero then the number is special prime , hence return true ; Function to find the Smallest Special Prime which is greater than or equal to a given number ; Initially all numbers are considered Primes . ; There is always an answer possible ; Checking if the number is a special prime or not ; If yes print the number and break the loop . ; Else increment the number . ; Driver code","```java
public static boolean isSpecialPrime(int number) {
    if (number <= 1) {
      return false;
    }
    for (int i = 2; i * i <= number; i++) {
      if (number % i == 0) {
        return false;
      }
    }
    while (number != 0) {
      number /= 10;
      if (number == 0) {
        return true;
      }
    }
    return false;
  }
  public static int smallestSpecialPrime(int number) {
    while (true) {
      if (isSpecialPrime(number)) {
        return number;
      }
      number++;
    }
  }
```","```python
def is_special_prime(num):
  while num != 0:
    if not is_prime(num):
      return False
    num //= 10
    if num == 0:
      return True

def is_prime(num):
  if num <= 1:
    return False
  for i in range(2, int(num**0.5) + 1):
    if num % i == 0:
      return False
  return True

def smallest_special_prime(num):
  while True:
    if is_special_prime(num):
      return num
    num += 1
```"
221,Minimum number of given moves required to make N divisible by 25 | Java implementation of the approach ; Function to return the minimum number of moves required to make n divisible by 25 ; Convert number into string ; To store required answer ; Length of the string ; To check all possible pairs ; Make a duplicate string ; Number of swaps required to place ith digit in last position ; Number of swaps required to place jth digit in 2 nd last position ; Find first non zero digit ; Place first non zero digit in the first position ; Convert string to number ; If this number is divisible by 25 then cur is one of the possible answer ; If not possible ; Driver code,"```java
public static int minMoves(int n) {
    String s = String.valueOf(n);
    int ans = Integer.MAX_VALUE;
    int len = s.length();
    for (int i = 0; i < len; i++) {
        for (int j = i + 1; j < len; j++) {
            String temp = new String(s);
            int swaps1 = Math.abs(i - (len - 1));
            int swaps2 = Math.abs(j - (len - 2));
            int firstNonZero = -1;
            for (int k = 0; k < len; k++) {
                if (temp.charAt(k) != '0') {
                    firstNonZero = k;
                    break;
                }
            }
            if (firstNonZero != -1) {
                char tempChar = temp.charAt(firstNonZero);
                temp = temp.substring(0, firstNonZero) + temp.substring(firstNonZero + 1);
                temp = temp.substring(0, 0) + tempChar + temp.substring(0);
                temp = temp.substring(0, len - 1 - i) + temp.charAt(len - 1 - i) + temp.substring(len - 1 - i + 1, len - 1) + temp.charAt(len - 1) + temp.substring(len);
                temp = temp.substring(0, len - 2 - j) + temp.charAt(len - 2 - j) + temp.substring(len - 2 - j + 1, len - 2) + temp.charAt(len - 2) + temp.substring(len - 1);
                int cur = swaps1 + swaps2;
                int num = Integer.parseInt(temp);
                if (num % 25 == 0) {
                    ans = Math.min(ans, cur);
                }
            }
        }
    }
    if (ans == Integer.MAX_VALUE) {
        return -1;
    }
    return ans;
}
```","```python
def minMoves(n):
  s = str(n)
  ans = float('inf')
  l = len(s)
  for i in range(l):
    for j in range(i + 1, l):
      t = list(s)
      swaps1 = abs(i - (l - 1))
      swaps2 = abs(j - (l - 2))
      t[l - 1] = s[i]
      t[l - 2] = s[j]
      k = 0
      while k < l and t[k] == '0':
        k += 1
      t[0] = t[k]
      t[k] = '0'
      cur = int("""".join(t))
      if cur % 25 == 0:
        ans = min(ans, swaps1 + swaps2)
  if ans == float('inf'):
    return -1
  return ans
```"
222,"Maximum positive integer divisible by C and is in the range [ A , B ] | Java implementation of the above approach ; Function to return the required number ; If b % c = 0 then b is the required number ; Else get the maximum multiple of c smaller than b ; Driver code","```java
public static int getMaxPositiveIntDivisibleByC(int a, int b, int c) {
    if (b % c == 0) {
      return b;
    } else {
      return b - (b % c);
    }
  }
```","```python
def maximum_divisible(a, b, c):
  if b % c == 0:
    return b
  else:
    return (b // c) * c
```"
223,"Count of pairs ( x , y ) in an array such that x < y | Java implementation of the approach ; Function to return the number of pairs ( x , y ) such that x < y ; Length of the array ; Calculate the number of valid pairs ; Return the count of valid pairs ; Driver code","```java
public static int countPairs(int[] arr, int n) {
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] < arr[j]) {
                count++;
            }
        }
    }
    return count;
}
```","```python
def countPairs(arr, n):
  count = 0
  for i in range(n):
    for j in range(i + 1, n):
      if arr[i] < arr[j]:
        count += 1
  return count
```"
224,Count the total number of squares that can be visited by Bishop in one move | Java implementation of above approach ; Function to return the count of total positions the Bishop can visit in a single move ; Count top left squares ; Count bottom right squares ; Count top right squares ; Count bottom left squares ; Return total count ; Driver code ; Bishop 's Position,"```java
public static int countReachableSquares(int N, int row, int col) {
    int topLeft = Math.min(row, col);
    int bottomRight = Math.min(N - row, N - col);
    int topRight = Math.min(row, N - col);
    int bottomLeft = Math.min(N - row, col);
    return topLeft + bottomRight + topRight + bottomLeft - 3;
}
```","```python
def count_reachable_squares(row, col):
  top_left = min(row, col)
  bottom_right = min(8 - row, 8 - col)
  top_right = min(row, 8 - col)
  bottom_left = min(8 - row, col)
  return top_left + bottom_right + top_right + bottom_left - 4 
```"
225,Check whether Bishop can take down Pawn or not | Java implementation of above approach ; Function that return true if the Bishop can take down the pawn ; If pawn is at angle 45 or 225 degree from bishop 's Position ; If pawn is at angle 135 or 315 degree from bishop 's Position ; Driver code ; Bishop 's Position ; Pawn 's Position,"```java
public static boolean canBishopTakePawn(int bishopX, int bishopY, int pawnX, int pawnY) {
    return (Math.abs(bishopX - pawnX) == Math.abs(bishopY - pawnY));
}
```","```python
def can_bishop_take_pawn(bishop_x, bishop_y, pawn_x, pawn_y):
  return abs(bishop_x - pawn_x) == abs(bishop_y - pawn_y)
```"
226,Find maximum operations to reduce N to 1 | Java program to find maximum number moves possible ; To store number of prime factors of each number ; Function to find number of prime factors of each number ; if i is a prime number ; increase value by one from it 's preveious multiple ; make prefix sum this will be helpful for multiple test cases ; Driver Code ; Generate primeFactors array ; required answer,"```java
public static int maxOperations(int n) {
    int[] primeFactors = new int[n + 1];
    generatePrimeFactors(primeFactors);
    int[] prefixSum = new int[n + 1];
    for (int i = 1; i <= n; i++) {
        prefixSum[i] = prefixSum[i - 1] + primeFactors[i];
    }
    return prefixSum[n];
}

private static void generatePrimeFactors(int[] primeFactors) {
    for (int i = 2; i <= primeFactors.length; i++) {
        if (primeFactors[i] == 0) {
            for (int j = i; j <= primeFactors.length; j += i) {
                primeFactors[j]++;
            }
        }
    }
}
```","```python
def maxOperations(n):
  primeFactors = [0] * (n + 1)
  for i in range(2, n + 1):
    if primeFactors[i] == 0:
      for j in range(i, n + 1, i):
        primeFactors[j] += 1
  for i in range(1, n + 1):
    primeFactors[i] += primeFactors[i - 1]
  return primeFactors[n]
```"
227,Smallest integer with digit sum M and multiple of N | Java implementation of the above approach ; Function to return digit sum ; Function to find out the smallest integer ; Start of the iterator ( Smallest multiple of n ) ; Driver code,"```java
public class SmallestInteger {

    public static int digitSum(int num) {
        int sum = 0;
        while (num > 0) {
            sum += num % 10;
            num /= 10;
        }
        return sum;
    }

    public static int findSmallestInteger(int m, int n) {
        int i = n;
        while (true) {
            if (digitSum(i) == m) {
                return i;
            }
            i += n;
        }
    }

    public static void main(String[] args) {
        int m = 10;
        int n = 3;
        System.out.println(findSmallestInteger(m, n));
    }
}
```","```python
def digitSum(num):
  sum = 0
  while num > 0:
    sum += num % 10
    num //= 10
  return sum

def smallestInteger(M, N):
  i = N
  while True:
    if digitSum(i) == M:
      return i
    i += N
```"
228,Maximum sum after repeatedly dividing N by a divisor | Java implementation of the above approach ; Function to find the smallest divisor ; Function to find the maximum sum ; Driver Code,"```java
import java.util.*;
public class Solution {
    public static int findSmallestDivisor(int n) {
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) {
                return i;
            }
        }
        return n;
    }
    public static int findMaximumSum(int n) {
        int sum = 0;
        while (n > 1) {
            int divisor = findSmallestDivisor(n);
            sum += divisor;
            n /= divisor;
        }
        return sum;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(findMaximumSum(n));
    }
}
```","```python
def find_smallest_divisor(n):
  for i in range(2, int(n**0.5) + 1):
    if n % i == 0:
      return i
  return n

def find_maximum_sum(n):
  max_sum = 0
  while n > 1:
    divisor = find_smallest_divisor(n)
    max_sum += divisor
    n //= divisor
  return max_sum
```"
229,Make all elements of an array equal with the given operation | Java implementation of the approach ; Function that returns true if all the elements of the array can be made equal with the given operation ; To store the sum of the array elements and the maximum element from the array ; Driver code,"```java
public static boolean canMakeEqual(int[] arr) {
    if (arr.length == 0) {
      return true;
    }
    int sum = 0;
    int max = arr[0];
    for (int i = 0; i < arr.length; i++) {
      sum += arr[i];
      max = Math.max(max, arr[i]);
    }
    return (sum - max) % (arr.length - 1) == 0;
  }
```","```python
def can_make_equal(arr):
  n = len(arr)
  if n == 0:
    return True
  sum_arr = 0
  max_arr = arr[0]
  for i in range(n):
    sum_arr += arr[i]
    max_arr = max(max_arr, arr[i])
  return (sum_arr - max_arr) % (n - 1) == 0
```"
230,Maximize the value of x + y + z such that ax + by + cz = n | Java implementation of the approach ; Function to return the maximum value of ( x + y + z ) such that ( ax + by + cz = n ) ; i represents possible values of a * x ; j represents possible values of b * y ; If z is an integer ; Driver code ; Function Call,"```java
public static int maximize(int a, int b, int c, int n) {
    int max = Integer.MIN_VALUE;
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            if ((n - i - j) % c == 0) {
                int z = (n - i - j) / c;
                max = Math.max(max, i / a + j / b + z);
            }
        }
    }
    return max;
}
```","```python
def maximize_xyz(a, b, c, n):
  max_sum = 0
  for i in range(n + 1):
    for j in range(n + 1):
      if (n - i - j) % c == 0:
        z = (n - i - j) // c
        current_sum = i // a + j // b + z
        max_sum = max(max_sum, current_sum)
  return max_sum
```"
231,Make all numbers of an array equal | Java implementation of above approach ; Function that returns true if all the array elements can be made equal with the given operation ; Divide number by 2 ; Divide number by 3 ; Driver code,"```java
public static boolean canMakeEqual(int[] arr) {
    int sum = 0;
    for (int num : arr) {
      sum += num;
    }
    if (sum % 2 != 0 || sum % 3 != 0) {
      return false;
    }
    for (int i = 0; i < arr.length; i++) {
      while (arr[i] % 2 == 0) {
        arr[i] /= 2;
      }
      while (arr[i] % 3 == 0) {
        arr[i] /= 3;
      }
    }
    for (int i = 1; i < arr.length; i++) {
      if (arr[i] != arr[0]) {
        return false;
      }
    }
    return true;
  }
```","```python
def canMakeEqual(arr):
  n = len(arr)
  sum = 0
  for i in range(n):
    sum += arr[i]
  if sum % 3 != 0:
    return False
  for i in range(n):
    arr[i] %= 3
  count = 0
  for i in range(n):
    if arr[i] == 1:
      count += 1
  if count == n or count == 0:
    return True
  return False
```"
232,Maximum GCD from Given Product of Unknowns | Java implementation of the approach ; Function to return the required gcd ; Count the number of times 2 divides p ; Equivalent to p = p \/ 2 ; ; If 2 divides p ; Check all the possible numbers that can divide p ; If n in the end is a prime number ; Return the required gcd ; Driver code,"```java
public static int maxGCD(int p) {
    int count = 0;
    while ((p & 1) == 0) {
      count++;
      p >>= 1;
    }
    if (count > 0) {
      for (int n = 3; n * n <= p; n += 2) {
        while (p % n == 0) {
          p /= n;
        }
      }
      if (p > 1) {
        return (int) Math.pow(2, count) * p;
      } else {
        return (int) Math.pow(2, count);
      }
    }
    return 1;
  }
```","```python
def max_gcd(p):
  cnt = 0
  while p % 2 == 0:
    cnt += 1
    p //= 2
  if p == 1:
    return 2 ** (cnt - 1)
  n = 3
  while n * n <= p:
    if p % n == 0:
      return 2 ** (cnt - 1)
    n += 2
  return 2 ** (cnt - 1) * p
```"
233,"Minimum positive integer divisible by C and is not in range [ A , B ] | Java implementation of the approach ; Function to return the required number ; If doesn 't belong to the range  then c is the required number ; Else get the next multiple of c starting from b + 1 ; Driver code","```java
public static int findMinDivisible(int A, int B, int C) {
    if (A >= C || B < C) {
      return C;
    } else {
      return (B + 1) / C * C;
    }
  }
```","```python
def find_min_positive_divisible(A, B, C):
  if A >= C or B < C:
    return C
  else:
    return (B + 1) // C * C
```"
234,"Count of pairs of ( i , j ) such that ( ( n % i ) % j ) % n is maximized | Java implementation of the approach ; Function to return the count of required pairs ; Special case ; Number which will give the max value for ( ( n % i ) % j ) % n ; To store the maximum possible value of ( ( n % i ) % j ) % n ; Count of possible pairs ; Driver code","```java
public static int countPairs(int n) {
    if (n == 1) {
        return 0;
    }
    int maxVal = n - 1;
    int count = 0;
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < n; j++) {
            if (((n % i) % j) % n == maxVal) {
                count++;
            }
        }
    }
    return count;
}
```","```python
def count_pairs(n):
  if n == 1:
    return 0
  max_val = n - 1
  count = 0
  for i in range(1, n):
    for j in range(1, n):
      if ((n % i) % j) % n == max_val:
        count += 1
  return count
```"
235,Remove characters from a numeric string such that string becomes divisible by 8 | Java program to remove digits from a numeric string such that the number becomes divisible by 8 ; Function that return true if sub is a sub - sequence in s ; Function to return a multiple of 8 formed after removing 0 or more characters from the given string ; Iterate over all multiples of 8 ; If current multiple exists as a subsequence in the given string ; Driver Code,"```java
public static String removeCharsForDivisibilityBy8(String str) {
    for (int i = 0; i <= 1000; i++) {
      if (isSubsequence(Integer.toString(i * 8), str)) {
        return Integer.toString(i * 8);
      }
    }
    return ""-1"";
  }

  public static boolean isSubsequence(String sub, String s) {
    int j = 0;
    for (int i = 0; i < s.length() && j < sub.length(); i++) {
      if (s.charAt(i) == sub.charAt(j)) {
        j++;
      }
    }
    return j == sub.length();
  }
```","```python
def is_subsequence(s, sub):
  i = 0
  j = 0
  while i < len(s) and j < len(sub):
    if s[i] == sub[j]:
      j += 1
    i += 1
  return j == len(sub)

def remove_digits_to_make_divisible_by_8(s):
  for i in range(8, len(s) * 10 + 1, 8):
    if is_subsequence(s, str(i)):
      return str(i)
  return ""-1""
```"
236,Program to check if a number is divisible by any of its digits | JAva implementation of above approach ; Converting integer to string ; Traversing the string ; find the actual digit ; If the number is divisible by digits then return yes ; If no digits are dividing the number then return no ; Driver Code ; passing this number to get result function,"```java
public static String isDivisibleByDigit(int num) {
    String numStr = String.valueOf(num);
    for (int i = 0; i < numStr.length(); i++) {
        int digit = Integer.parseInt(String.valueOf(numStr.charAt(i)));
        if (digit != 0 && num % digit == 0) {
            return ""yes"";
        }
    }
    return ""no"";
}
```","```python
def is_divisible_by_digit(number):
  number_str = str(number)
  for digit_str in number_str:
    digit = int(digit_str)
    if digit != 0 and number % digit == 0:
      return ""yes""
  return ""no""
```"
237,Program to find sum of harmonic series | Java program to find sum of harmonic series using recursion ; Base condition ; Driven Code,"```java
public static double harmonicSum(int n) {
    if (n == 1) {
      return 1;
    }
    return (1.0 / n) + harmonicSum(n - 1);
  }
```","```python
def harmonic_sum(n):
  if n == 1:
    return 1
  else:
    return 1/n + harmonic_sum(n-1)
```"
238,Sum of P terms of an AP if Mth and Nth terms are given | Java implementation of the above approach ; Function to calculate the value of the ; Calculate value of d using formula ; Calculate value of a using formula ; Return pair ; Function to calculate value sum of first p numbers of the series ; First calculate value of a and d ; Calculate the sum by using formula ; Return the sum ; Driver Code,"```java
public static int sumOfAP(int m, int n, int p) {
    int d = (n - m) / (p - 1);
    int a = m - (m - 1) * d;
    return (p / 2) * (2 * a + (p - 1) * d);
  }
```","```python
def sum_of_ap(m, n, p):
  d = (n - m) / (p - 1)
  a = m - (p - 1) * d
  return (p / 2) * (2 * a + (p - 1) * d)
```"
239,Print all integers that are sum of powers of two given numbers | Java implementation of the approach ; Function to print powerful integers ; Set is used to store distinct numbers in sorted order ; Store all the powers of y < bound in a vector to avoid calculating them again and again ; x ^ i ; If num is within limits insert it into the set ; Break out of the inner loop ; Adding any number to it will be out of bounds ; Increment i ; Print the contents of the set ; Driver code ; Print powerful integers,"```java
import java.util.*;
public class PowerfulIntegers {
    public static void powerfulIntegers(int x, int y, int bound) {
        Set<Integer> set = new TreeSet<>();
        List<Integer> powersOfY = new ArrayList<>();
        int power = 1;
        while (power <= bound) {
            powersOfY.add(power);
            power *= y;
        }
        for (int i = 0; Math.pow(x, i) <= bound; i++) {
            for (int j = 0; j < powersOfY.size(); j++) {
                int num = (int) Math.pow(x, i) + powersOfY.get(j);
                if (num <= bound) {
                    set.add(num);
                } else {
                    break;
                }
            }
        }
        for (int num : set) {
            System.out.print(num + "" "");
        }
    }
    public static void main(String[] args) {
        int x = 2, y = 3, bound = 10;
        powerfulIntegers(x, y, bound);
    }
}
```","```python
def printPowerfulIntegers(x, y, bound):
  s = set()
  powers_of_y = []
  i = 0
  while x ** i <= bound:
    powers_of_y.append(x ** i)
    i += 1
  for num in powers_of_y:
    j = 0
    while y ** j <= bound:
      if num + y ** j <= bound:
        s.add(num + y ** j)
      else:
        break
      j += 1
  for num in sorted(s):
    print(num, end="" "")
```"
240,Distribute N candies among K people | Java code for better approach to distribute candies ; Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Last term of last and current series ; Sum of current and last series ; Sum of current series only ; If sum of current is less than N ; else Individually distribute ; First term ; Distribute candies till there ; Candies available ; Not available ; Count the total candies ; Print the total candies ; Driver Code,"```java
public static void distributeCandies(int N, int K) {
    int candiesAvailable = N;
    int count = 0;
    int firstTerm = 1;
    int lastTerm = 0;
    int currentSeriesSum = 0;
    int lastSeriesSum = 0;

    while (candiesAvailable > 0) {
        lastTerm = firstTerm + K - 1;
        currentSeriesSum = (K / 2) * (firstTerm + lastTerm);
        lastSeriesSum = (K / 2) * (firstTerm - 1 + (firstTerm - 1 + K - 1));

        if (currentSeriesSum <= candiesAvailable) {
            candiesAvailable -= currentSeriesSum;
            count++;
            firstTerm = lastTerm + 1;
        } else {
            int candiesToDistribute = candiesAvailable;
            for (int i = 0; i < K && candiesToDistribute > 0; i++) {
                System.out.print((firstTerm + i) + "" "");
                candiesToDistribute--;
            }
            candiesAvailable = 0;
        }
    }

    System.out.println(""\nTotal candies distributed: "" + (N - candiesAvailable));
}
```","```python
def distribute_candies(N, K):
  candies = [0] * K
  complete_turns = 0
  last_term = 0
  available_candies = N
  while available_candies > 0:
    first_term = 1 + complete_turns * K
    last_term = first_term + K - 1
    sum_current_series = (last_term + first_term) * K // 2
    sum_last_series = (last_term + 1) * K // 2
    if sum_current_series <= available_candies:
      available_candies -= sum_current_series
      for i in range(K):
        candies[i] += last_term - i
      complete_turns += 1
    else:
      for i in range(K):
        if available_candies > 0:
          candies[i] += 1
          available_candies -= 1
  return candies
```"
241,Distribute N candies among K people | Java implementation of the above approach ; Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Do a binary search to find the number whose sum is less than N . ; Get mide ; If sum is below N ; Find number of complete turns ; Right halve ; Left halve ; Last term of last complete series ; Subtract the sum till ; First term of incomplete series ; Count the total candies ; Print the total candies ; Driver Code,"```java
public static int[] distributeCandies(int N, int K) {
    int completeTurns = (int) Math.floor((double) N / (K * (K + 1) / 2));
    int lastTerm = completeTurns * K;
    int candies = completeTurns * (K * (K + 1) / 2);
    int left = 0;
    int right = lastTerm;
    while (left <= right) {
        int mid = (left + right) / 2;
        int sum = (mid * (mid + 1) / 2);
        if (sum <= N) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    completeTurns = right;
    candies = completeTurns * (K * (K + 1) / 2);
    lastTerm = completeTurns * K;
    candies += (N - (completeTurns * (K * (K + 1) / 2)));
    int[] result = new int[K];
    for (int i = 0; i < K; i++) {
        if (i <= lastTerm) {
            result[i] = completeTurns + 1;
        } else {
            result[i] = completeTurns;
        }
    }
    return result;
}
```","```python
def distributeCandies(N, K):
  left = 0
  right = N
  while left <= right:
    mid = (left + right) // 2
    sum = (mid * (mid + 1)) // 2
    if sum <= N:
      left = mid + 1
    else:
      right = mid - 1
  completeTurns = right
  lastTerm = completeTurns * (completeTurns + 1) // 2
  candies = N - lastTerm
  firstTerm = completeTurns + 1
  totalCandies = candies + firstTerm
  return totalCandies
```"
242,"Smallest multiple of 3 which consists of three given non | Java implementation of the approach ; Function to return the minimum number divisible by 3 formed by the given digits ; Sort the given array in ascending ; Check if any single digit is divisible by 3 ; Check if any two digit number formed by the given digits is divisible by 3 starting from the minimum ; Generate the two digit number ; If none of the above is true , we can form three digit number by taking a [ 0 ] three times . ; Driver code","```java
public static int smallestMultipleOf3(int[] a) {
    Arrays.sort(a);
    for (int i = 0; i < a.length; i++) {
        if (a[i] % 3 == 0) {
            return a[i];
        }
    }
    for (int i = 0; i < a.length - 1; i++) {
        for (int j = i + 1; j < a.length; j++) {
            int num = a[i] * 10 + a[j];
            if (num % 3 == 0) {
                return num;
            }
        }
    }
    return a[0] * 100 + a[0] * 10 + a[0];
}
```","```python
def smallest_multiple_of_3(a):
  a.sort()
  for i in range(len(a)):
    if a[i] % 3 == 0:
      return a[i]
  for i in range(len(a) - 1):
    for j in range(i + 1, len(a)):
      num = int(str(a[i]) + str(a[j]))
      if num % 3 == 0:
        return num
  return int(str(a[0]) * 3)
```"
243,Print matrix after applying increment operations in M ranges | Java implementation of the approach ; Function to update and print the matrix after performing queries ; Add 1 to the first element of the sub - matrix ; If there is an element after the last element of the sub - matrix then decrement it by 1 ; Calculate the running sum ; Print the updated element ; Next line ; Driver code ; Size of the matrix ; Queries,"```java
public static void updateMatrix(int[][] matrix, int[][] queries) {
    for (int[] query : queries) {
        int rowStart = query[0];
        int colStart = query[1];
        int rowEnd = query[2];
        int colEnd = query[3];

        matrix[rowStart][colStart]++;
        if (colEnd + 1 < matrix[0].length) {
            matrix[rowEnd][colEnd + 1]--;
        }
    }

    for (int i = 0; i < matrix.length; i++) {
        for (int j = 1; j < matrix[0].length; j++) {
            matrix[i][j] += matrix[i][j - 1];
        }
    }

    for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[0].length; j++) {
            System.out.print(matrix[i][j] + "" "");
        }
        System.out.println();
    }
}
```","```python
def update_matrix(n, queries):
  matrix = [[0 for _ in range(n)] for _ in range(n)]
  for query in queries:
    r1, c1, r2, c2 = query
    matrix[r1][c1] += 1
    if c2 + 1 < n:
      matrix[r2][c2 + 1] -= 1
  for i in range(n):
    for j in range(n):
      if j > 0:
        matrix[i][j] += matrix[i][j - 1]
      print(matrix[i][j], end=' ')
    print()
```"
244,Replace the maximum element in the array by coefficient of range | Java implementation to replace maximum element by coefficient of range ; Utility function to print the contents of the array ; Function to replace the maximum element from the array with the coefficient of range of the array ; Maximum element from the array ; Minimum element from the array ; Calculate the coefficient of range for the array ; Assuming all the array elements are distinc Replace the maximum element with the coefficient of range of the array ; Print the updated array ; Driver code,"```java
public static void replaceMaxWithCoefficientOfRange(int[] arr) {
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
      if (arr[i] < min) {
        min = arr[i];
      }
    }
    double coefficientOfRange = (double) (max - min) / (max + min);
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == max) {
        arr[i] = (int) coefficientOfRange;
        break;
      }
    }
  }
```","```python
def replace_max_with_coefficient_of_range(arr):
  max_element = max(arr)
  min_element = min(arr)
  coefficient_of_range = (max_element - min_element) / min_element
  arr[arr.index(max_element)] = coefficient_of_range
  return arr
```"
245,Divide the two given numbers by their common divisors | Java implementation of above approach ; print the numbers after dividing them by their common factors ; iterate from 1 to minimum of a and b ; if i is the common factor of both the numbers ; Driver code ; divide A and B by their common factors,"```java
public static void divideByCommonDivisors(int a, int b) {
    for (int i = 1; i <= Math.min(a, b); i++) {
        if (a % i == 0 && b % i == 0) {
            a /= i;
            b /= i;
        }
    }
    System.out.println(a + "" "" + b);
}
```","```python
def divide_by_common_divisors(a, b):
  for i in range(1, min(a, b) + 1):
    if a % i == 0 and b % i == 0:
      a //= i
      b //= i
  return a, b
```"
246,"Divide the two given numbers by their common divisors | Java implementation of above approach ; Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Driver code","```java
public static void commonDivisors(int a, int b) {
    int gcd = gcd(a, b);
    for (int i = 1; i <= gcd; i++) {
        if (gcd % i == 0) {
            System.out.print(i + "" "");
        }
    }
}

public static int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}
```","```python
def common_divisors(a, b):
  gcd = 1
  for i in range(1, min(a, b) + 1):
    if a % i == 0 and b % i == 0:
      gcd = i
  return gcd
```"
247,Minimum absolute difference between N and a power of 2 | Java implementation of the above approach ; Function to return the minimum difference between N and a power of 2 ; Power of 2 closest to n on its left ; Power of 2 closest to n on its right ; Return the minimum abs difference ; Driver code,"```java
public static int minAbsoluteDifference(int n) {
    int leftPower = 1;
    while (leftPower <= n / 2) {
      leftPower *= 2;
    }
    int rightPower = leftPower * 2;
    return Math.min(Math.abs(n - leftPower), Math.abs(n - rightPower));
  }
```","```python
def min_abs_difference(n):
  left = 1
  while left <= n:
    left <<= 1
  right = left >> 1
  return min(n - right, left - n)
```"
248,Find probability that a player wins when probabilities of hitting the target are given | Java implementation of the approach ; Function to return the probability of the winner ; Driver Code ; Will print 9 digits after the decimal point,"```java
import java.util.*;
import java.lang.*;
class Solution {
    public static double findWinnerProbability(double[] prob) {
        double player1Win = 0;
        double player2Win = 0;
        double currentProb = 1;
        for (int i = 0; i < prob.length; i++) {
            if (i % 2 == 0) {
                player1Win += currentProb * prob[i];
            } else {
                player2Win += currentProb * prob[i];
            }
            currentProb *= (1 - prob[i]);
        }
        return player1Win;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        double[] prob = new double[n];
        for (int i = 0; i < n; i++) {
            prob[i] = sc.nextDouble();
        }
        System.out.printf(""%.9f\n"", findWinnerProbability(prob));
    }
}
```","```python
def findProbability(p1, p2):
  return p1 / (p1 + p2)
```"
249,Represent n as the sum of exactly k powers of two | Set 2 | Java implementation of the above approach ; Function to print k numbers which are powers of two and whose sum is equal to n ; Initialising the sum with k ; Initialising an array A with k elements and filling all elements with 1 ; Iterating A [ ] from k - 1 to 0 ; Update sum and A [ i ] till sum + A [ i ] is less than equal to n ; Impossible to find the combination ; Possible solution is stored in A [ ] ; Driver code,"```java
public static void printPowersOfTwoSum(int n, int k) {
    int sum = k;
    int[] A = new int[k];
    for (int i = 0; i < k; i++) {
      A[i] = 1;
    }
    for (int i = k - 1; i >= 0; i--) {
      while (sum + A[i] <= n) {
        sum += A[i];
        A[i] *= 2;
      }
    }
    if (sum != n) {
      System.out.println(""Impossible"");
    } else {
      for (int i = 0; i < k; i++) {
        System.out.print(A[i] + "" "");
      }
      System.out.println();
    }
  }
```","```python
def printPowersOfTwo(n, k):
  sum = k
  A = [1] * k
  for i in range(k - 1, -1, -1):
    while sum + A[i] <= n:
      sum += A[i]
      A[i] <<= 1
    if sum == n:
      for i in range(k):
        print(A[i], end="" "")
      return
  print(""Impossible"")

# Driver code
n = 10
k = 3
printPowersOfTwo(n, k)
```"
250,"Check whether a + b = c or not after removing all zeroes from a , b and c | Java program to check the sum after Removing all zeroes is true or not ; Function to remove zeroes ; Initialize result to zero holds the Result after removing zeroes from no ; Initialize variable d to 1 that holds digits of no ; Loop while n is greater then zero ; Check if n mod 10 is not equal to zero ; store the result by removing zeroes And increment d by 10 ; Go to the next digit ; Return the result ; Function to check if sum is true after Removing all zeroes . ; Call removeZero ( ) for both sides and check whether they are equal After removing zeroes . ; Driver code","```java
public static int removeZero(int n) {
    int result = 0;
    int d = 1;
    while (n > 0) {
      if (n % 10 != 0) {
        result += n % 10 * d;
        d *= 10;
      }
      n /= 10;
    }
    return result;
  }
  public static boolean checkSum(int a, int b, int c) {
    return removeZero(a) + removeZero(b) == removeZero(c);
  }
  public static void main(String[] args) {
    int a = 10203;
    int b = 4050;
    int c = 14253;
    System.out.println(checkSum(a, b, c));
  }
```","```python
def removeZeroes(n):
  result = 0
  d = 1
  while n > 0:
    if n % 10 != 0:
      result += n % 10 * d
      d *= 10
    n //= 10
  return result

def checkSum(a, b, c):
  return removeZeroes(a) + removeZeroes(b) == removeZeroes(c)
```"
251,"A Sum Array Puzzle | Java implementation of above approach ; Allocate memory for temporary arrays leftSum [ ] , rightSum [ ] and Sum [ ] ; Left most element of left array is always 0 ; Right most element of right array is always 0 ; Construct the left array ; Construct the right array ; Construct the sum array using left [ ] and right [ ] ; print the sum array ; Driver function to test above function","```java
public static void sumArrayPuzzle(int[] arr) {
    int n = arr.length;
    int[] leftSum = new int[n];
    int[] rightSum = new int[n];
    int[] sum = new int[n];
    leftSum[0] = 0;
    for (int i = 1; i < n; i++) {
      leftSum[i] = leftSum[i - 1] + arr[i - 1];
    }
    rightSum[n - 1] = 0;
    for (int i = n - 2; i >= 0; i--) {
      rightSum[i] = rightSum[i + 1] + arr[i + 1];
    }
    for (int i = 0; i < n; i++) {
      sum[i] = leftSum[i] + rightSum[i];
    }
    for (int i = 0; i < n; i++) {
      System.out.print(sum[i] + "" "");
    }
    System.out.println();
  }
```","```python
def sum_array_puzzle(arr):
  n = len(arr)
  leftSum = [0] * n
  rightSum = [0] * n
  Sum = [0] * n
  leftSum[0] = 0
  rightSum[n-1] = 0
  for i in range(1, n):
    leftSum[i] = leftSum[i-1] + arr[i-1]
  for i in range(n-2, -1, -1):
    rightSum[i] = rightSum[i+1] + arr[i+1]
  for i in range(n):
    Sum[i] = leftSum[i] + rightSum[i]
  return Sum
```"
252,Find minimum x such that ( x % k ) * ( x \/ k ) == n | Set | Java Program to find the minimum positive X such that the given equation holds true ; This function gives the required answer ; Iterate for all the factors ; Check if i is a factor ; Consider i to be A and n \/ i to be B ; Consider i to be B and n \/ i to be A ; Driver Code to test above function,"```java
public static int findMinX(int k, int n) {
    for (int i = 1; i <= n; i++) {
        if (n % i == 0) {
            int A = i;
            int B = n / i;
            if ((A % k) * (B % k) == n) {
                return A;
            }
            if ((B % k) * (A % k) == n) {
                return B;
            }
        }
    }
    return -1;
}
```","```python
def find_min_x(n, k):
  for i in range(1, n + 1):
    if n % i == 0:
      a = i
      b = n // i
      if (a % k) * (b % k) == n:
        return a
      if (b % k) * (a % k) == n:
        return b
  return -1
```"
253,Find minimum x such that ( x % k ) * ( x \/ k ) == n | Java Program to find the minimum positive X such that the given equation holds true ; This function gives the required answer ; Iterate over all possible remainders ; it must divide n ; Driver Code to test above function,"```java
public static int findMinX(int k, int n) {
    for (int r = 0; r < k; r++) {
        if (n % r == 0) {
            int x = (n / r) * k + r;
            if ((x % k) * (x / k) == n) {
                return x;
            }
        }
    }
    return -1;
}
```","```python
def find_min_x(k, n):
  for remainder in range(k):
    if n % remainder == 0:
      x = remainder + (n // remainder) * k
      return x
  return -1
```"
254,Find nth Hermite number | Java program to find nth Hermite number ; Function to return nth Hermite number ; Base condition ; Driver Code ; Print nth Hermite number,"```java
public static int hermite(int n) {
    if (n == 0) {
        return 1;
    } else if (n == 1) {
        return 2;
    } else {
        return 2 * (n - 1) * hermite(n - 2) - 2 * (n - 2) * hermite(n - 1);
    }
}
```","```python
def hermite(n):
  if n == 0:
    return 1
  elif n == 1:
    return 2 * n
  else:
    return 2 * n * hermite(n - 1) - 2 * (n - 1) * hermite(n - 2)
```"
255,Find numbers a and b that satisfy the given conditions | Java implementation of the above approach ; Function to print the required numbers ; Suppose b = n and we want a % b = 0 and also ( a \/ b ) < n so a = b * ( n - 1 ) ; Special case if n = 1 we get a = 0 so ( a * b ) < n ; If no pair satisfies the conditions ; Driver code,"```java
public static void findNumbers(int n) {
    if (n == 1) {
        System.out.println(""0 1"");
        return;
    }
    int a = (n - 1) * n;
    if ((a % n) == 0 && (a / n) < n) {
        System.out.println(a + "" "" + n);
    } else {
        System.out.println(""No such pair exists"");
    }
}
```","```python
def find_numbers(n):
  if n == 1:
    return 0, 1
  else:
    a = n * (n - 1)
    b = n
    if (a * b) < n:
      return a, b
    else:
      return None, None
```"
256,Closest perfect square and its distance | Java program to find the closest perfect square taking minimum steps to reach from a number ; Function to check if a number is perfect square or not ; Function to find the closest perfect square taking minimum steps to reach from a number ; Variables to store first perfect square number above and below N ; Finding first perfect square number greater than N ; Finding first perfect square number less than N ; Variables to store the differences ; Driver code,"```java
public static int closestPerfectSquare(int n) {
    int firstPerfectSquareAboveN = findFirstPerfectSquareGreaterThanN(n);
    int firstPerfectSquareBelowN = findFirstPerfectSquareLessThanN(n);
    int diffAbove = Math.abs(firstPerfectSquareAboveN - n);
    int diffBelow = Math.abs(firstPerfectSquareBelowN - n);
    return diffAbove < diffBelow ? firstPerfectSquareAboveN : firstPerfectSquareBelowN;
}

public static int findFirstPerfectSquareGreaterThanN(int n) {
    int i = (int) Math.sqrt(n) + 1;
    while (!isPerfectSquare(i * i)) {
        i++;
    }
    return i * i;
}

public static int findFirstPerfectSquareLessThanN(int n) {
    int i = (int) Math.sqrt(n);
    while (!isPerfectSquare(i * i)) {
        i--;
    }
    return i * i;
}

public static boolean isPerfectSquare(int n) {
    return Math.sqrt(n) % 1 == 0;
}
```","```python
def is_perfect_square(num):
  return int(num**0.5)**2 == num

def closest_perfect_square(n):
  upper_square = 1
  while upper_square**2 < n:
    upper_square += 1
  lower_square = upper_square - 1
  upper_diff = upper_square**2 - n
  lower_diff = n - lower_square**2
  if upper_diff < lower_diff:
    return upper_square**2
  else:
    return lower_square**2
```"
257,Fraction | Java program to add 2 fractions ; Function to return gcd of a and b ; Function to convert the obtained fraction into it 's simplest form ; Finding gcd of both terms ; Converting both terms into simpler terms by dividing them by common factor ; Function to add two fractions ; Finding gcd of den1 and den2 ; Denominator of final fraction obtained finding LCM of den1 and den2 LCM * GCD = a * b ; Changing the fractions to have same denominator . Numerator of the final fraction obtained ; Calling function to convert final fraction into it 's simplest form ; Driver Code,"```java
public static Fraction addFractions(Fraction frac1, Fraction frac2) {
    int gcd = gcd(frac1.den, frac2.den);
    int lcm = (frac1.den * frac2.den) / gcd;
    int num1 = frac1.num * (lcm / frac1.den);
    int num2 = frac2.num * (lcm / frac2.den);
    int finalNum = num1 + num2;
    Fraction finalFrac = new Fraction(finalNum, lcm);
    return simplifyFraction(finalFrac);
  }

  public static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }

  public static Fraction simplifyFraction(Fraction frac) {
    int gcd = gcd(frac.num, frac.den);
    return new Fraction(frac.num / gcd, frac.den / gcd);
  }

  public static class Fraction {
    public int num;
    public int den;

    public Fraction(int num, int den) {
      this.num = num;
      this.den = den;
    }
  }
```","```python
def gcd(a, b):
  while b:
    a, b = b, a % b
  return a

def simplify_fraction(num, den):
  common_factor = gcd(num, den)
  return num // common_factor, den // common_factor

def add_fractions(num1, den1, num2, den2):
  gcd_den = gcd(den1, den2)
  lcm_den = (den1 * den2) // gcd_den
  num1 = num1 * (lcm_den // den1)
  num2 = num2 * (lcm_den // den2)
  final_num = num1 + num2
  final_den = lcm_den
  return simplify_fraction(final_num, final_den)
```"
258,"Largest Divisor of a Number not divisible by a perfect square | Efficient Java Program to find the largest divisor not divisible by any perfect square greater than 1 ; Function to find the largest divisor not divisible by any perfect square greater than 1 ; If the number is divisible by i * i , then remove one i ; Now all squares are removed from n ; Driver Code","```java
public static int largestDivisor(int n) {
    for (int i = 2; i * i <= n; i++) {
        while (n % (i * i) == 0) {
            n /= i;
        }
    }
    return n;
}
```","```python
def largest_divisor_not_divisible_by_perfect_square(n):
  for i in range(2, int(n**0.5) + 1):
    while n % (i * i) == 0:
      n //= i
  return n
```"
259,"Arithmetic Progression | Java program to check if a given array can form arithmetic progression ; Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression ; Sort array ; After sorting , difference between consecutive elements must be same . ; driver code","```java
public static boolean canFormArithmeticProgression(int[] arr) {
    if (arr.length <= 2) {
      return true;
    }
    Arrays.sort(arr);
    int diff = arr[1] - arr[0];
    for (int i = 2; i < arr.length; i++) {
      if (arr[i] - arr[i - 1] != diff) {
        return false;
      }
    }
    return true;
  }
```","```python
def can_form_arithmetic_progression(arr):
  arr.sort()
  diff = arr[1] - arr[0]
  for i in range(2, len(arr)):
    if arr[i] - arr[i - 1] != diff:
      return False
  return True
```"
260,"Check if a number is Triperfect Number | Java code to check if a given number is Triperfect or not ; Returns true if n is Triperfect ; To store sum of divisors . Adding 1 and n since they are divisors of n . ; Find all divisors and add them ; If sum of divisors is equal to 3 * n , then n is a Triperfect number ; Driver program","```java
public static boolean isTriperfect(int n) {
    int sum = 1 + n;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            sum += i;
            if (i * i != n) {
                sum += n / i;
            }
        }
    }
    return sum == 3 * n;
}
```","```python
def isTriperfect(n):
  sum_divisors = 1 + n
  for i in range(2, int(n**0.5) + 1):
    if n % i == 0:
      sum_divisors += i + (n // i)
  return sum_divisors == 3 * n
```"
261,Sum of first N natural numbers which are divisible by X or Y | Java program to find sum of numbers from 1 to N which are divisible by X or Y ; Function to calculate the sum of numbers divisible by X or Y ; Driver code,"```java
public static int sumDivisibleByXOrY(int n, int x, int y) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
      if (i % x == 0 || i % y == 0) {
        sum += i;
      }
    }
    return sum;
  }
```","```python
def sum_divisible_by_x_or_y(n, x, y):
  sum = 0
  for i in range(1, n + 1):
    if i % x == 0 or i % y == 0:
      sum += i
  return sum
```"
262,"Count numbers from range whose prime factors are only 2 and 3 | Java program to count the numbers within a range whose prime factors are only 2 and 3 ; Function to count the number within a range whose prime factors are only 2 and 3 ; Start with 2 so that 1 doesn 't get counted ; While num is divisible by 2 , divide it by 2 ; While num is divisible by 3 , divide it by 3 ; If num got reduced to 1 then it has only 2 and 3 as prime factors ; Driver code","```java
public static int countNumbers(int low, int high) {
    int count = 0;
    for (int num = 2; num <= high; num++) {
        int temp = num;
        while (temp % 2 == 0) {
            temp /= 2;
        }
        while (temp % 3 == 0) {
            temp /= 3;
        }
        if (temp == 1) {
            count++;
        }
    }
    return count;
}
```","```python
def count_numbers(low, high):
  count = 0
  for num in range(low, high + 1):
    temp = num
    while temp % 2 == 0:
      temp //= 2
    while temp % 3 == 0:
      temp //= 3
    if temp == 1:
      count += 1
  return count
```"
263,Maximum number with same digit factorial product | Java implementation of the approach ; Function to return the required number ; Count the frequency of each digit ; 4 ! can be expressed as 2 ! * 2 ! * 3 ! ; 6 ! can be expressed as 5 ! * 3 ! ; 8 ! can be expressed as 7 ! * 2 ! * 2 ! * 2 ! ; 9 ! can be expressed as 7 ! * 3 ! * 3 ! * 2 ! ; To store the required number ; If number has only either 1 and 0 as its digits ; Generate the greatest number possible ; Driver code,"```java
public static int maxNumberSameDigitFactorialProduct(int n) {
    int[] freq = new int[10];
    int temp = n;
    while (temp > 0) {
      freq[temp % 10]++;
      temp /= 10;
    }
    if (freq[0] + freq[1] == 10) {
      return (int) Math.pow(10, freq[1]) - 1;
    }
    int result = 0;
    for (int i = 9; i >= 0; i--) {
      while (freq[i] > 0) {
        result = result * 10 + i;
        freq[i]--;
      }
    }
    return result;
  }
```","```python
def max_num_same_digit_factorial_product(n):
  freq = [0] * 10
  for i in str(n):
    freq[int(i)] += 1
  if sum(freq) == 2 and (freq[0] > 0 or freq[1] > 0):
    return int(""1"" * (freq[0] + freq[1]))
  result = 0
  for i in range(9, -1, -1):
    if freq[i] > 0:
      result = result * 10 + i * freq[i]
  return result
```"
264,"Program to find first N Iccanobif Numbers | Java program to find first N Icanobif numbers ; Iterative function to reverse digits of num ; Function to print first N Icanobif Numbers ; Initialize first , second numbers ; Print first two numbers ; Reversing digit of previous two terms and adding them ; Driver Code","```java
public static void printIccanobifNumbers(int n) {
    int first = 0;
    int second = 1;
    System.out.print(first + "" "" + second + "" "");
    for (int i = 2; i < n; i++) {
      int next = reverseDigits(first) + reverseDigits(second);
      System.out.print(next + "" "");
      first = second;
      second = next;
    }
  }
  public static int reverseDigits(int num) {
    int reversed = 0;
    while (num != 0) {
      int digit = num % 10;
      reversed = reversed * 10 + digit;
      num /= 10;
    }
    return reversed;
  }
```","```python
def print_iccanobif_numbers(n):
  first = 0
  second = 1
  print(first, second, end="" "")
  for i in range(2, n):
    next_term = int(str(first)[::-1]) + int(str(second)[::-1])
    print(next_term, end="" "")
    first = second
    second = next_term
```"
265,Add N digits to A such that it is divisible by B after each addition | Java implementation of the approach ; Try all digits from ( 0 to 9 ) ; Fails in the first move itself ; Add ( n - 1 ) 0 's ; Driver Program to test above function,"```java
public static int addDigits(int A, int B, int N) {
    for (int i = 0; i <= 9; i++) {
        if ((A * 10 + i) % B == 0) {
            return i;
        }
    }
    return (int) Math.pow(10, N - 1) - 1;
}
```","```python
def add_digits(A, B, N):
  for i in range(10):
    if (int(str(A) + str(i)) % B == 0):
      return str(A) + str(i)
  return str(A) + '0' * (N - 1)
```"
266,"Count number of triplets ( a , b , c ) such that a ^ 2 + b ^ 2 = c ^ 2 and 1 <= a <= b <= c <= n | Java program to Find number of Triplets 1 <= a <= b <= c <= n , Such that a ^ 2 + b ^ 2 = c ^ 2 ; function to ind number of Triplets 1 <= a <= b <= c <= n , Such that a ^ 2 + b ^ 2 = c ^ 2 ; to store required answer ; run nested loops for first two numbers . ; third number ; check if third number is perfect square and less than n ; Driver code ; function call","```java
public static int countTriplets(int n) {
    int count = 0;
    for (int a = 1; a <= n; a++) {
        for (int b = a; b <= n; b++) {
            int c = (int) Math.sqrt(a * a + b * b);
            if (c * c == a * a + b * b && c <= n) {
                count++;
            }
        }
    }
    return count;
}
```","```python
def count_triplets(n):
  count = 0
  for a in range(1, n + 1):
    for b in range(a, n + 1):
      c = (a ** 2 + b ** 2) ** 0.5
      if c.is_integer() and c <= n:
        count += 1
  return count
```"
267,Sum of the digits of a number N written in all bases from 2 to N \/ 2 | Java implementation of the approach ; Function to calculate the sum of the digits of n in the given base ; Sum of digits ; Digit of n in the given base ; Add the digit ; Function to calculate the sum of digits of n in bases from 2 to n \/ 2 ; to store digit sum in all bases ; function call for multiple bases ; Driver program,"```java
public static int sumOfDigitsInAllBases(int n) {
    int[] sum = new int[n / 2 - 1];
    for (int base = 2; base <= n / 2; base++) {
        sum[base - 2] = sumOfDigitsInBase(n, base);
    }
    return sum;
}

public static int sumOfDigitsInBase(int n, int base) {
    int sum = 0;
    while (n > 0) {
        int digit = n % base;
        sum += digit;
        n /= base;
    }
    return sum;
}
```","```python
def sum_of_digits_in_all_bases(n):
  result = [0] * (n // 2)
  for base in range(2, n // 2 + 1):
    digit_sum = 0
    num = n
    while num > 0:
      digit = num % base
      digit_sum += digit
      num //= base
    result[base - 2] = digit_sum
  return result
```"
268,Largest number in an array that is not a perfect cube | Java program to find the largest non - perfect cube number among n numbers ; Function to check if a number is perfect cube number or not ; takes the sqrt of the number ; checks if it is a perfect cube number ; Function to find the largest non perfect cube number in the array ; stores the maximum of all perfect cube numbers ; Traverse all elements in the array ; store the maximum if current element is a non perfect cube ; Driver Code,"```java
public static int findLargestNonPerfectCube(int[] arr) {
    int maxNonPerfectCube = Integer.MIN_VALUE;
    for (int i = 0; i < arr.length; i++) {
        if (!isPerfectCube(arr[i])) {
            maxNonPerfectCube = Math.max(maxNonPerfectCube, arr[i]);
        }
    }
    return maxNonPerfectCube;
}

public static boolean isPerfectCube(int num) {
    if (num < 0) {
        num = -num;
    }
    double cubeRoot = Math.cbrt(num);
    return Math.abs(cubeRoot - Math.round(cubeRoot)) < 1e-6;
}
```","```python
def find_largest_non_perfect_cube(arr):
  max_perfect_cube = -1
  largest_non_perfect_cube = -1
  for num in arr:
    if is_perfect_cube(num):
      max_perfect_cube = max(max_perfect_cube, num)
    else:
      largest_non_perfect_cube = max(largest_non_perfect_cube, num)
  return largest_non_perfect_cube

def is_perfect_cube(num):
  return round(num**(1/3))**3 == num
```"
269,"Check if N can be represented as sum of integers chosen from set { A , B } | Java program to find if number N can be represented as sum of a ' s ▁ and ▁ b ' s ; Function to find if number N can be represented as sum of a ' s ▁ and ▁ b ' s ; base condition ; if x is already visited ; set x as possible ; recursive call ; Driver program","```java
public static boolean isSumPossible(int a, int b, int n, int x, boolean[][] visited) {
    if (n == 0) {
        return true;
    }
    if (x < 0 || visited[x][n]) {
        return false;
    }
    visited[x][n] = true;
    return isSumPossible(a, b, n - a, x + 1, visited) || isSumPossible(a, b, n - b, x + 1, visited);
}
```","```python
def is_sum_possible(N, A, B, x, visited):
  if N == 0:
    return True
  if x == N:
    return True
  if x > N or visited[x]:
    return False
  visited[x] = True
  return is_sum_possible(N, A, B, x + A, visited) or is_sum_possible(N, A, B, x + B, visited)
```"
270,Sum of all odd natural numbers in range L and R | Java program to print the sum of all numbers in range L and R ; Function to return the sum of all odd natural numbers ; Function to return the sum of all odd numbers in range L and R ; Driver Code,"```java
public static int sumOddNumbersInRange(int L, int R) {
    int sum = 0;
    for (int i = L; i <= R; i++) {
        if (i % 2 != 0) {
            sum += i;
        }
    }
    return sum;
}
```","```python
def sum_odd_numbers(L, R):
  sum = 0
  for i in range(L, R + 1):
    if i % 2 != 0:
      sum += i
  return sum
```"
271,"Sum of common divisors of two numbers A and B | Java implementation of above approach ; Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Find the sum of divisors of n . ; if ' i ' is factor of n ; check if divisors are equal ; Driver program to run the case","```java
public static int sumOfCommonDivisors(int a, int b) {
    int gcd = gcd(a, b);
    int sum = 0;
    for (int i = 1; i <= gcd; i++) {
      if (gcd % i == 0) {
        sum += i;
      }
    }
    return sum;
  }
  
  public static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
```","```python
def sum_common_divisors(a, b):
  def gcd(a, b):
    while b:
      a, b = b, a % b
    return a
  def sum_divisors(n):
    sum = 0
    for i in range(1, n + 1):
      if n % i == 0:
        sum += i
    return sum
  gcd_ab = gcd(a, b)
  return sum_divisors(gcd_ab)
```"
272,"Check if a number is formed by Concatenation of 1 , 14 or 144 only | Java program to check if a number is formed by Concatenation of 1 , 14 or 144 only ; Function to check if a number is formed by Concatenation of 1 , 14 or 144 only ; check for each possible digit if given number consist other then 1 , 14 , 144 print NO else print YES ; Driver Code","```java
public static void checkNumber(int num) {
    String numStr = String.valueOf(num);
    for (int i = 0; i < numStr.length(); i++) {
      String digit = numStr.substring(i, i + 1);
      if (!digit.equals(""1"") && !digit.equals(""14"") && !digit.equals(""144"")) {
        System.out.println(""NO"");
        return;
      }
    }
    System.out.println(""YES"");
  }
```","```python
def check_number(n):
  while n > 0:
    if n % 10 == 1 or n % 100 == 14 or n % 1000 == 144:
      n //= 10
    else:
      return ""NO""
  return ""YES""
```"
273,Fibonacci problem ( Value of Fib ( N ) * Fib ( N ) | Java implementation of the approach ; Driver code,"```java
public static long fibSquare(int n) {
    if (n <= 1) {
      return n;
    }
    long[] dp = new long[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n] * dp[n];
  }
```","```python
def fib_squared(n):
  if n <= 1:
    return n
  else:
    return fib_squared(n-1) * fib_squared(n-1) + fib_squared(n-2) * fib_squared(n-2)
```"
274,Find two numbers with sum and product both same as N | Java program to find a and b such that a * b = N and a + b = N ; Function to return the smallest string ; Not possible ; find a and b ; Driver Code,"```java
public static String findNumbers(int N) {
    if (N < 2) {
        return ""Not possible"";
    }
    for (int a = 1; a <= N / 2; a++) {
        int b = N - a;
        if (a * b == N) {
            return a + "" "" + b;
        }
    }
    return ""Not possible"";
}
```","```python
def find_numbers(N):
  for a in range(1, N + 1):
    b = N - a
    if a * b == N:
      return a, b
  return ""Not possible""
```"
275,Find minimum operations needed to make an Array beautiful | Java implementation of above approach ; Function to find minimum operations required to make array beautiful ; counting consecutive zeros . ; check that start and end are same ; check is zero and one are equal ; Driver program,"```java
public static int minOperations(int[] arr) {
    int n = arr.length;
    int operations = 0;
    int consecutiveZeros = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] == 0) {
            consecutiveZeros++;
        } else {
            if (consecutiveZeros > 0) {
                operations += consecutiveZeros - 1;
                consecutiveZeros = 0;
            }
        }
    }
    if (consecutiveZeros > 0) {
        operations += consecutiveZeros - 1;
    }
    return operations;
}
```","```python
def minOperations(arr, n):
  count = 0
  start = 0
  end = n - 1
  while start <= end:
    if arr[start] == arr[end]:
      start += 1
      end -= 1
    else:
      if arr[start] == 0:
        start += 1
      else:
        end -= 1
      count += 1
  return count
```"
276,"Steps to reduce N to zero by subtracting its most significant digit at every step | Java program to find the count of Steps to reduce N to zero by subtracting its most significant digit at every step ; Function to count the number of digits in a number m ; Function to count the number of steps to reach 0 ; count the total number of stesp ; iterate till we reach 0 ; count the digits in last ; decrease it by 1 ; find the number on whose division , we get the first digit ; first digit in last ; find the first number less than last where the first digit changes ; find the number of numbers with same first digit that are jumped ; count the steps ; the next number with a different first digit ; Driver code","```java
public static int countStepsToReduceToZero(int n) {
    int steps = 0;
    while (n > 0) {
        int digits = countDigits(n);
        int firstDigit = (int) Math.pow(10, digits - 1);
        int nextNumber = n - firstDigit;
        steps += countNumbersWithSameFirstDigit(n, nextNumber) + 1;
        n = nextNumber;
    }
    return steps;
}

public static int countDigits(int m) {
    int count = 0;
    while (m > 0) {
        m /= 10;
        count++;
    }
    return count;
}

public static int countNumbersWithSameFirstDigit(int last, int next) {
    int digits = countDigits(last);
    int firstDigit = (int) Math.pow(10, digits - 1);
    return last / firstDigit - next / firstDigit;
}
```","```python
def count_digits(m):
  return len(str(m))

def count_steps_to_zero(N):
  steps = 0
  while N > 0:
    last = N
    digits = count_digits(last)
    N -= 10**(digits-1)
    steps += 1
  return steps

def main():
  N = int(input())
  total_steps = count_steps_to_zero(N)
  print(total_steps)

if __name__ == ""__main__"":
  main()
```"
277,"GCD of a number raised to some power and another number | Java program of the above approach ; Calculates modular exponentiation , i . e . , ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y \/ 2 ; Returns GCD of a ^ n and b ; Driver code","```java
public static int gcd(int a, int n, int b) {
    a = a % b;
    if (a >= b) {
      a = a % b;
    }
    if (n == 0) {
      return b;
    }
    if (n % 2 == 1) {
      return gcd(a * a, n / 2, b);
    }
    return gcd(a * a, n / 2, b);
  }
```","```python
def gcd(a, n, b):
  x = a % b
  if x >= b:
    x %= b
  result = 1
  while n > 0:
    if n % 2:
      result = (result * x) % b
    n >>= 1
    x = (x * x) % b
  return gcd(x, 1, b)
```"
278,Largest number not greater than N all the digits of which are odd | Java program to print the largest integer not greater than N with all odd digits ; Function to check if all digits of a number are odd ; iterate for all digits ; if digit is even ; all digits are odd ; function to return the largest number with all digits odd ; iterate till we find a number with all digits odd ; Driver Code,"```java
public static int largestOddDigitNumber(int n) {
    for (int i = n; i >= 0; i--) {
        if (allDigitsOdd(i)) {
            return i;
        }
    }
    return -1;
}

private static boolean allDigitsOdd(int num) {
    while (num > 0) {
        if ((num % 10) % 2 == 0) {
            return false;
        }
        num /= 10;
    }
    return true;
}
```","```python
def largest_odd_digits_number(N):
  def all_digits_odd(num):
    for digit in str(num):
      if int(digit) % 2 == 0:
        return False
    return True
  
  for i in range(N, 0, -1):
    if all_digits_odd(i):
      return i
```"
279,"Largest number not greater than N all the digits of which are odd | Java program to print the largest integer not greater than N with all odd digits ; function to return the largest number with all digits odd ; convert the number to a string for easy operations ; find first even digit ; if no even digit , then N is the answer ; till first even digit , add all odd numbers ; decrease 1 from the even digit ; add 9 in the rest of the digits ; Driver Code","```java
public static int largestOddDigitNumber(int N) {
    String str = String.valueOf(N);
    int i;
    for (i = 0; i < str.length(); i++) {
        if (Integer.parseInt(String.valueOf(str.charAt(i))) % 2 == 0) {
            break;
        }
    }
    if (i == str.length()) {
        return N;
    }
    StringBuilder sb = new StringBuilder();
    for (int j = 0; j < i; j++) {
        sb.append(9);
    }
    sb.append(Integer.parseInt(String.valueOf(str.charAt(i))) - 1);
    for (int j = i + 1; j < str.length(); j++) {
        sb.append(9);
    }
    return Integer.parseInt(sb.toString());
}
```","```python
def largest_odd_digits(N):
  s = str(N)
  for i in range(len(s)):
    if int(s[i]) % 2 == 0:
      return int("""".join([str(j) for j in range(9, -1, -2)][:i]) + str(int(s[i]) - 1) + ""9"" * (len(s) - i - 1))
  return N
```"
280,Count number less than N which are product of perfect squares | Java program to count number less than N which are product of any two perfect squares ; Function to count number less than N which are product of any two perfect squares ; Driver program,"```java
public static int countSquares(int n) {
    int count = 0;
    for (int i = 1; i * i <= n; i++) {
        for (int j = 1; j * j <= n; j++) {
            if (i * i * j * j <= n) {
                count++;
            }
        }
    }
    return count;
}
```","```python
def count_products_of_squares(N):
  count = 0
  for i in range(1, int(N**0.5) + 1):
    for j in range(i, int(N**0.5) + 1):
      if i * i * j * j < N:
        count += 1
  return count
```"
281,"Count ordered pairs with product less than N | Java implementation of above approach ; Function to return count of Ordered pairs whose product are less than N ; Initialize count to 0 ; count total pairs ; multiply by 2 to get ordered_pairs ; subtract redundant pairs ( a , b ) where a == b . ; return answer ; Driver code ; function call to print required answer","```java
public static int countOrderedPairs(int N) {
    int count = 0;
    for (int i = 1; i <= N; i++) {
        count += N / i;
    }
    return 2 * count - N;
}
```","```python
def count_ordered_pairs(N):
  count = 0
  for a in range(1, N + 1):
    for b in range(1, N + 1):
      if a * b < N:
        count += 1
  return count * 2 - N
```"
282,Absolute Difference of all pairwise consecutive elements in an array | Java program to print the absolute difference of the consecutive elements ; Function to print pairwise absolute difference of consecutive elements ; absolute difference between consecutive numbers ; Driver Code,"```java
public static void printPairwiseAbsoluteDifference(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        System.out.print(Math.abs(arr[i] - arr[i + 1]) + "" "");
    }
}
```","```python
def print_absolute_differences(arr):
  for i in range(len(arr) - 1):
    print(abs(arr[i] - arr[i + 1]))
```"
283,"Find the sum of all multiples of 2 and 5 below N | Java program to find the sum of all multiples of 2 and 5 below N ; Function to find sum of AP series ; Number of terms ; Function to find the sum of all multiples of 2 and 5 below N ; Since , we need the sum of multiples less than N ; Driver code","```java
public static int sumMultiples(int N) {
  int sum = 0;
  for (int i = 1; i < N; i++) {
    if (i % 2 == 0 || i % 5 == 0) {
      sum += i;
    }
  }
  return sum;
}
```","```python
def sum_multiples_of_2_and_5(N):
  sum = 0
  for i in range(1, N):
    if i % 2 == 0 and i % 5 == 0:
      sum += i
  return sum
```"
284,Find the total marks obtained according to given marking scheme | Function that calculates marks . ; for not attempt score + 0 ; for each correct answer score + 3 ; for each wrong answer score - 1 ; calculate total marks ; Driver code,"```java
public static int calculateMarks(int[] answers, int[] correctAnswers) {
    int score = 0;
    for (int i = 0; i < answers.length; i++) {
      if (answers[i] == 0) {
        score += 0;
      } else if (answers[i] == correctAnswers[i]) {
        score += 3;
      } else {
        score -= 1;
      }
    }
    return score;
  }
```","```python
def calculate_marks(attempts, answers):
  total_marks = 0
  for i in range(len(attempts)):
    if attempts[i] == 'N':
      total_marks += 0
    elif attempts[i] == answers[i]:
      total_marks += 3
    else:
      total_marks -= 1
  return total_marks
```"
285,"Find the Product of first N Prime Numbers | Java implementation of above solution ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; find the product of 1 st N prime numbers ; count of prime numbers ; product of prime numbers ; if the number is prime add it ; increase the count ; get to next number ; Driver code ; create the sieve ; find the value of 1 st n prime numbers","```java
public static long findProductOfFirstNPrimes(int n) {
    boolean[] prime = new boolean[n + 1];
    Arrays.fill(prime, true);
    int count = 0;
    long product = 1;
    for (int p = 2; count < n; p++) {
      if (prime[p]) {
        product *= p;
        count++;
        for (int i = p * p; i <= n; i += p) {
          prime[i] = false;
        }
      }
    }
    return product;
  }
```","```python
def find_product_of_first_n_primes(n):
  prime = [True] * (n + 1)
  count = 0
  product = 1
  for p in range(2, n + 1):
    if prime[p]:
      product *= p
      count += 1
      for i in range(p * p, n + 1, p):
        prime[i] = False
  return count, product
```"
286,"Program to find count of numbers having odd number of divisors in given range | Java implementation of the approach ; Function to return the count of divisors of a number ; Count the powers of the current prime i which divides a ; Update the count of divisors ; Reset the count ; If the remaining a is prime then a ^ 1 will be one of its prime factors ; Function to count numbers having odd number of divisors in range [ A , B ] ; To store the count of elements having odd number of divisors ; Iterate from a to b and find the count of their divisors ; To store the count of divisors of i ; If the divisor count of i is odd ; Driver code","```java
public static int countDivisors(int a) {
    int count = 0;
    for (int i = 1; i * i <= a; i++) {
      if (a % i == 0) {
        if (i * i == a) {
          count++;
        } else {
          count += 2;
        }
      }
    }
    return count;
  }
  public static int countNumbersWithOddDivisors(int a, int b) {
    int count = 0;
    for (int i = a; i <= b; i++) {
      if (countDivisors(i) % 2 != 0) {
        count++;
      }
    }
    return count;
  }
```","```python
def countDivisors(n):
  count = 0
  for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
      if i * i == n:
        count += 1
      else:
        count += 2
  return count

def countOddDivisors(a, b):
  count = 0
  for i in range(a, b + 1):
    if countDivisors(i) % 2 != 0:
      count += 1
  return count
```"
287,Check if there is any pair in a given range with GCD is divisible by k | Java program to count the numbers divisible by k in a given range ; Returns count of numbers in [ l r ] that are divisible by k . ; Add 1 explicitly as l is divisible by k ; l is not divisible by k ; Driver Code,"```java
public static int countDivisible(int l, int r, int k) {
    int count = 0;
    if (l % k == 0) {
      count++;
    }
    count += (r / k) - (l / k);
    return count;
  }
```","```python
def countDivisibles(l, r, k):
  count = 0
  if l % k == 0:
    count += 1
  count += (r // k) - (l // k)
  return count
```"
288,Find sum of N | Java program to find sum in Nth group ; calculate sum of Nth group ; Driver code,"```java
public static int sumNthGroup(int[] arr, int n) {
    int sum = 0;
    int groupSize = arr.length / n;
    int start = (n - 1) * groupSize;
    int end = Math.min(start + groupSize, arr.length);
    for (int i = start; i < end; i++) {
      sum += arr[i];
    }
    return sum;
  }
```","```python
def sum_of_nth_group(n, arr):
  sum = 0
  for i in range(n-1, len(arr), n):
    sum += arr[i]
  return sum
```"
289,Find if a molecule can be formed from 3 atoms using their valence numbers | Java implementation of the above approach ; Function to check if it is possible ; Driver code,"```java
public static boolean canFormMolecule(int[] valence) {
    int totalValence = 0;
    for (int i = 0; i < valence.length; i++) {
        totalValence += valence[i];
    }
    return totalValence == 8;
}
```","```python
def can_form_molecule(valence1, valence2, valence3):
  return (valence1 + valence2 >= valence3) or (valence1 + valence3 >= valence2) or (valence2 + valence3 >= valence1)
```"
290,Check if a number is a Trojan Number | Java program to check if a number is Trojan Number or not ; Function to check if a number can be expressed as x ^ y ; Try all numbers from 2 to sqrt ( n ) as base ; Keep increasing y while power ' p ' is smaller than n . ; Function to check if a number is Strong ; count the number for each prime factor ; minimum number of prime divisors should be 2 ; Function to check if a number is Trojan Number ; Driver Code,"```java
public static boolean isTrojanNumber(int n) {
    if (isStrong(n) && isPowerOf(n)) {
        return true;
    }
    return false;
}

public static boolean isPowerOf(int n) {
    for (int x = 2; x <= Math.sqrt(n); x++) {
        int y = 1;
        int p = x;
        while (p <= n) {
            if (p == n) {
                return true;
            }
            y++;
            p = (int) Math.pow(x, y);
        }
    }
    return false;
}

public static boolean isStrong(int n) {
    int count = 0;
    for (int i = 2; i <= n; i++) {
        if (n % i == 0) {
            count = 0;
            while (n % i == 0) {
                count++;
                n /= i;
            }
            if (count > 0) {
                break;
            }
        }
    }
    return count >= 2;
}
```","```python
import math

def is_trojan_number(n):
    if is_strong(n) and is_power(n):
        return True
    return False

def is_strong(n):
    count = 0
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            count += 1
            while n % i == 0:
                n //= i
    if n > 1:
        count += 1
    return count >= 2

def is_power(n):
    for x in range(2, int(math.sqrt(n)) + 1):
        y = 1
        p = x ** y
        while p <= n:
            if p == n:
                return True
            y += 1
            p = x ** y
    return False
```"
291,Find the sum of first N terms of the series 2 Ã — 3 + 4 Ã — 4 + 6 Ã — 5 + 8 Ã — 6 + ... | Java program to find sum upto N term of the series : ; calculate sum upto N term of series ; Driver code,"```java
public static double seriesSum(int n) {
    double sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += (2 * i) * (3 + (2 * i - 2));
    }
    return sum;
}
```","```python
def sum_of_series(N):
  sum = 0
  for i in range(1, N + 1):
    sum += (2 * i) * (i + 1) - (2 * i + 2)
  return sum
```"
292,"Absolute Difference between the Sum of Non | Java program to find the Absolute Difference between the Sum of Non - Prime numbers and Prime numbers of an Array ; Function to find the difference between the sum of non - primes and the sum of primes of an array . ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store the sum of primes in S1 and the sum of non primes in S2 ; the number is prime ; the number is non - prime ; Return the absolute difference ; Driver Code ; Get the array ; Find the absolute difference","```java
public static int findAbsoluteDifference(int[] arr) {
  int max_val = Integer.MIN_VALUE;
  for (int i = 0; i < arr.length; i++) {
    if (arr[i] > max_val) {
      max_val = arr[i];
    }
  }
  boolean[] prime = new boolean[max_val + 1];
  Arrays.fill(prime, true);
  prime[0] = prime[1] = false;
  for (int p = 2; p * p <= max_val; p++) {
    if (prime[p]) {
      for (int i = p * p; i <= max_val; i += p) {
        prime[i] = false;
      }
    }
  }
  int S1 = 0;
  int S2 = 0;
  for (int i = 0; i < arr.length; i++) {
    if (prime[arr[i]]) {
      S1 += arr[i];
    } else {
      S2 += arr[i];
    }
  }
  return Math.abs(S1 - S2);
}
```","```python
def absolute_difference(arr):
  max_val = max(arr)
  prime = [True] * (max_val + 1)
  prime[0] = prime[1] = False
  for p in range(2, int(max_val**0.5) + 1):
    if prime[p]:
      for i in range(p * p, max_val + 1, p):
        prime[i] = False
  S1 = 0
  S2 = 0
  for num in arr:
    if prime[num]:
      S1 += num
    else:
      S2 += num
  return abs(S1 - S2)
```"
293,Program to find sum of 1 + x \/ 2 ! + x ^ 2 \/ 3 ! + ... + x ^ n \/ ( n + 1 ) ! | Java implementation of the approach ; Function to compute the series sum ; To store the value of S [ i - 1 ] ; Iterate over n to store sum in total ; Update previous with S [ i ] ; Driver code ; Get x and n ; Find and print the sum,"```java
public static double seriesSum(int x, int n) {
    double total = 1;
    double previous = 1;
    for (int i = 1; i <= n; i++) {
      previous *= x;
      previous /= (i + 1);
      total += previous;
    }
    return total;
  }
```","```python
def series_sum(x, n):
  total = 1
  previous = 1
  for i in range(1, n + 1):
    previous = previous * x / i
    total += previous
  return total
```"
294,Count number of integers less than or equal to N which has exactly 9 divisors | Java implementation of above approach ; Function to count factors in O ( N ) ; iterate and check if factor or not ; Function to count numbers having exactly 9 divisors ; check for all numbers <= N ; check if exactly 9 factors or not ; Driver Code,"```java
public static int countNumbers(int n) {
    int count = 0;
    for (int i = 1; i <= n; i++) {
        if (countFactors(i) == 9) {
            count++;
        }
    }
    return count;
}

public static int countFactors(int n) {
    int count = 0;
    for (int i = 1; i <= n; i++) {
        if (n % i == 0) {
            count++;
        }
    }
    return count;
}
```","```python
def countNumbers(N):
  count = 0
  for i in range(1, N + 1):
    if countFactors(i) == 9:
      count += 1
  return count

def countFactors(n):
  count = 0
  for i in range(1, n + 1):
    if n % i == 0:
      count += 1
  return count
```"
295,"Number of distinct integers obtained by lcm ( X , N ) \/ X | Java program to find distinct integers ontained by lcm ( x , num ) \/ x ; Function to count the number of distinct integers ontained by lcm ( x , num ) \/ x ; iterate to count the number of factors ; Driver Code","```java
public static int countDistinctIntegers(int num) {
    int count = 0;
    for (int x = 1; x <= num; x++) {
      if (lcm(x, num) / x != 1) {
        count++;
      }
    }
    return count;
  }

  private static int lcm(int a, int b) {
    return (a * b) / gcd(a, b);
  }

  private static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }
```","```python
def count_distinct_lcm(num):
  count = 0
  for x in range(1, num + 1):
    lcm = (x * num) //  (math.gcd(x, num))
    if lcm not in seen:
      seen.add(lcm)
      count += 1
  return count
```"
296,Ulam Number Sequence | JAVA code to print nth Ulam number ; Array to store Ulam Number ; Function to compute ulam Number ; push First 2 two term of the sequence in the array for further calculation ; loop to generate Ulam number ; traverse the array and check if i can be represented as sum of two distinct element of the array ; If count is 2 that means i can be represented as sum of two distinct terms of the sequence ; i is ulam number ; Driver code ; pre compute Ulam Number sequence ; print nth Ulam number,"```java
public static int ulamNumber(int n) {
    int[] ulam = new int[n + 1];
    ulam[0] = 1;
    ulam[1] = 2;
    int count = 2;
    for (int i = 3; count < n; i++) {
        int sumCount = 0;
        for (int j = 0; j < count; j++) {
            for (int k = j + 1; k < count; k++) {
                if (ulam[j] + ulam[k] == i) {
                    sumCount++;
                }
            }
        }
        if (sumCount == 2) {
            ulam[count++] = i;
        }
    }
    return ulam[n - 1];
}
```","```python
def ulam_number(n):
  ulam = [1, 2]
  i = 3
  while len(ulam) < n:
    count = 0
    for j in range(len(ulam)):
      for k in range(j + 1, len(ulam)):
        if ulam[j] + ulam[k] == i:
          count += 1
    if count == 2:
      ulam.append(i)
    i += 1
  return ulam[-1]
```"
297,Find the number of rectangles of size 2 * 1 which can be placed inside a rectangle of size n * m | Java program to Find the number of rectangles of size 2 * 1 can be placed inside a rectangle of size n * m ; function to Find the number of rectangles of size 2 * 1 can be placed inside a rectangle of size n * m ; if n is even ; if m is even ; if both are odd ; Driver code ; function call,"```java
public static int countRectangles(int n, int m) {
    if (n % 2 == 0) {
        if (m % 2 == 0) {
            return (n / 2) * (m / 2);
        } else {
            return (n / 2) * ((m + 1) / 2);
        }
    } else {
        if (m % 2 == 0) {
            return ((n + 1) / 2) * (m / 2);
        } else {
            return ((n + 1) / 2) * ((m + 1) / 2);
        }
    }
}
```","```python
def count_rectangles(n, m):
  if n % 2 == 0:
    if m % 2 == 0:
      return (n // 2) * (m // 2)
    else:
      return ((n // 2) * (m - 1))
  else:
    if m % 2 == 0:
      return ((n - 1) * (m // 2))
    else:
      return ((n - 1) * (m - 1)) // 2
```"
298,"Next greater Number than N with the same quantity of digits A and B | Java program to find next greater Number than N with the same quantity of digits A and B ; Recursive function to find the required number ; If the resulting number is >= n and count of a = count of b , return the number ; select minimum of two and call the function again ; Function to find the number next greater Number than N with the same quantity of digits A and B ; Driver code","```java
public static int nextGreaterNumber(int n, int a, int b, int countA, int countB) {
    if (n >= 10 && countA == countB) {
        return n;
    }
    int nextNumber = Math.min(n + a, n + b);
    return nextGreaterNumber(nextNumber, a, b, countA + (nextNumber == n + a ? 1 : 0), countB + (nextNumber == n + b ? 1 : 0));
}

public static int findNextGreaterNumber(int n, int a, int b) {
    return nextGreaterNumber(n, a, b, 0, 0);
}

public static void main(String[] args) {
    int n = 123;
    int a = 2;
    int b = 3;
    int result = findNextGreaterNumber(n, a, b);
    System.out.println(""Next greater number: "" + result);
}
```","```python
def findNextGreaterNumber(n, a, b):
    def helper(num, countA, countB):
        if num >= n and countA == countB:
            return num
        else:
            return min(helper(num * 10 + a, countA + 1, countB), helper(num * 10 + b, countA, countB + 1))
    return helper(0, 0, 0)

def findNextGreaterNumberWithSameQuantity(n, a, b):
    return findNextGreaterNumber(n, a, b)

n = int(input())
a = int(input())
b = int(input())
print(findNextGreaterNumberWithSameQuantity(n, a, b))
```"
299,Minimum and maximum number of N chocolates after distribution among K students | Java implementation of the above approach ; Driver code,"```java
public static int[] minMaxChocolates(int N, int K) {
    int[] result = new int[2];
    result[0] = (N % K == 0) ? N / K : (N / K) + 1;
    result[1] = N / K;
    return result;
}
```","```python
def min_max_chocolates(N, K):
  if N < K:
    return 0, 0
  min_chocolates = N // K
  max_chocolates = N - (K - 1)
  return min_chocolates, max_chocolates
```"
300,Total money to be paid after traveling the given number of hours | Java implementation of the above approach ; calculating hours travelled,"```java
public static double calculateTotalCost(double baseFare, double hourlyRate, int hoursTraveled) {
    return baseFare + hourlyRate * hoursTraveled;
  }
```","```python
def calculate_money(hours_traveled, base_fare, fare_per_hour):
  return base_fare + hours_traveled * fare_per_hour
```"
301,Absolute difference between sum and product of roots of a quartic equation | Java implementation of above approach ; Function taking coefficient of each term of equation as input ; Finding sum of roots ; Finding product of roots ; Absolute difference ; Driver Code,"```java
public static double absoluteDifference(double a, double b, double c, double d, double e) {
    double sum = -b / a;
    double product = e / a;
    return Math.abs(sum - product);
}
```","```python
def absolute_difference(a, b, c, d, e):
  sum_of_roots = -b / a
  product_of_roots = e / a
  return abs(sum_of_roots - product_of_roots)
```"
302,Number of solutions of n = x + n âŠ • x | Java implementation of above approach ; Function to find the number of solutions of n = n xor x ; Counter to store the number of solutions found ; Driver code,"```java
public static int countSolutions(int n) {
    int count = 0;
    for (int x = 0; x <= n; x++) {
        if (n == x + (n ^ x)) {
            count++;
        }
    }
    return count;
}
```","```python
def count_solutions(n):
  count = 0
  for x in range(n + 1):
    if n == x + n ^ x:
      count += 1
  return count
```"
303,Program to find minimum number of lectures to attend to maintain 75 % | Java Program to find minimum number of lectures to attend to maintain 75 % attendance ; Method to compute minimum lecture ; Formula to compute ; Driver Code,"```java
public static int minLectures(int totalLectures, int attendedLectures) {
    int requiredLectures = (int) Math.ceil(0.75 * totalLectures);
    return Math.max(0, requiredLectures - attendedLectures);
}
```","```python
def min_lectures(total_lectures, attended_lectures):
  required_attendance = 0.75 * total_lectures
  return max(0, int(required_attendance - attended_lectures))
```"
304,Count Numbers with N digits which consists of odd number of 0 's | Java program to count numbers with N digits which consists of odd number of 0 's ; Function to count Numbers with N digits which consists of odd number of 0 's ; Driver code,"```java
public static int countNumbersWithOddZeroes(int n) {
    if (n == 1) {
        return 9;
    }
    int[][] dp = new int[n + 1][2];
    dp[1][0] = 9;
    dp[1][1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i][0] = 9 * dp[i - 1][0] + 9 * dp[i - 1][1];
        dp[i][1] = dp[i - 1][0];
    }
    return dp[n][0] + dp[n][1];
}
```","```python
def countNumbers(n):
  dp = [[0 for _ in range(2)] for _ in range(n + 1)]
  dp[0][0] = 1
  dp[1][0] = 9
  dp[1][1] = 1
  for i in range(2, n + 1):
    dp[i][0] = 9 * dp[i - 1][0] + 9 * dp[i - 1][1]
    dp[i][1] = dp[i - 1][0]
  return dp[n][0] + dp[n][1]
```"
305,"Sum of all Primes in a given range using Sieve of Eratosthenes | Java program to find sum of primes in range L to R ; prefix [ i ] is going to store sum of primes till i ( including i ) . ; Function to build the prefix sum array ; Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Build prefix array ; Function to return sum of prime in range ; Driver code","```java
public static int sumOfPrimesInRange(int L, int R) {
    int n = R;
    boolean[] prime = new boolean[n + 1];
    Arrays.fill(prime, true);
    int[] prefix = new int[n + 1];
    buildPrefixArray(prime, prefix, n);
    return prefix[R] - prefix[L - 1];
}

private static void buildPrefixArray(boolean[] prime, int[] prefix, int n) {
    for (int p = 2; p * p <= n; p++) {
        if (prime[p]) {
            for (int i = p * p; i <= n; i += p) {
                prime[i] = false;
            }
        }
    }
    prefix[0] = 0;
    for (int i = 1; i <= n; i++) {
        if (prime[i]) {
            prefix[i] = prefix[i - 1] + i;
        } else {
            prefix[i] = prefix[i - 1];
        }
    }
}
```","```python
def sum_of_primes_in_range(L, R):
  n = R
  prime = [True] * (n + 1)
  p = 2
  while (p * p <= n):
    if (prime[p] == True):
      for i in range(p * p, n + 1, p):
        prime[i] = False
    p += 1
  prefix = [0] * (n + 1)
  for i in range(2, n + 1):
    if (prime[i]):
      prefix[i] = prefix[i - 1] + i
    else:
      prefix[i] = prefix[i - 1]
  return prefix[R] - prefix[L - 1]
```"
306,"Sum of the first N terms of the series 5 , 12 , 23 , 38. ... | Java program to find sum of first n terms ; Function to calculate the sum ; Driver code ; number of terms to be included in sum ; find the Sn","```java
public static int sumSeries(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
      sum += 5 + (i - 1) * 7;
    }
    return sum;
  }
```","```python
def find_Sn(n):
  sum = 0
  for i in range(1, n + 1):
    sum += 5 + (i - 1) * 7 + (i - 1) * (i - 2)
  return sum
```"
307,"Program to find number of solutions in Quadratic Equation | Java Program to find the solutions of specified equations ; Method to check for solutions of equations ; If the expression is greater than 0 , then 2 solutions ; If the expression is equal 0 , then 2 solutions ; Else no solutions ; Driver Code","```java
public static int checkSolutions(double a, double b, double c) {
    double discriminant = b * b - 4 * a * c;
    if (discriminant > 0 || discriminant == 0) {
      return 2;
    } else {
      return 0;
    }
  }
```","```python
import cmath

def find_solutions(a, b, c):
  delta = (b**2) - 4*(a*c)
  if delta > 0 or delta == 0:
    return 2
  else:
    return 0
```"
308,Program to convert KiloBytes to Bytes and Bits | Java implementation of above program ; Function to calculates the bits ; calculates Bits 1 kilobytes ( s ) = 8192 bits ; Function to calculates the bytes ; calculates Bytes 1 KB = 1024 bytes ; Driver code,"```java
public static long calculateBits(long kiloBytes) {
    return kiloBytes * 8192;
}

public static long calculateBytes(long kiloBytes) {
    return kiloBytes * 1024;
}
```","```python
def convert_kb_to_bits(kb):
  return kb * 1024 * 8

def convert_kb_to_bytes(kb):
  return kb * 1024
```"
309,"Program to find the Hidden Number | Java Program to find the hidden number ; Driver Code ; Getting the size of array ; Getting the array of size n ; Solution ; Finding sum of the array elements ; Dividing sum by size n ; Print x , if found","```java
import java.util.Scanner;

public class HiddenNumber {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the size of the array: "");
        int n = scanner.nextInt();
        int[] arr = new int[n];
        System.out.println(""Enter the elements of the array: "");
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += arr[i];
        }
        int x = sum / n;
        System.out.println(""The hidden number is: "" + x);
    }
}
```","```python
def find_hidden_number(n, arr):
  sum = 0
  for i in range(n):
    sum += arr[i]
  x = sum / n
  print(x)
```"
310,Find sum of the series ? 3 + ? 12 + ... ... ... upto N terms | Java implementation of above approach ; Function to find the sum ; Apply AP formula ; Driver code ; number of terms,"```java
public static double sumSeries(int n) {
  return (n * (3 + (n - 1) * 9)) / 2;
}
```","```python
def sum_of_series(n):
  return (n * (3 + (n - 1) * 9)) // 2
```"
311,Find the sum of the series x ( x + y ) + x ^ 2 ( x ^ 2 + y ^ 2 ) + x ^ 3 ( x ^ 3 + y ^ 3 ) + ... + x ^ n ( x ^ n + y ^ n ) | Java program to find the sum of series ; Function to return required sum ; sum of first series ; sum of second series ; Driver code ; function call to print sum,"```java
public static double seriesSum(int x, int y, int n) {
    double sum1 = 0;
    double sum2 = 0;
    for (int i = 1; i <= n; i++) {
      sum1 += Math.pow(x, i);
      sum2 += Math.pow(x, i) * Math.pow(y, i);
    }
    return sum1 * sum2;
  }
```","```python
def sum_series(x, y, n):
  sum1 = 0
  sum2 = 0
  for i in range(1, n + 1):
    sum1 += x ** i
    sum2 += (x ** i) * (x ** i + y ** i)
  return sum1 + sum2
```"
312,Find any pair with given GCD and LCM | Java program to print any pair with a given gcd G and lcm L ; Function to print the pairs ; Driver Code,"```java
public static void printPairs(int G, int L) {
    if (L % G != 0) {
        System.out.println(""Invalid Input"");
        return;
    }
    for (int a = G; a <= L; a++) {
        if (L % a == 0 && GCD(a, L / a) == G) {
            System.out.println(a + "" "" + L / a);
            return;
        }
    }
}

public static int GCD(int a, int b) {
    if (b == 0) {
        return a;
    }
    return GCD(b, a % b);
}
```","```python
def print_pairs(G, L):
  for i in range(1, L + 1):
    if (G * i) % L == 0:
      a = G * i
      b = L
      print(f""({a}, {b})"")
```"
313,"Sum of first n terms of a given series 3 , 6 , 11 , ... . . | Java program to find sum of first n terms ; Function to calculate the sum ; starting number ; Common Ratio ; Common difference ; Driver code ; N th term to be find ; find the Sn","```java
public static int sumOfSeries(int n) {
    int sum = 0;
    int start = 3;
    int commonRatio = 3;
    int commonDifference = 2;
    for (int i = 1; i <= n; i++) {
      sum += start + (i - 1) * commonRatio + (i - 1) * (i - 2) / 2 * commonDifference;
    }
    return sum;
  }
```","```python
def sum_of_series(n):
  a = 3
  r = 3
  d = 2
  Sn = (n / 2) * (2 * a + (n - 1) * d)
  return Sn
```"
314,Maximum of sum and product of digits until number is reduced to a single digit | Java implementation of above approach ; Function to sum the digits until it becomes a single digit ; Function to product the digits until it becomes a single digit ; Loop to do sum while sum is not less than or equal to 9 ; Function to find the maximum among repeated sum and repeated product ; Driver code,"```java
public static int maxSumProduct(int n) {
    int sum = sumDigits(n);
    int product = productDigits(n);
    return Math.max(sum, product);
}

public static int sumDigits(int n) {
    while (n > 9) {
        int sum = 0;
        while (n > 0) {
            sum += n % 10;
            n /= 10;
        }
        n = sum;
    }
    return n;
}

public static int productDigits(int n) {
    while (n > 9) {
        int product = 1;
        while (n > 0) {
            product *= n % 10;
            n /= 10;
        }
        n = product;
    }
    return n;
}
```","```python
def sumDigits(n):
  while n > 9:
    sum = 0
    while n > 0:
      sum += n % 10
      n //= 10
    n = sum
  return n

def productDigits(n):
  while n > 9:
    product = 1
    while n > 0:
      product *= n % 10
      n //= 10
    n = product
  return n

def maxSumProduct(n):
  return max(sumDigits(n), productDigits(n))
```"
315,Find maximum possible value of advertising | Java program for the above approach ; Function to find maximum possible advertising value ; To store advertising value at i - th minute ; Base Case ; If no advertisement is taken on ith minute ; If advertisement is taken on i - th minute ; Driver code ; array [ ] [ 0 ] start time array [ ] [ 1 ] advertising value,"```java
public static int maxAdvertising(int[][] array, int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0;
    for (int i = 1; i <= n; i++) {
        dp[i] = dp[i - 1];
        for (int j = 0; j < array.length; j++) {
            if (array[j][0] == i) {
                dp[i] = Math.max(dp[i], dp[i - 1] + array[j][1]);
            }
        }
    }
    return dp[n];
}
```","```python
def find_max_advertising(array):
  n = len(array)
  dp = [0] * (n + 1)
  for i in range(1, n + 1):
    dp[i] = dp[i - 1]
    if i >= array[i - 1][0]:
      dp[i] = max(dp[i], dp[i - array[i - 1][0]] + array[i - 1][1])
  return dp[n]
```"
316,"Count numbers with exactly K non | Java program to count the numbers having exactly K non - zero digits and sum of digits are odd and distinct . ; To store digits of N ; visited map ; DP Table ; Push all the digits of N into digits vector ; Function returns the count ; If desired number is formed whose sum is odd ; If it is not present in map , mark it as true and return 1 ; Sum is present in map already ; Desired result not found ; If that state is already calculated just return that state value ; Upper limit ; To store the count of desired numbers ; If k is non - zero , i ranges from 0 to j else [ 1 , j ] ; If current digit is 0 , decrement k and recurse sum is not changed as we are just adding 0 that makes no difference ; If i is non zero , then k remains unchanged and value is added to sum ; Memoize and return ; Driver code ; K is the number of exact non - zero elements to have in number ; break N into its digits ; We keep record of 0 s we need to place in the number","```java
public int countNumbers(int N, int K) {
    List<Integer> digits = new ArrayList<>();
    Map<String, Boolean> visited = new HashMap<>();
    int[][] dp = new int[10][10];
    for (int i = 0; i < 10; i++) {
        Arrays.fill(dp[i], -1);
    }
    while (N > 0) {
        digits.add(N % 10);
        N /= 10;
    }
    return helper(digits, K, 0, 0, visited, dp);
}

private int helper(List<Integer> digits, int K, int i, int sum, Map<String, Boolean> visited, int[][] dp) {
    if (i == digits.size()) {
        if (sum % 2 != 0) {
            String key = K + ""_"" + sum;
            if (!visited.containsKey(key)) {
                visited.put(key, true);
                return 1;
            }
        }
        return 0;
    }
    if (dp[K][sum] != -1) {
        return dp[K][sum];
    }
    int j = digits.size() - 1;
    int count = 0;
    if (K != 0) {
        for (int k = 0; k <= j; k++) {
            if (digits.get(k) == 0) {
                count += helper(digits, K - 1, i + 1, sum, visited, dp);
            } else {
                count += helper(digits, K, i + 1, sum + digits.get(k), visited, dp);
            }
        }
    } else {
        for (int k = 1; k <= j; k++) {
            count += helper(digits, K, i + 1, sum + digits.get(k), visited, dp);
        }
    }
    dp[K][sum] = count;
    return count;
}
```","```python
def countNumbers(N, K):
  digits = []
  visited = {}
  dp = {}
  for i in str(N):
    digits.append(int(i))
  def recurse(index, k, sum, used):
    if index == len(digits):
      if k == 0 and sum % 2 != 0:
        if used not in visited:
          visited[used] = True
          return 1
        return 0
      return 0
    if (index, k, sum, used) in dp:
      return dp[(index, k, sum, used)]
    count = 0
    if digits[index] == 0:
      count += recurse(index + 1, k - 1, sum, used)
    else:
      count += recurse(index + 1, k, sum + digits[index], used | (1 << digits[index]))
      count += recurse(index + 1, k, sum, used)
    dp[(index, k, sum, used)] = count
    return count
  return recurse(0, K, 0, 0)
```"
317,Count of subsets of integers from 1 to N having no adjacent elements | Java code to count subsets not containing adjacent elements from 1 to N ; Function to count subsets ; Driver code,"```java
public static int countSubsets(int n) {
    if (n <= 1) {
        return 1 << n;
    }
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 2;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```","```python
def count_subsets(n):
  dp = [0] * (n + 1)
  dp[0] = 1
  dp[1] = 2
  for i in range(2, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]
  return dp[n]
```"
318,Count the number of ordered sets not containing consecutive numbers | Java program to count the number of ordered sets not containing consecutive numbers ; DP table ; Function to calculate the count of ordered set for a given size ; Base cases ; If subproblem has been soved before ; Store and return answer to this subproblem ; Function returns the count of all ordered sets ; Prestore the factorial value ; Initialise the dp table ; Iterate all ordered set sizes and find the count for each one maximum ordered set size will be smaller than N as all elements are distinct and non consecutive . ; Multiply ny size ! for all the arrangements because sets are ordered . ; Add to total answer ; Driver code,"```java
public static long countOrderedSets(int n) {
    long[] fact = new long[n + 1];
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = fact[i - 1] * i;
    }
    long[][] dp = new long[n + 1][n + 1];
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            dp[i][j] = -1;
        }
    }
    long total = 0;
    for (int i = 1; i <= n; i++) {
        total += countOrderedSetsUtil(i, n, dp) * fact[i];
    }
    return total;
}

private static long countOrderedSetsUtil(int size, int n, long[][] dp) {
    if (size == 0) {
        return 1;
    }
    if (size == 1) {
        return n;
    }
    if (dp[size][n] != -1) {
        return dp[size][n];
    }
    long ans = 0;
    for (int i = 1; i <= n; i++) {
        ans += countOrderedSetsUtil(size - 1, i - 1, dp);
    }
    dp[size][n] = ans;
    return ans;
}
```","```python
def count_ordered_sets(N):
    fact = [1] * (N + 1)
    for i in range(2, N + 1):
        fact[i] = fact[i - 1] * i
    dp = [[-1] * (N + 1) for _ in range(N + 1)]
    ans = 0
    for size in range(1, N + 1):
        dp[0][size] = 1
        for i in range(1, size + 1):
            if dp[i][size] == -1:
                dp[i][size] = dp[i - 1][size - 1] + dp[i][size - 1]
        ans += dp[size][size] * fact[size]
    return ans
```"
319,Count the Arithmetic sequences in the Array of size at least 3 | Java program to find all arithmetic sequences of size atleast 3 ; Function to find all arithmetic sequences of size atleast 3 ; If array size is less than 3 ; Finding arithmetic subarray length ; To store all arithmetic subarray of length at least 3 ; Check if current element makes arithmetic sequence with previous two elements ; Begin with a new element for new arithmetic sequences ; Accumulate result in till i . ; Return final count ; Driver code ; Function to find arithmetic sequences,"```java
public static int countArithmeticSequences(int[] arr) {
    if (arr.length < 3) {
      return 0;
    }
    int count = 0;
    for (int i = 2; i < arr.length; i++) {
      int diff = arr[i] - arr[i - 1];
      if (arr[i - 1] - arr[i - 2] == diff) {
        count++;
      }
    }
    return count;
  }
```","```python
def countArithmeticSequences(arr):
  n = len(arr)
  if n < 3:
    return 0
  count = 0
  for i in range(2, n):
    if arr[i] - arr[i - 1] == arr[i - 1] - arr[i - 2]:
      count += 1
    else:
      count += i - 2
  return count + (n - 2)
```"
320,"Count triplet of indices ( i , j , k ) such that XOR of elements between [ i , j ) equals [ j , k ] | Java program to count the Number of triplets in array having subarray XOR equal ; Function return the count of triplets having subarray XOR equal ; XOR value till i ; Count and ways array as defined above ; Using the formula stated ; Increase the frequency of x ; Add i + 1 to ways [ x ] for upcoming indices ; Driver code","```java
public static int countTriplets(int[] arr) {
    int n = arr.length;
    int[] xor = new int[n + 1];
    int[] count = new int[1024];
    int[] ways = new int[1024];
    xor[0] = 0;
    for (int i = 1; i <= n; i++) {
      xor[i] = xor[i - 1] ^ arr[i - 1];
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
      for (int j = i + 1; j <= n; j++) {
        int x = xor[j] ^ xor[i];
        ans += count[x] * ways[x];
        count[x]++;
      }
      for (int j = 0; j <= 1023; j++) {
        ways[j] += count[j];
        count[j] = 0;
      }
    }
    return ans;
  }
```","```python
def countTriplets(arr):
  n = len(arr)
  xor = [0] * (n + 1)
  ways = [0] * (1 << 20)
  count = 0
  for i in range(n):
    xor[i + 1] = xor[i] ^ arr[i]
  for i in range(n):
    for j in range(i + 1, n + 1):
      x = xor[j] ^ xor[i]
      count += ways[x]
    ways[xor[i + 1]] += i + 1
  return count
```"
321,Count of subarrays of an Array having all unique digits | Java program to find the count of subarrays of an Array having all unique digits ; Dynamic programming table ; Function to obtain the mask for any integer ; Function to count the number of ways ; Subarray must not be empty ; If subproblem has been solved ; Excluding this element in the subarray ; If there are no common digits then only this element can be included ; Calculate the new mask if this element is included ; Store and return the answer ; Function to find the count of subarray with all digits unique ; initializing dp ; Driver code,"```java
public class CountSubarraysUniqueDigits {

    public static int getMask(int num) {
        int mask = 0;
        while (num > 0) {
            mask |= 1 << (num % 10);
            num /= 10;
        }
        return mask;
    }

    public static int countWays(int[] arr, int n, int[][] dp, int prevMask) {
        if (n == 0) {
            return 1;
        }
        if (dp[n][prevMask] != -1) {
            return dp[n][prevMask];
        }
        int exclude = countWays(arr, n - 1, dp, prevMask);
        int include = 0;
        int currMask = getMask(arr[n - 1]);
        if ((prevMask & currMask) == 0) {
            include = countWays(arr, n - 1, dp, prevMask | currMask);
        }
        dp[n][prevMask] = exclude + include;
        return dp[n][prevMask];
    }

    public static int countSubarraysUniqueDigits(int[] arr) {
        int n = arr.length;
        int[][] dp = new int[n + 1][1024];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j < 1024; j++) {
                dp[i][j] = -1;
            }
        }
        return countWays(arr, n, dp, 0) - 1;
    }

    public static void main(String[] args) {
        int[] arr = {123, 456, 789};
        int count = countSubarraysUniqueDigits(arr);
        System.out.println(count);
    }
}
```","```python
def getMask(num):
  mask = 0
  while num:
    mask |= 1 << (num % 10)
    num //= 10
  return mask

def countWays(arr, n, dp, mask):
  if dp[n][mask] != -1:
    return dp[n][mask]
  if n == 0:
    return 1 if mask == 0 else 0
  ans = countWays(arr, n - 1, dp, mask)
  if (getMask(arr[n - 1]) & mask) == 0:
    ans += countWays(arr, n - 1, dp, mask | getMask(arr[n - 1]))
  dp[n][mask] = ans
  return ans

def countSubarrays(arr, n):
  dp = [[-1 for _ in range(1 << 10)] for _ in range(n + 1)]
  return countWays(arr, n, dp, 0)

if __name__ == ""__main__"":
  arr = [12, 34, 56, 78, 90]
  n = len(arr)
  print(countSubarrays(arr, n))
```"
322,"Count of Fibonacci paths in a Binary tree | Java program to count all of Fibonacci paths in a Binary tree ; Vector to store the fibonacci series ; Binary Tree Node ; Function to create a new tree node ; Function to find the height of the given tree ; Function to make fibonacci series upto n terms ; Preorder Utility function to count exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of Math . pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; Function to find whether fibonacci path exists or not ; To find the height ; Making fibonacci series upto ht terms ; Driver code ; Create binary tree ; Function Call","```java
import java.util.Vector;

class Node {
    int data;
    Node left, right;

    Node(int data) {
        this.data = data;
        left = right = null;
    }
}

class BinaryTree {

    Node root;

    Node newNode(int data) {
        return new Node(data);
    }

    int height(Node node) {
        if (node == null) {
            return 0;
        }
        return 1 + Math.max(height(node.left), height(node.right));
    }

    Vector<Integer> fibonacciSeries(int n) {
        Vector<Integer> fib = new Vector<>();
        fib.add(0);
        fib.add(1);
        for (int i = 2; i <= n; i++) {
            fib.add(fib.get(i - 1) + fib.get(i - 2));
        }
        return fib;
    }

    int countFibonacciPathsUtil(Node node, Vector<Integer> fib, int count) {
        if (node == null || !isPowerOfTwo(node.data)) {
            return count;
        }
        if (node.left == null && node.right == null) {
            count++;
        }
        count = countFibonacciPathsUtil(node.left, fib, count);
        count = countFibonacciPathsUtil(node.right, fib, count);
        return count;
    }

    int countFibonacciPaths(Node node) {
        int ht = height(node);
        Vector<Integer> fib = fibonacciSeries(ht);
        return countFibonacciPathsUtil(node, fib, 0);
    }

    boolean isFibonacciPathExists(Node node) {
        return countFibonacciPaths(node) > 0;
    }

    boolean isPowerOfTwo(int n) {
        return (n & (n - 1)) == 0;
    }

    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.root = tree.newNode(1);
        tree.root.left = tree.newNode(2);
        tree.root.right = tree.newNode(4);
        tree.root.left.left = tree.newNode(8);
        tree.root.left.right = tree.newNode(16);
        tree.root.right.left = tree.newNode(32);
        tree.root.right.right = tree.newNode(64);
        if (tree.isFibonacciPathExists(tree.root)) {
            System.out.println(""Yes"");
        } else {
            System.out.println(""No"");
        }
    }
}
```","```python
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def newNode(data):
    return Node(data)

def height(root):
    if root is None:
        return 0
    return 1 + max(height(root.left), height(root.right))

def fibonacci_series(n):
    fib = [0] * (n + 1)
    fib[0] = 0
    fib[1] = 1
    for i in range(2, n + 1):
        fib[i] = fib[i - 1] + fib[i - 2]
    return fib

def countFibonacciPaths(root, fib, ht, count=0):
    if root is None or not isinstance(root.data, int) or not (root.data == fib[ht] or root.data == fib[ht - 1]):
        return count
    if root.left is None and root.right is None:
        count += 1
    count = countFibonacciPaths(root.left, fib, ht - 1, count)
    count = countFibonacciPaths(root.right, fib, ht - 1, count)
    return count

def hasFibonacciPath(root):
    ht = height(root)
    fib = fibonacci_series(ht)
    return countFibonacciPaths(root, fib, ht) > 0

if __name__ == '__main__':
    root = newNode(1)
    root.left = newNode(2)
    root.right = newNode(3)
    root.left.left = newNode(5)
    root.left.right = newNode(8)
    root.right.left = newNode(13)
    root.right.right = newNode(21)
    print(hasFibonacciPath(root))
```"
323,"Numbers with a Fibonacci difference between Sum of digits at even and odd positions in a given range | Java program to count the numbers in the range having the difference between the sum of digits at even and odd positions as a Fibonacci Number ; To store all the Fibonacci numbers ; Function to generate Fibonacci numbers upto 100 ; Adding the first two Fibonacci numbers in the set ; Computing the remaining Fibonacci numbers using the first two Fibonacci numbers ; Function to return the count of required numbers from 0 to num ; Base Case ; Check if the difference is equal to any fibonacci number ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; If the current position is odd add it to currOdd , otherwise to currEven ; Function to convert x into its digit vector and uses count ( ) function to return the required count ; Initialize dp ; Driver Code ; Generate fibonacci numbers","```java
import java.util.*;
public class Solution {
    static Set<Integer> fibonacciNumbers = new HashSet<>();
    public static void main(String[] args) {
        generateFibonacciNumbers();
        Scanner sc = new Scanner(System.in);
        int l = sc.nextInt();
        int r = sc.nextInt();
        int count = countNumbers(r) - countNumbers(l - 1);
        System.out.println(count);
    }
    static void generateFibonacciNumbers() {
        fibonacciNumbers.add(0);
        fibonacciNumbers.add(1);
        int a = 0;
        int b = 1;
        for (int i = 2; i <= 100; i++) {
            int c = a + b;
            fibonacciNumbers.add(c);
            a = b;
            b = c;
        }
    }
    static int countNumbers(int num) {
        int[][] dp = new int[10][num + 1];
        for (int i = 0; i <= 9; i++) {
            dp[i][0] = 1;
        }
        return count(num, 0, 0, 0, dp, 1);
    }
    static int count(int num, int pos, int currOdd, int currEven, int[][] dp, int tight) {
        if (pos == 10) {
            if (fibonacciNumbers.contains(Math.abs(currOdd - currEven))) {
                return 1;
            }
            return 0;
        }
        if (dp[pos][num] != 0) {
            return dp[pos][num];
        }
        int result = 0;
        int limit = tight == 1 ? 9 : num % 10;
        for (int i = 0; i <= limit; i++) {
            if (pos % 2 == 1) {
                result += count(num / 10, pos + 1, currOdd + i, currEven, dp, tight == 1 ? 1 : (i == limit ? 1 : 0));
            } else {
                result += count(num / 10, pos + 1, currOdd, currEven + i, dp, tight == 1 ? 1 : (i == limit ? 1 : 0));
            }
        }
        dp[pos][num] = result;
        return result;
    }
}
```","```python
def countNumbers(num):
  dp = [[-1 for i in range(101)] for j in range(101)]
  fib = []
  fib.append(0)
  fib.append(1)
  for i in range(2, 101):
    fib.append(fib[i-1] + fib[i-2])
  return count(num, 0, 0, 0, 1, fib, dp)

def count(num, pos, currOdd, currEven, tight, fib, dp):
  if pos == len(num):
    if abs(currOdd - currEven) in fib:
      return 1
    return 0
  if dp[pos][tight] != -1:
    return dp[pos][tight]
  ans = 0
  limit = 9 if tight else int(num[pos])
  for i in range(0, limit + 1):
    if pos % 2 == 0:
      ans += count(num, pos + 1, currOdd, currEven + i, tight or (i < limit), fib, dp)
    else:
      ans += count(num, pos + 1, currOdd + i, currEven, tight or (i < limit), fib, dp)
  dp[pos][tight] = ans
  return ans

def convert(x):
  return [int(i) for i in str(x)]

def main():
  n = int(input())
  ans = countNumbers(convert(n))
  print(ans)

if __name__ == '__main__':
  main()
```"
324,Count maximum occurrence of subsequence in string such that indices in subsequence is in A . P . | Java implementation to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Function to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Frequency for characters ; Loop to count the occurrence of ith character before jth character in the given String ; Increase the frequency of s [ i ] or c of String ; Maximum occurrence of subsequence of length 1 in given String ; Maximum occurrence of subsequence of length 2 in given String ; Driver Code,"```java
public static int maxSubsequence(String s, int[] a) {
    int n = s.length();
    int[][] freq = new int[n][n];
    for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
        if (s.charAt(i) == s.charAt(j)) {
          freq[i][j]++;
        }
        freq[i][j] += freq[i][j - 1];
      }
    }
    int max1 = 0;
    for (int i = 0; i < n; i++) {
      max1 = Math.max(max1, freq[i][n - 1]);
    }
    int max2 = 0;
    for (int i = 0; i < a.length - 1; i++) {
      for (int j = i + 1; j < a.length; j++) {
        if (a[j] - a[i] == a[i + 1] - a[i]) {
          max2 = Math.max(max2, freq[a[i]][a[j]]);
        }
      }
    }
    return Math.max(max1, max2);
  }
```","```python
def count_max_occurrence(s):
  n = len(s)
  freq = [0] * 26
  for i in range(n):
    freq[ord(s[i]) - ord('a')] += 1
  max_occur = 0
  for i in range(n):
    for j in range(i + 1, n):
      if (j - i) == (n - 1 - j):
        max_occur = max(max_occur, freq[ord(s[i]) - ord('a')] * freq[ord(s[j]) - ord('a')])
  return max_occur
```"
325,"Count the numbers with N digits and whose suffix is divisible by K | Java implementation to Count the numbers with N digits and whose suffix is divisible by K ; Suffix of length pos with remainder rem and Z representing whether the suffix has a non zero digit until now ; Base case ; If count of digits is less than n ; Placing all possible digits in remaining positions ; If remainder non zero and suffix has n digits ; If the subproblem is already solved ; Placing all digits at MSB of suffix and increasing it 's length by 1 ; Non zero digit is placed ; Store and return the solution to this subproblem ; Function to Count the numbers with N digits and whose suffix is divisible by K ; Since we need powers of 10 for counting , it 's better to  pre store them along with their  modulo with 1e9 + 7 for counting ; Since at each recursive step we increase the suffix length by 1 by placing digits at its leftmost position , we need powers of 10 modded with k , in order to fpos the new remainder efficiently ; Initialising dp table values - 1 represents subproblem hasn 't  been solved yet ; Driver Code","```java
class Solution {
    int MOD = 1000000007;
    long[][] dp;
    long[] pow10;
    long[] pow10modK;
    public int countNumbers(int n, int k) {
        dp = new long[n + 1][k];
        pow10 = new long[n + 1];
        pow10modK = new long[n + 1];
        pow10[0] = 1;
        pow10modK[0] = 1;
        for (int i = 1; i <= n; i++) {
            pow10[i] = pow10[i - 1] * 10;
            pow10modK[i] = (pow10modK[i - 1] * 10) % k;
        }
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j < k; j++) {
                dp[i][j] = -1;
            }
        }
        return (int)solve(n, 0, 0, false);
    }
    long solve(int n, int pos, int rem, boolean Z) {
        if (pos == n) {
            return rem == 0 && Z ? 1 : 0;
        }
        if (dp[pos][rem] != -1) {
            return dp[pos][rem];
        }
        long ans = 0;
        if (Z) {
            for (int d = 1; d <= 9; d++) {
                ans = (ans + solve(n, pos + 1, (rem * 10 + d) % k, true)) % MOD;
            }
        } else {
            for (int d = 0; d <= 9; d++) {
                ans = (ans + solve(n, pos + 1, (rem * 10 + d) % k, d != 0)) % MOD;
            }
        }
        dp[pos][rem] = ans;
        return ans;
    }
}
```","```python
def countNumbers(n, k):
    mod = 10**9 + 7
    pow10 = [1]
    for i in range(1, n + 1):
        pow10.append((pow10[-1] * 10) % mod)
    pow10k = [1]
    for i in range(1, n + 1):
        pow10k.append((pow10k[-1] * 10) % k)
    dp = [[[-1 for _ in range(2)] for _ in range(k)] for _ in range(n + 1)]
    def solve(pos, rem, z):
        if pos == n:
            return 1 if rem == 0 else 0
        if dp[pos][rem][z] != -1:
            return dp[pos][rem][z]
        ans = 0
        for d in range(10):
            if pos == 0 and d == 0:
                continue
            newRem = (rem * 10 + d) % k
            newZ = z or d != 0
            ans = (ans + solve(pos + 1, newRem, newZ)) % mod
        dp[pos][rem][z] = ans
        return ans
    return solve(0, 0, 0)
```"
326,Shortest path with exactly k edges in a directed and weighted graph | Set 2 | Java implementation of the above approach ; Function to find the smallest path with exactly K edges ; Array to store dp ; Initialising the array ; Loop to solve DP ; Initialising next state ; Recurrence relation ; Returning final answer ; Driver code ; Input edges ; Source and Destination ; Number of edges in path ; Calling the function,"```java
public static int shortestPath(int[][] graph, int src, int dest, int k) {
    int[][] dp = new int[k + 1][graph.length];
    for (int i = 0; i <= k; i++) {
      for (int j = 0; j < graph.length; j++) {
        dp[i][j] = Integer.MAX_VALUE;
      }
    }
    dp[0][src] = 0;
    for (int i = 1; i <= k; i++) {
      for (int u = 0; u < graph.length; u++) {
        for (int v = 0; v < graph.length; v++) {
          if (graph[u][v] != Integer.MAX_VALUE) {
            if (dp[i - 1][u] != Integer.MAX_VALUE) {
              dp[i][v] = Math.min(dp[i][v], dp[i - 1][u] + graph[u][v]);
            }
          }
        }
      }
    }
    return dp[k][dest];
  }
```","```python
def shortest_path_with_k_edges(graph, src, dest, k):
  n = len(graph)
  dp = [[float('inf')] * n for _ in range(k + 1)]
  for i in range(k + 1):
    dp[i][src] = 0
  for i in range(1, k + 1):
    for u in range(n):
      for v in range(n):
        if graph[u][v] != float('inf'):
          dp[i][v] = min(dp[i][v], dp[i - 1][u] + graph[u][v])
  return dp[k][dest]
```"
327,Path with smallest product of edges with weight > 0 | Java implementation of the approach ; Function to return the smallest product of edges ; If the source is equal to the destination ; Array to store distances ; Initialising the array ; Bellman ford algorithm ; Loop to detect cycle ; Returning final answer ; Driver code ; Input edges ; Source and Destination ; Bellman ford,"```java
public static long shortestPath(int[][] graph, int src, int dest) {
    if (src == dest) {
      return 1;
    }
    long[] dist = new long[graph.length];
    Arrays.fill(dist, Long.MAX_VALUE);
    dist[src] = 1;
    for (int i = 0; i < graph.length - 1; i++) {
      for (int j = 0; j < graph.length; j++) {
        for (int k = 0; k < graph.length; k++) {
          if (graph[j][k] > 0 && dist[j] != Long.MAX_VALUE && dist[j] * graph[j][k] < dist[k]) {
            dist[k] = dist[j] * graph[j][k];
          }
        }
      }
    }
    for (int i = 0; i < graph.length; i++) {
      for (int j = 0; j < graph.length; j++) {
        for (int k = 0; k < graph.length; k++) {
          if (graph[j][k] > 0 && dist[j] != Long.MAX_VALUE && dist[j] * graph[j][k] < dist[k]) {
            return -1;
          }
        }
      }
    }
    return dist[dest];
  }
```","```python
def minProduct(edges, source, destination):
  n = len(edges)
  dist = [float('inf')] * n
  dist[source] = 1
  for _ in range(n - 1):
    for u, v, w in edges:
      if dist[u] != float('inf') and dist[u] * w < dist[v] and w > 0:
        dist[v] = dist[u] * w
  for u, v, w in edges:
    if dist[u] != float('inf') and dist[u] * w < dist[v] and w > 0:
      return -1
  return dist[destination] if dist[destination] != float('inf') else -1
```"
328,Find Maximum Length Of A Square Submatrix Having Sum Of Elements At | Java implementation of the above approach ; Function to return maximum length of square submatrix having sum of elements at - most K ; Matrix to store prefix sum ; Current maximum length ; Variable for storing maximum length of square ; Calculating prefix sum ; Checking whether there exits square with length cur_max + 1 or not ; Returning the maximum length ; Driver code,"```java
public static int maxLenSquareWithSumAtMostK(int[][] mat, int K) {
    int n = mat.length;
    int m = mat[0].length;
    int[][] prefixSum = new int[n + 1][m + 1];
    int curMax = 0;
    int maxLen = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1] + mat[i - 1][j - 1];
        }
    }
    while (curMax <= Math.min(n, m)) {
        for (int i = curMax; i <= n; i++) {
            for (int j = curMax; j <= m; j++) {
                int sum = prefixSum[i][j] - prefixSum[i - curMax][j] - prefixSum[i][j - curMax] + prefixSum[i - curMax][j - curMax];
                if (sum <= K) {
                    maxLen = curMax;
                }
            }
        }
        curMax++;
    }
    return maxLen;
}
```","```python
def max_square_submatrix(matrix, K):
  n = len(matrix)
  m = len(matrix[0])
  prefix_sum = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
  cur_max = 0
  for i in range(1, n + 1):
    for j in range(1, m + 1):
      prefix_sum[i][j] = matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]
  for i in range(1, n + 1):
    for j in range(1, m + 1):
      for cur_max in range(1, min(i, j) + 1):
        if prefix_sum[i][j] - prefix_sum[i - cur_max][j] - prefix_sum[i][j - cur_max] + prefix_sum[i - cur_max][j - cur_max] <= K:
          break
  return cur_max
```"
329,"Sum of all numbers formed having 4 atmost X times , 5 atmost Y times and 6 atmost Z times | Java program to find sum of all numbers formed having 4 atmost X times , 5 atmost Y times and 6 atmost Z times ; exactsum [ i ] [ j ] [ k ] stores the sum of all the numbers having exact i 4 ' s , ▁ j ▁ 5' s and k 6 's ; exactnum [ i ] [ j ] [ k ] stores numbers of numbers having exact i 4 ' s , ▁ j ▁ 5' s and k 6 's ; Utility function to calculate the sum for x 4 ' s , ▁ y ▁ 5' s and z 6 's ; Computing exactsum [ i ] [ j ] [ k ] as explained above ; Driver code","```java
public static int sum(int x, int y, int z) {
    int[][][] exactsum = new int[x + 1][y + 1][z + 1];
    int[][][] exactnum = new int[x + 1][y + 1][z + 1];
    for (int i = 0; i <= x; i++) {
        for (int j = 0; j <= y; j++) {
            for (int k = 0; k <= z; k++) {
                if (i == 0 && j == 0 && k == 0) {
                    exactsum[i][j][k] = 0;
                    exactnum[i][j][k] = 1;
                } else if (i == 0) {
                    exactsum[i][j][k] = exactsum[i][j - 1][k] * 10 + exactnum[i][j - 1][k] * 5;
                    exactnum[i][j][k] = exactnum[i][j - 1][k];
                } else if (j == 0) {
                    exactsum[i][j][k] = exactsum[i - 1][j][k] * 10 + exactnum[i - 1][j][k] * 4;
                    exactnum[i][j][k] = exactnum[i - 1][j][k];
                } else if (k == 0) {
                    exactsum[i][j][k] = exactsum[i][j][k - 1] * 10 + exactnum[i][j][k - 1] * 6;
                    exactnum[i][j][k] = exactnum[i][j][k - 1];
                } else {
                    exactsum[i][j][k] = exactsum[i - 1][j][k] * 10 + exactnum[i - 1][j][k] * 4 + exactsum[i][j - 1][k] * 10 + exactnum[i][j - 1][k] * 5 + exactsum[i][j][k - 1] * 10 + exactnum[i][j][k - 1] * 6;
                    exactnum[i][j][k] = exactnum[i - 1][j][k] + exactnum[i][j - 1][k] + exactnum[i][j][k - 1];
                }
            }
        }
    }
    int result = 0;
    for (int i = 0; i <= x; i++) {
        for (int j = 0; j <= y; j++) {
            for (int k = 0; k <= z; k++) {
                result += exactsum[i][j][k];
            }
        }
    }
    return result;
}
```","```python
def sum_of_numbers(X, Y, Z):
  exactsum = [[[0 for _ in range(Z + 1)] for _ in range(Y + 1)] for _ in range(X + 1)]
  exactnum = [[[0 for _ in range(Z + 1)] for _ in range(Y + 1)] for _ in range(X + 1)]
  for i in range(X + 1):
    for j in range(Y + 1):
      for k in range(Z + 1):
        if i == 0 and j == 0 and k == 0:
          exactsum[i][j][k] = 0
          exactnum[i][j][k] = 1
        elif i == 0 and j == 0 and k != 0:
          exactsum[i][j][k] = 6 * exactsum[i][j][k - 1] + 6 * exactnum[i][j][k - 1]
          exactnum[i][j][k] = exactnum[i][j][k - 1]
        elif i == 0 and j != 0 and k == 0:
          exactsum[i][j][k] = 5 * exactsum[i][j - 1][k] + 5 * exactnum[i][j - 1][k]
          exactnum[i][j][k] = exactnum[i][j - 1][k]
        elif i != 0 and j == 0 and k == 0:
          exactsum[i][j][k] = 4 * exactsum[i - 1][j][k] + 4 * exactnum[i - 1][j][k]
          exactnum[i][j][k] = exactnum[i - 1][j][k]
        elif i != 0 and j != 0 and k == 0:
          exactsum[i][j][k] = 4 * exactsum[i - 1][j][k] + 4 * exactnum[i - 1][j][k] + 5 * exactsum[i][j - 1][k] + 5 * exactnum[i][j - 1][k]
          exactnum[i][j][k] = exactnum[i - 1][j][k] + exactnum[i][j - 1][k]
        elif i != 0 and j == 0 and k != 0:
          exactsum[i][j][k] = 4 * exactsum[i - 1][j][k] + 4 * exactnum[i - 1][j][k] + 6 * exactsum[i][j][k - 1] + 6 * exactnum[i][j][k - 1]
          exactnum[i][j][k] = exactnum[i - 1][j][k] + exactnum[i][j][k - 1]
        elif i == 0 and j != 0 and k != 0:
          exactsum[i][j][k] = 5 * exactsum[i][j - 1][k] + 5 * exactnum[i][j - 1][k] + 6 * exactsum[i][j][k - 1] + 6 * exactnum[i][j][k - 1]
          exactnum[i][j][k] = exactnum[i][j - 1][k] + exactnum[i][j][k - 1]
        else:
          exactsum[i][j][k] = 4 * exactsum[i - 1][j][k] + 4 * exactnum[i - 1][j][k] + 5 * exactsum[i][j - 1][k] + 5 * exactnum[i][j - 1][k] + 6 * exactsum[i][j][k - 1] + 6 * exactnum[i][j][k - 1]
          exactnum[i][j][k] = exactnum[i - 1][j][k] + exactnum[i][j - 1][k] + exactnum[i][j][k - 1]
  sum = 0
  for i in range(X + 1):
    for j in range(Y + 1):
      for k in range(Z + 1):
        sum += exactsum[i][j][k]
  return sum

```"
330,Maximum value obtained by performing given operations in an Array | Java implementation of the above approach ; A function to calculate the maximum value ; basecases ; Loop to iterate and add the max value in the dp array ; Driver Code,"```java
public static int maxOperations(int[] arr, int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = arr[0];
    for (int i = 2; i <= n; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + arr[i - 1]);
    }
    return dp[n];
}
```","```python
def max_value(arr, n):
  dp = [0] * (n + 1)
  dp[0] = arr[0]
  dp[1] = max(arr[0], arr[1])
  for i in range(2, n + 1):
    dp[i] = max(dp[i - 1], dp[i - 2] + arr[i - 1])
  return dp[n]
```"
331,Optimal strategy for a Game with modifications | Java implementation of the above approach ; Function to return sum of subarray from l to r ; calculate sum by a loop from l to r ; dp to store the values of sub problems ; if length of the array is less than k return the sum ; if the value is previously calculated ; else calculate the value ; select all the sub array of length len_r ; get the sum of that sub array ; check if it is the maximum or not ; store it in the table ; Driver code,"```java
public static int optimalStrategy(int[] arr, int k) {
    int n = arr.length;
    if (n < k) {
        return sum(arr, 0, n - 1);
    }
    int[][] dp = new int[n][n];
    for (int len_r = k; len_r <= n; len_r++) {
        for (int l = 0; l <= n - len_r; l++) {
            int r = l + len_r - 1;
            if (dp[l][r] != 0) {
                continue;
            }
            int max = 0;
            for (int i = l; i <= r - k + 1; i++) {
                max = Math.max(max, sum(arr, l, i) + sum(arr, i + k, r) + dp[i + 1][r - k]);
            }
            dp[l][r] = max;
        }
    }
    return dp[0][n - 1];
}

private static int sum(int[] arr, int l, int r) {
    int sum = 0;
    for (int i = l; i <= r; i++) {
        sum += arr[i];
    }
    return sum;
}
```","```python
def optimal_strategy(arr, k):
  n = len(arr)
  if n < k:
    return sum(arr)
  dp = [[0 for _ in range(n)] for _ in range(n)]
  for len_r in range(k, n + 1):
    for l in range(n - len_r + 1):
      r = l + len_r - 1
      if dp[l][r] != 0:
        continue
      dp[l][r] = max(arr[l] + min(dp[l + 1][r], dp[l + 2][r]), arr[r] + min(dp[l][r - 1], dp[l][r - 2]))
  return dp[0][n - 1]
```"
332,"Find the minimum difference path from ( 0 , 0 ) to ( N | Java implementation of the approach ; Function to return the minimum difference path from ( 0 , 0 ) to ( N - 1 , M - 1 ) ; Terminating case ; Base case ; If it is already visited ; Recursive calls ; Return the value ; Driver code ; Function call","```java
public static int minDifferencePath(int[][] grid, int n, int m, int[][] dp, int i, int j) {
    if (i == n - 1 && j == m - 1) {
        return grid[i][j];
    }
    if (i >= n || j >= m) {
        return Integer.MAX_VALUE;
    }
    if (dp[i][j] != -1) {
        return dp[i][j];
    }
    int down = minDifferencePath(grid, n, m, dp, i + 1, j);
    int right = minDifferencePath(grid, n, m, dp, i, j + 1);
    dp[i][j] = grid[i][j] + Math.min(down, right);
    return dp[i][j];
}
```","```python
def min_diff_path(grid, N, M, i, j, dp):
    if i == N - 1 and j == M - 1:
        return abs(grid[i][j])
    if i >= N or j >= M:
        return float('inf')
    if dp[i][j] != -1:
        return dp[i][j]
    right = min_diff_path(grid, N, M, i, j + 1, dp)
    down = min_diff_path(grid, N, M, i + 1, j, dp)
    dp[i][j] = abs(grid[i][j]) + min(right, down)
    return dp[i][j]
```"
333,Longest subsequence having difference atmost K | Java program for the above approach ; Function to find the longest Special Sequence ; Creating a list with all 0 's of size  equal to the length of String ; Supporting list with all 0 's of size 26 since  the given String consists  of only lower case alphabets ; Converting the ascii value to list indices ; Determining the lower bound ; Determining the upper bound ; Filling the dp array with values ; Filling the max_length array with max length of subsequence till now ; return the max length of subsequence ; Driver Code,"```java
public static int longestSpecialSequence(String s, int k) {
    int n = s.length();
    int[] dp = new int[n];
    int[] max_length = new int[26];
    Arrays.fill(max_length, 0);
    for (int i = 0; i < n; i++) {
        int ascii = s.charAt(i) - 'a';
        int lower_bound = Math.max(0, ascii - k);
        int upper_bound = Math.min(25, ascii + k);
        dp[i] = 1;
        for (int j = lower_bound; j <= upper_bound; j++) {
            dp[i] = Math.max(dp[i], max_length[j] + 1);
        }
        max_length[ascii] = Math.max(max_length[ascii], dp[i]);
    }
    return max_length[s.charAt(n - 1) - 'a'];
}
```","```python
def longestSpecialSequence(str, k):
  n = len(str)
  dp = [0] * n
  max_length = [0] * 26
  for i in range(n):
    lower_bound = 0
    upper_bound = i - 1
    while lower_bound <= upper_bound:
      mid = (lower_bound + upper_bound) // 2
      if ord(str[i]) - ord(str[mid]) <= k:
        upper_bound = mid - 1
      else:
        lower_bound = mid + 1
    if upper_bound >= 0:
      dp[i] = max_length[ord(str[i]) - ord('a')] + 1
    else:
      dp[i] = 1
    max_length[ord(str[i]) - ord('a')] = max(max_length[ord(str[i]) - ord('a')], dp[i])
  return max(dp)
```"
334,Maximum sum subarray after altering the array | Java implementation of the approach ; Function that returns true if all the array element are <= 0 ; If any element is non - negative ; Function to return the vector representing the right to left Kadane array as described in the approach ; Function to return the prefix_sum vector ; Function to return the maximum sum subarray ; Function to get the maximum sum subarray in the modified array ; kadane_r_to_l [ i ] will store the maximum subarray sum for thre subarray arr [ i ... N - 1 ] ; Get the prefix sum array ; To get max_prefix_sum_at_any_index ; Summation of both gives the maximum subarray sum after applying the operation ; Function to return the maximum subarray sum after performing the given operation at most once ; If all element are negative then return the maximum element ; Maximum subarray sum without performing any operation ; Maximum subarray sum after performing the operations of first type ; Reversing the array to use the same existing function for operations of the second type ; Driver code,"```java
import java.util.*;
public class Solution {
    public static boolean allElementsNegative(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] >= 0) {
                return false;
            }
        }
        return true;
    }
    public static int[] kadane_r_to_l(int[] arr) {
        int n = arr.length;
        int[] kadane_r_to_l = new int[n];
        kadane_r_to_l[n - 1] = arr[n - 1];
        int max_so_far = arr[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            max_so_far = Math.max(arr[i], max_so_far + arr[i]);
            kadane_r_to_l[i] = max_so_far;
        }
        return kadane_r_to_l;
    }
    public static int[] prefix_sum(int[] arr) {
        int n = arr.length;
        int[] prefix_sum = new int[n];
        prefix_sum[0] = arr[0];
        for (int i = 1; i < n; i++) {
            prefix_sum[i] = prefix_sum[i - 1] + arr[i];
        }
        return prefix_sum;
    }
    public static int maxSubArraySum(int[] arr) {
        int n = arr.length;
        int max_so_far = arr[0];
        int max_ending_here = arr[0];
        for (int i = 1; i < n; i++) {
            max_ending_here = Math.max(arr[i], max_ending_here + arr[i]);
            max_so_far = Math.max(max_so_far, max_ending_here);
        }
        return max_so_far;
    }
    public static int getMaxSumSubarrayInModifiedArray(int[] arr) {
        int n = arr.length;
        int[] kadane_r_to_l = kadane_r_to_l(arr);
        int[] prefix_sum = prefix_sum(arr);
        int max_prefix_sum_at_any_index = prefix_sum[0];
        for (int i = 1; i < n; i++) {
            max_prefix_sum_at_any_index = Math.max(max_prefix_sum_at_any_index, prefix_sum[i]);
        }
        int max_sum = kadane_r_to_l[0] + max_prefix_sum_at_any_index;
        for (int i = 1; i < n; i++) {
            max_sum = Math.max(max_sum, kadane_r_to_l[i] + max_prefix_sum_at_any_index - prefix_sum[i - 1]);
        }
        return max_sum;
    }
    public static int maximumSumSubarrayAfterAtMostOneOperation(int[] arr) {
        if (allElementsNegative(arr)) {
            int max = arr[0];
            for (int i = 1; i < arr.length; i++) {
                max = Math.max(max, arr[i]);
            }
            return max;
        }
        int max_sum_without_operation = maxSubArraySum(arr);
        int max_sum_with_operation = getMaxSumSubarrayInModifiedArray(arr);
        int[] reversed_arr = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            reversed_arr[i] = arr[arr.length - 1 - i];
        }
        int max_sum_with_operation_reversed = getMaxSumSubarrayInModifiedArray(reversed_arr);
        return Math.max(max_sum_without_operation, Math.max(max_sum_with_operation, max_sum_with_operation_reversed));
    }
    public static void main(String[] args) {
        int[] arr = {1, -2, 3, 4, -5, 6, -7, 8, -9};
        System.out.println(maximumSumSubarrayAfterAtMostOneOperation(arr));
    }
}
```","```python
def all_negative(arr):
  for i in arr:
    if i >= 0:
      return False
  return True

def kadane_r_to_l(arr):
  n = len(arr)
  kadane_r_to_l = [0] * n
  kadane_r_to_l[n - 1] = arr[n - 1]
  max_so_far = arr[n - 1]
  for i in range(n - 2, -1, -1):
    max_so_far = max(arr[i], max_so_far + arr[i])
    kadane_r_to_l[i] = max_so_far
  return kadane_r_to_l

def prefix_sum(arr):
  n = len(arr)
  prefix_sum = [0] * (n + 1)
  for i in range(n):
    prefix_sum[i + 1] = prefix_sum[i] + arr[i]
  return prefix_sum

def max_sum_subarray(arr):
  n = len(arr)
  max_so_far = arr[0]
  max_ending_here = arr[0]
  for i in range(1, n):
    max_ending_here = max(arr[i], max_ending_here + arr[i])
    max_so_far = max(max_so_far, max_ending_here)
  return max_so_far

def max_sum_subarray_modified(arr):
  n = len(arr)
  prefix_sum = prefix_sum(arr)
  kadane_r_to_l_arr = kadane_r_to_l(arr)
  max_prefix_sum = 0
  for i in range(n):
    max_prefix_sum = max(max_prefix_sum, prefix_sum[i + 1])
  max_sum = 0
  for i in range(n):
    max_sum = max(max_sum, max_prefix_sum + kadane_r_to_l_arr[i])
  return max_sum

def max_sum_subarray_operation(arr):
  if all_negative(arr):
    return max(arr)
  max_sum_without_operation = max_sum_subarray(arr)
  max_sum_with_operation = max_sum_subarray_modified(arr)
  return max(max_sum_without_operation, max_sum_with_operation)

def max_sum_subarray_operation_second_type(arr):
  arr.reverse()
  return max_sum_subarray_operation(arr)

# Driver code
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_sum_subarray_operation(arr))
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_sum_subarray_operation_second_type(arr))
```"
335,Maximum possible array sum after performing the given operation | Java implementation of the approach ; Function to return the maximum possible sum after performing the given operation ; Dp vector to store the answer ; Base value ; Return the maximum sum ; Driver code,"```java
public static long maxSumAfterOperation(int[] nums, int k) {
    long[] dp = new long[nums.length + 1];
    dp[0] = 0;
    for (int i = 1; i <= nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 1] + nums[i - 1]);
    }
    long maxSum = dp[nums.length];
    for (int i = 1; i <= nums.length; i++) {
        for (int j = i + 1; j <= nums.length; j++) {
            long sum = dp[i - 1] + (long) Math.pow(nums[i - 1], k) + dp[nums.length] - dp[j];
            maxSum = Math.max(maxSum, sum);
        }
    }
    return maxSum;
}
```","```python
def maxSum(arr, n, k):
  dp = [0] * (n + 1)
  dp[0] = 0
  for i in range(1, n + 1):
    dp[i] = max(dp[i - 1], arr[i - 1] + dp[max(0, i - k)])
  return dp[n]
```"
336,Find the number of ways to reach Kth step in stair case | Java implementation of the approach ; Function to return the number of ways to reach the kth step ; Create the dp array ; Broken steps ; Calculate the number of ways for the rest of the positions ; If it is a blocked position ; Number of ways to get to the ith step ; Return the required answer ; Driver code,"```java
public static int countWays(int n, int[] a) {
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (a[i - 1] == 0) {
            dp[i] = dp[i - 1] + dp[i - 2];
        } else {
            dp[i] = 0;
        }
    }
    return dp[n];
}
```","```python
def countWays(n, k, a):
  dp = [0] * (n + 1)
  dp[0] = 1
  dp[1] = 1
  for i in range(2, n + 1):
    if i in a:
      dp[i] = 0
    else:
      dp[i] = dp[i - 1] + dp[i - 2]
  return dp[n]
```"
337,Minimum number of coins that can generate all the values in the given range | Java program to find minimum number of coins ; Function to find minimum number of coins ; Driver code,"```java
public static int minCoins(int[] coins, int rangeStart, int rangeEnd) {
    int[] dp = new int[rangeEnd + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    for (int i = 1; i <= rangeEnd; i++) {
        for (int j = 0; j < coins.length; j++) {
            if (coins[j] <= i && dp[i - coins[j]] != Integer.MAX_VALUE) {
                dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
        }
    }
    int minCoins = Integer.MAX_VALUE;
    for (int i = rangeStart; i <= rangeEnd; i++) {
        minCoins = Math.min(minCoins, dp[i]);
    }
    return minCoins;
}
```","```python
def min_coins(coins, total):
  dp = [float('inf')] * (total + 1)
  dp[0] = 0
  for i in range(1, total + 1):
    for j in range(len(coins)):
      if coins[j] <= i:
        dp[i] = min(dp[i], dp[i - coins[j]] + 1)
  return dp[total] if dp[total] != float('inf') else -1
```"
338,Calculate the number of set bits for every number from 0 to N | Java implementation of the approach ; Function to find the count of set bits in all the integers from 0 to n ; Driver code,"```java
public static int countSetBits(int n) {
    int count = 0;
    for (int i = 0; i <= n; i++) {
        int num = i;
        while (num > 0) {
            count += num & 1;
            num >>= 1;
        }
    }
    return count;
}
```","```python
def countSetBits(n):
  count = 0
  for i in range(n + 1):
    count += bin(i).count('1')
  return count
```"
339,Count number of ways to arrange first N numbers | Java implementation of the above approach ; Function to return the count of required arrangements ; Create a vector ; Store numbers from 1 to n ; To store the count of ways ; Generate all the permutations using next_permutation in STL ; Initialize flag to true if first element is 1 else false ; Checking if the current permutation satisfies the given conditions ; If the current permutation is invalid then set the flag to false ; If valid arrangement ; Generate the next permutation ;  ; Driver code,"```java
public static int countArrangements(int n) {
    List<Integer> arr = new ArrayList<>();
    for (int i = 1; i <= n; i++) {
      arr.add(i);
    }
    int count = 0;
    do {
      boolean flag = arr.get(0) == 1;
      for (int i = 1; i < n; i++) {
        if (Math.abs(arr.get(i) - arr.get(i - 1)) != 1) {
          flag = false;
          break;
        }
      }
      if (flag) {
        count++;
      }
    } while (nextPermutation(arr));
    return count;
  }

  private static boolean nextPermutation(List<Integer> arr) {
    int i = arr.size() - 2;
    while (i >= 0 && arr.get(i) >= arr.get(i + 1)) {
      i--;
    }
    if (i >= 0) {
      int j = arr.size() - 1;
      while (arr.get(j) <= arr.get(i)) {
        j--;
      }
      swap(arr, i, j);
    }
    reverse(arr, i + 1, arr.size() - 1);
    return i >= 0;
  }

  private static void swap(List<Integer> arr, int i, int j) {
    int temp = arr.get(i);
    arr.set(i, arr.get(j));
    arr.set(j, temp);
  }

  private static void reverse(List<Integer> arr, int start, int end) {
    while (start < end) {
      swap(arr, start, end);
      start++;
      end--;
    }
  }
```","```python
from itertools import permutations

def count_arrangements(n):
  numbers = list(range(1, n + 1))
  count = 0
  for perm in permutations(numbers):
    flag = perm[0] == 1
    for i in range(1, n):
      if abs(perm[i] - perm[i - 1]) != 1:
        flag = False
        break
    if flag:
      count += 1
  return count
```"
340,Count number of ways to arrange first N numbers | Java implementation of the approach ; Function to return the count of required arrangements ; Create the dp array ; Initialize the base cases as explained above ; ( 12 ) as the only possibility ; Generate answer for greater values ; dp [ n ] contains the desired answer ; Driver code,"```java
public static long countArrangements(int n) {
    long[] dp = new long[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
      dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
    }
    return dp[n];
  }
```","```python
def count_arrangements(n):
  dp = [0] * (n + 1)
  dp[0] = 1
  dp[1] = 1
  for i in range(2, n + 1):
    dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2])
  return dp[n]
```"
341,Number of shortest paths to reach every cell from bottom | Java program to find number of shortest paths ; Function to find number of shortest paths ; Compute the grid starting from the bottom - left corner ; Print the grid ; Driver code ; Function call,"```java
public static int[][] numberOfShortestPaths(int[][] grid) {
    int rows = grid.length;
    int cols = grid[0].length;
    int[][] dp = new int[rows][cols];
    dp[rows - 1][0] = 1;
    for (int i = rows - 2; i >= 0; i--) {
        if (grid[i][0] == 0) {
            dp[i][0] = dp[i + 1][0];
        }
    }
    for (int j = 1; j < cols; j++) {
        if (grid[rows - 1][j] == 0) {
            dp[rows - 1][j] = dp[rows - 1][j - 1];
        }
    }
    for (int i = rows - 2; i >= 0; i--) {
        for (int j = 1; j < cols; j++) {
            if (grid[i][j] == 0) {
                dp[i][j] = dp[i + 1][j] + dp[i][j - 1];
            }
        }
    }
    return dp;
}
```","```python
def count_shortest_paths(grid):
  m = len(grid)
  n = len(grid[0])
  dp = [[0 for _ in range(n)] for _ in range(m)]
  dp[m - 1][0] = 1
  for i in range(m - 2, -1, -1):
    dp[i][0] = dp[i + 1][0]
  for j in range(1, n):
    dp[m - 1][j] = dp[m - 1][j - 1]
  for i in range(m - 2, -1, -1):
    for j in range(1, n):
      dp[i][j] = dp[i + 1][j] + dp[i][j - 1]
  return dp
```"
342,Maximum sum combination from two arrays | Java program to maximum sum combination from two arrays ; Function to maximum sum combination from two arrays ; To store dp value ; For loop to calculate the value of dp ; Return the required answer ; Driver code ; Function call,"```java
public static int maxSumCombination(int[] arr1, int[] arr2, int n) {
    int[][] dp = new int[n + 1][n + 1];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + (arr1[i - 1] + arr2[j - 1]);
        }
    }
    return dp[n][n];
}
```","```python
def maxSumCombination(arr1, arr2, n):
  dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
  for i in range(1, n + 1):
    for j in range(1, n + 1):
      dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + arr1[i - 1] + arr2[j - 1])
  return dp[n][n]
```"
343,"Partition the array in K segments such that bitwise AND of individual segment sum is maximized | Java program to find maximum possible AND ; Function to check whether a k segment partition is possible such that bitwise AND is ' mask ' ; dp [ i ] [ j ] stores whether it is possible to partition first i elements into j segments such that all j segments are ' good ' ; Initialising dp ; Filling dp in bottom - up manner ; Finding a cut such that first l elements can be partitioned into j - 1 ' good ' segments and arr [ l + 1 ] + ... + arr [ i ] is a ' good ' segment ; Function to find maximum possible AND ; Array to store prefix sums ; Maximum no of bits in the possible answer ; This will store the final answer ; Constructing answer greedily selecting from the higher most bit ; Checking if array can be partitioned such that the bitwise AND is ans | ( 1 << i ) ; if possible , update the answer ; Return the final answer ; Driver code ; n = 11 , first element is zero to make array 1 based indexing . So , number of elements are 10 ; Function call","```java
public static int maxAND(int[] arr, int k) {
    int n = arr.length;
    int[] prefixSum = new int[n + 1];
    for (int i = 1; i <= n; i++) {
      prefixSum[i] = prefixSum[i - 1] + arr[i - 1];
    }
    int maxBits = 31;
    int ans = 0;
    boolean[][] dp = new boolean[n + 1][k + 1];
    for (int i = 0; i <= n; i++) {
      dp[i][0] = true;
    }
    for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= k; j++) {
        for (int l = 0; l < i; l++) {
          if (dp[l][j - 1] && (prefixSum[i] - prefixSum[l]) == ((prefixSum[i] - prefixSum[l]) & -(prefixSum[i] - prefixSum[l]))) {
            dp[i][j] = true;
            break;
          }
        }
      }
    }
    for (int i = maxBits; i >= 0; i--) {
      if (dp[n][k] && (ans | (1 << i)) == (ans | (1 << i))) {
        ans = ans | (1 << i);
      }
    }
    return ans;
  }
  public static void main(String[] args) {
    int[] arr = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
    int k = 3;
    System.out.println(maxAND(arr, k));
  }
```","```python
def max_and_partition(arr, k):
  n = len(arr)
  prefix_sum = [0] * (n + 1)
  for i in range(1, n + 1):
    prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]
  max_bits = 31
  ans = 0
  dp = [[False for _ in range(k + 1)] for _ in range(n + 1)]
  for i in range(n + 1):
    dp[i][1] = True
  for i in range(2, n + 1):
    for j in range(2, min(i, k) + 1):
      for l in range(i - 1, -1, -1):
        if dp[l][j - 1] and (prefix_sum[i] - prefix_sum[l]) & ans == ans:
          dp[i][j] = True
          break
  for i in range(max_bits, -1, -1):
    if dp[n][k] and (ans | (1 << i)) & (prefix_sum[n] - prefix_sum[0]) == (ans | (1 << i)):
      ans |= (1 << i)
  return ans

n = 11
arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
k = 3
result = max_and_partition(arr, k)
print(result)
```"
344,"Cost Based Tower of Hanoi | Java implementation of the approach ; Function to initialize the dp table ; Initialize with maximum value ; Function to return the minimum cost ; Base case ; If problem is already solved , return the pre - calculated answer ; Number of the auxiliary disk ; Initialize the minimum cost as Infinity ; Calculationg the cost for first case ; Calculating the cost for second case ; Minimum of both the above cases ; Store it in the dp table ; Return the minimum cost ; Driver code","```java
public static int minCost(int n, int from, int to, int aux) {
    if (n == 1) {
        return 1;
    }
    if (dp[n][from][to][aux] != Integer.MAX_VALUE) {
        return dp[n][from][to][aux];
    }
    int auxDisk = 6 - from - to;
    int cost1 = minCost(n - 1, from, aux, to) + minCost(1, from, to, aux) + minCost(n - 1, aux, to, from);
    int cost2 = minCost(n - 1, from, to, aux) + minCost(1, from, aux, to) + minCost(n - 1, aux, to, from);
    dp[n][from][to][aux] = Math.min(cost1, cost2);
    return dp[n][from][to][aux];
}
```","```python
def minCost(n, cost):
  dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]
  for i in range(n + 1):
    for j in range(n + 1):
      dp[i][j] = float('inf')
  def solve(n, source, dest, aux):
    if n == 0:
      return 0
    if dp[n][source] != float('inf'):
      return dp[n][source]
    aux_disk = n - 1
    cost1 = solve(aux_disk, source, aux, dest) + cost[n - 1] + solve(aux_disk, aux, dest, source)
    cost2 = solve(aux_disk, source, dest, aux) + cost[n - 1] + solve(aux_disk, dest, aux, source)
    dp[n][source] = min(cost1, cost2)
    return dp[n][source]
  return solve(n, 1, 3, 2)
```"
345,"Minimum time required to rot all oranges | Dynamic Programming | Java implementation of the approach ; DP table to memoize the values ; Visited array to keep track of visited nodes in order to avoid infinite loops ; Function to return the minimum of four numbers ; Function to return the minimum distance to any rotten orange from [ i , j ] ; If i , j lie outside the array ; If 0 then it can 't lead to  any path so return INT_MAX ; If 2 then we have reached our rotten oranges so return from here ; If this node is already visited then return to avoid infinite loops ; Mark the current node as visited ; Check in all four possible directions ; Take the minimum of all ; If result already exists in the table check if min_value is less than existing value ; Function to return the minimum time required to rot all the oranges ; Calculate the minimum distances to any rotten orange from all the fresh oranges ; Pick the maximum distance of fresh orange to some rotten orange ; If all oranges can be rotten ; Driver Code","```java
class Solution {
    int[][] dp;
    boolean[][] visited;
    int[][] grid;
    int rows;
    int cols;

    public int orangesRotting(int[][] grid) {
        this.grid = grid;
        this.rows = grid.length;
        this.cols = grid[0].length;
        dp = new int[rows][cols];
        visited = new boolean[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        int maxDistance = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 1) {
                    int distance = minDistance(i, j);
                    if (distance == Integer.MAX_VALUE) {
                        return -1;
                    }
                    maxDistance = Math.max(maxDistance, distance);
                }
            }
        }
        return maxDistance;
    }

    public int minDistance(int i, int j) {
        if (i < 0 || i >= rows || j < 0 || j >= cols) {
            return Integer.MAX_VALUE;
        }
        if (grid[i][j] == 0) {
            return Integer.MAX_VALUE;
        }
        if (grid[i][j] == 2) {
            return 0;
        }
        if (visited[i][j]) {
            return dp[i][j];
        }
        visited[i][j] = true;
        int min = Math.min(minDistance(i + 1, j), minDistance(i - 1, j));
        min = Math.min(min, minDistance(i, j + 1));
        min = Math.min(min, minDistance(i, j - 1));
        if (dp[i][j] < min) {
            return dp[i][j];
        }
        dp[i][j] = min + 1;
        return dp[i][j];
    }
}
```","```python
import sys

def minOfFour(a, b, c, d):
  return min(a, min(b, min(c, d)))

def minDistance(grid, i, j, visited):
  if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):
    return sys.maxsize
  if grid[i][j] == 0:
    return sys.maxsize
  if grid[i][j] == 2:
    return 0
  if visited[i][j]:
    return sys.maxsize
  visited[i][j] = True
  up = minDistance(grid, i - 1, j, visited)
  down = minDistance(grid, i + 1, j, visited)
  left = minDistance(grid, i, j - 1, visited)
  right = minDistance(grid, i, j + 1, visited)
  return minOfFour(up, down, left, right) + 1

def orangesRotting(grid):
  rows = len(grid)
  cols = len(grid[0])
  dp = [[sys.maxsize for _ in range(cols)] for _ in range(rows)]
  visited = [[False for _ in range(cols)] for _ in range(rows)]
  maxDistance = 0
  for i in range(rows):
    for j in range(cols):
      if grid[i][j] == 1:
        distance = minDistance(grid, i, j, visited)
        if distance != sys.maxsize:
          dp[i][j] = distance
          maxDistance = max(maxDistance, distance)
  if maxDistance == sys.maxsize:
    return -1
  return maxDistance
```"
346,"Maximum sum of non | Java program to implement above approach ; Variable to store states of dp ; Variable to check if a given state has been solved ; Function to find the maximum sum subsequence such that no two elements are adjacent ; Base case ; To check if a state has been solved ; Variable to store prefix sum for sub - array { i , j } ; Required recurrence relation ; Returning the value ; Driver code ; Input array","```java
public static int maxSumNonAdjacent(int[] arr) {
    int n = arr.length;
    boolean[][] dp = new boolean[n][n];
    int[][] sum = new int[n][n];
    for (int i = 0; i < n; i++) {
        sum[i][i] = arr[i];
        for (int j = i + 1; j < n; j++) {
            sum[i][j] = sum[i][j - 1] + arr[j];
        }
    }
    return maxSumNonAdjacentUtil(arr, 0, n - 1, dp, sum);
}

private static int maxSumNonAdjacentUtil(int[] arr, int i, int j, boolean[][] dp, int[][] sum) {
    if (i > j) {
        return 0;
    }
    if (dp[i][j]) {
        return sum[i][j];
    }
    dp[i][j] = true;
    int include = arr[i] + maxSumNonAdjacentUtil(arr, i + 2, j, dp, sum);
    int exclude = maxSumNonAdjacentUtil(arr, i + 1, j, dp, sum);
    sum[i][j] = Math.max(include, exclude);
    return sum[i][j];
}
```","```python
def maxSumNonAdjacent(arr):
  n = len(arr)
  dp = [[-1 for _ in range(n + 1)] for _ in range(n + 1)]
  def solve(i, j):
    if i == n:
      return 0
    if dp[i][j] != -1:
      return dp[i][j]
    inc = arr[i] + solve(i + 2, j + 1)
    exc = solve(i + 1, j)
    dp[i][j] = max(inc, exc)
    return dp[i][j]
  return solve(0, 0)
```"
347,Maximum subset sum such that no two elements in set have same digit in them | Java implementation of above approach ; Function to create mask for every number ; Recursion for Filling DP array ; Base Condition ; Recurrence Relation ; Function to find Maximum Subset Sum ; Initialize DP array ; Iterate over all possible masks of 10 bit number ; Driver Code,"```java
import java.util.*;
class Solution {
    static int MAX = (int) 1e9 + 7;
    static int N = 10;
    static int[][] dp = new int[1024][100];
    public static int findMaxSubsetSum(int[] arr, int n) {
        Arrays.fill(dp, -1);
        int maxSum = 0;
        for (int mask = 0; mask < (1 << N); mask++) {
            maxSum = Math.max(maxSum, findMaxSumUtil(arr, n - 1, mask));
        }
        return maxSum;
    }
    public static int findMaxSumUtil(int[] arr, int i, int mask) {
        if (i == -1) {
            return 0;
        }
        if (dp[mask][i] != -1) {
            return dp[mask][i];
        }
        int exclude = findMaxSumUtil(arr, i - 1, mask);
        int include = 0;
        if (check(arr[i], mask)) {
            include = arr[i] + findMaxSumUtil(arr, i - 1, mask | createMask(arr[i]));
        }
        return dp[mask][i] = Math.max(exclude, include);
    }
    public static int createMask(int num) {
        int mask = 0;
        while (num > 0) {
            mask |= (1 << (num % 10));
            num /= 10;
        }
        return mask;
    }
    public static boolean check(int num, int mask) {
        while (num > 0) {
            if ((mask & (1 << (num % 10))) != 0) {
                return false;
            }
            num /= 10;
        }
        return true;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        System.out.println(findMaxSubsetSum(arr, n));
    }
}
```","```python
def maxSubsetSumNoCommonDigit(nums):
    n = len(nums)
    dp = [[0 for _ in range(1024)] for _ in range(n + 1)]
    for i in range(1, n + 1):
        for mask in range(1024):
            dp[i][mask] = dp[i - 1][mask]
            num = nums[i - 1]
            currentMask = createMask(num)
            if (mask & currentMask) == 0:
                dp[i][mask] = max(dp[i][mask], dp[i - 1][mask | currentMask] + num)
    return dp[n][0]

def createMask(num):
    mask = 0
    while num > 0:
        mask |= 1 << (num % 10)
        num //= 10
    return mask
```"
348,"Minimize the sum after choosing elements from the given three arrays | Java implementation of the above approach ; Function to return the minimized sum ; If all the indices have been used ; If this value is pre - calculated then return its value from dp array instead of re - computing it ; If A [ i - 1 ] was chosen previously then only B [ i ] or C [ i ] can chosen now choose the one which leads to the minimum sum ; If B [ i - 1 ] was chosen previously then only A [ i ] or C [ i ] can chosen now choose the one which leads to the minimum sum ; If C [ i - 1 ] was chosen previously then only A [ i ] or B [ i ] can chosen now choose the one which leads to the minimum sum ; Driver code ; Initialize the dp [ ] [ ] array ; min ( start with A [ 0 ] , start with B [ 0 ] , start with C [ 0 ] )","```java
public static int minimizeSum(int[] A, int[] B, int[] C, int n, int[][] dp) {
    if (n == 0) {
        return 0;
    }
    if (dp[n][0] != -1) {
        return dp[n][0];
    }
    dp[n][0] = Math.min(minimizeSum(A, B, C, n - 1, dp) + A[n - 1],
                       Math.min(minimizeSum(B, A, C, n - 1, dp) + B[n - 1],
                                minimizeSum(C, A, B, n - 1, dp) + C[n - 1]));
    return dp[n][0];
}
```","```python
def minSum(A, B, C, n):
  dp = [[[float('inf')] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]
  def recur(i, j, k):
    if i == n and j == n and k == n:
      return 0
    if dp[i][j][k] != float('inf'):
      return dp[i][j][k]
    if i < n:
      dp[i][j][k] = min(dp[i][j][k], A[i] + recur(i + 1, j, k))
    if j < n:
      dp[i][j][k] = min(dp[i][j][k], B[j] + recur(i, j + 1, k))
    if k < n:
      dp[i][j][k] = min(dp[i][j][k], C[k] + recur(i, j, k + 1))
    return dp[i][j][k]
  return min(recur(1, 0, 0), recur(0, 1, 0), recur(0, 0, 1))
```"
349,Maximise matrix sum by following the given Path | Java implementation of the approach ; To store the states of the DP ; Function to return the maximum of the three integers ; Function to return the maximum score ; Base cases ; If the state has already been solved then return it ; Marking the state as solved ; Growing phase ; } Shrinking phase ; Returning the solved state ; Driver code,"```java
public static int getMaxSum(int[][] matrix, int[][] dp, int row, int col) {
    if (row == 0 && col == 0) {
        return matrix[row][col];
    }
    if (dp[row][col] != -1) {
        return dp[row][col];
    }
    int max = 0;
    if (row > 0) {
        max = Math.max(max, getMaxSum(matrix, dp, row - 1, col));
    }
    if (col > 0) {
        max = Math.max(max, getMaxSum(matrix, dp, row, col - 1));
    }
    if (row > 0 && col > 0) {
        max = Math.max(max, getMaxSum(matrix, dp, row - 1, col - 1));
    }
    dp[row][col] = max + matrix[row][col];
    return dp[row][col];
}
```","```python
def maxSum(matrix, n, m):
  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
  def maxOfThree(a, b, c):
    return max(a, max(b, c))
  def solve(i, j):
    if i == 0 and j == 0:
      return matrix[i][j]
    if dp[i][j] != -1:
      return dp[i][j]
    dp[i][j] = 0
    if i > 0:
      dp[i][j] = maxOfThree(dp[i][j], solve(i - 1, j), 0)
    if j > 0:
      dp[i][j] = maxOfThree(dp[i][j], solve(i, j - 1), 0)
    dp[i][j] += matrix[i][j]
    return dp[i][j]
  for i in range(n + 1):
    for j in range(m + 1):
      dp[i][j] = -1
  return solve(n - 1, m - 1)
```"
350,"Find maximum topics to prepare in order to pass the exam | Java implementation of the approach ; Function to return the maximum marks by considering topics which can be completed in the given time duration ; If we are given 0 time then nothing can be done So all values are 0 ; If we are given 0 topics then the time required will be 0 for sure ; Calculating the maximum marks that can be achieved under the given time constraints ; If time taken to read that topic is more than the time left now at position j then do no read that topic ; Two cases arise : 1 ) Considering current topic 2 ) Ignoring current topic We are finding maximum of ( current topic weightage + topics which can be done in leftover time - current topic time ) and ignoring current topic weightage sum ; Moving upwards in table from bottom right to calculate the total time taken to read the topics which can be done in given time and have highest weightage sum ; It means we have not considered reading this topic for max weightage sum ; Adding the topic time ; Evaluating the left over time after considering this current topic ; One topic completed ; It contains the maximum weightage sum formed by considering the topics ; Condition when exam cannot be passed ; Return the marks that can be obtained after passing the exam ; Driver code ; Number of topics , hours left and the passing marks ; n + 1 is taken for simplicity in loops Array will be indexed starting from 1","```java
public static int maxMarks(int n, int hours, int[] topics, int[] times, int passMarks) {
    int[][] dp = new int[n + 1][hours + 1];
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= hours; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 0;
            } else if (times[i - 1] > j) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], topics[i - 1] + dp[i - 1][j - times[i - 1]]);
            }
        }
    }
    if (dp[n][hours] < passMarks) {
        return -1;
    }
    return dp[n][hours];
}
```","```python
def maxMarks(n, time, marks, topics):
  dp = [[0 for _ in range(time + 1)] for _ in range(n + 1)]
  for j in range(time + 1):
    dp[0][j] = 0
  for i in range(n + 1):
    dp[i][0] = 0
  for i in range(1, n + 1):
    for j in range(1, time + 1):
      if topics[i - 1] <= j:
        dp[i][j] = max(marks[i - 1] + dp[i - 1][j - topics[i - 1]], dp[i - 1][j])
      else:
        dp[i][j] = dp[i - 1][j]
  return dp[n][time]
```"
351,Minimize the number of steps required to reach the end of the array | Java implementation of the above approach ; variable to store states of dp ; variable to check if a given state has been solved ; Function to find the minimum number of steps required to reach the end of the array ; base case ; to check if a state has been solved ; required recurrence relation ; returning the value ; Driver code,"```java
public class Solution {
    private boolean[][] dp;
    private boolean[][] visited;

    public int minSteps(int[] arr) {
        int n = arr.length;
        dp = new boolean[n][n];
        visited = new boolean[n][n];
        return minStepsUtil(arr, 0, n - 1);
    }

    private int minStepsUtil(int[] arr, int start, int end) {
        if (start == end) {
            return 0;
        }
        if (visited[start][end]) {
            return dp[start][end] ? 1 : Integer.MAX_VALUE;
        }
        visited[start][end] = true;
        int minSteps = Integer.MAX_VALUE;
        for (int i = start + 1; i <= end; i++) {
            if (arr[i] >= arr[start]) {
                int steps = minStepsUtil(arr, i, end);
                if (steps != Integer.MAX_VALUE) {
                    minSteps = Math.min(minSteps, steps + 1);
                }
            }
        }
        dp[start][end] = minSteps != Integer.MAX_VALUE;
        return minSteps;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] arr = {1, 3, 2, 4, 5};
        int minSteps = sol.minSteps(arr);
        System.out.println(""Minimum steps required: "" + minSteps);
    }
}
```","```python
def minStepsToEnd(arr, n):
  dp = [0] * (n + 1)
  solved = [False] * (n + 1)
  def solve(index):
    if index == n:
      return 0
    if solved[index]:
      return dp[index]
    solved[index] = True
    minSteps = float('inf')
    for jump in range(1, arr[index] + 1):
      if index + jump <= n:
        minSteps = min(minSteps, 1 + solve(index + jump))
    dp[index] = minSteps
    return dp[index]
  return solve(0)
```"
352,"Optimal Strategy for a Game | Set 2 | Java program to find out maximum value from a given sequence of coins ; For both of your choices , the opponent gives you total sum minus maximum of his value ; Returns optimal value possible that a player can collect from an array of coins of size n . Note than n must be even ; Driver code","```java
public static int optimalStrategyOfGame(int[] arr, int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return arr[0];
    }
    int[][] dp = new int[n][n];
    for (int gap = 0; gap < n; ++gap) {
        for (int i = 0, j = gap; j < n; ++i, ++j) {
            if (gap == 0) {
                dp[i][j] = arr[i];
            } else if (gap == 1) {
                dp[i][j] = Math.max(arr[i], arr[j]);
            } else {
                dp[i][j] = Math.max(arr[i] + Math.min(dp[i + 2][j], dp[i + 1][j - 1]), arr[j] + Math.min(dp[i + 1][j - 1], dp[i][j - 2]));
            }
        }
    }
    return dp[0][n - 1];
}
```","```python
def optimal_strategy(coins):
  n = len(coins)
  dp = [[0 for _ in range(n)] for _ in range(n)]
  for gap in range(n):
    for j in range(gap, n):
      i = j - gap
      if gap == 0:
        dp[i][j] = coins[i]
      elif gap == 1:
        dp[i][j] = max(coins[i], coins[j])
      else:
        dp[i][j] = max(coins[i] + min(dp[i + 2][j], dp[i + 1][j - 1]), coins[j] + min(dp[i + 1][j - 1], dp[i][j - 2]))
  return dp[0][n - 1]
```"
353,Minimum number of sub | Java implementation of the approach ; Function that returns true if n is a power of 5 ; Function to return the decimal value of binary equivalent ; Function to return the minimum cuts required ; Alongocating memory for dp [ ] array ; From length 1 to n ; If previous character is '0' then ignore to avoid number with leading 0 s . ; Ignore s [ j ] = '0' starting numbers ; Number formed from s [ j ... . i ] ; Check for power of 5 ; Assigning min value to get min cut possible ; ( n + 1 ) to check if all the Strings are traversed and no divisible by 5 is obtained like 000000 ; Driver code,"```java
public class Solution {
    public static boolean isPowerOf5(int n) {
        if (n == 0) {
            return false;
        }
        while (n % 5 == 0) {
            n /= 5;
        }
        return n == 1;
    }
    public static int decimalValue(String s) {
        int decimal = 0;
        for (int i = 0; i < s.length(); i++) {
            decimal = decimal * 2 + (s.charAt(i) - '0');
        }
        return decimal;
    }
    public static int minimumCuts(String s) {
        int n = s.length();
        int[] dp = new int[n + 1];
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            if (s.charAt(i - 1) == '0') {
                continue;
            }
            dp[i] = n + 1;
            for (int j = i; j >= 1; j--) {
                if (s.charAt(j - 1) == '0') {
                    continue;
                }
                String sub = s.substring(j - 1, i);
                int decimal = decimalValue(sub);
                if (isPowerOf5(decimal)) {
                    dp[i] = Math.min(dp[i], dp[j - 1] + 1);
                }
            }
        }
        return dp[n] == n + 1 ? -1 : dp[n];
    }
    public static void main(String[] args) {
        String s = ""10101"";
        int minCuts = minimumCuts(s);
        System.out.println(minCuts);
    }
}
```","```python
def isPowerOfFive(n):
  if n <= 0:
    return False
  while n % 5 == 0:
    n //= 5
  return n == 1

def binaryToDecimal(binary):
  decimal = 0
  i = 0
  while binary != 0:
    digit = binary % 10
    decimal += digit * pow(2, i)
    binary //= 10
    i += 1
  return decimal

def minCuts(s):
  n = len(s)
  dp = [n + 1] * (n + 1)
  dp[0] = 0
  for i in range(1, n + 1):
    if s[i - 1] == '0':
      continue
    for j in range(i):
      if s[j] == '0':
        continue
      num = binaryToDecimal(int(s[j:i]))
      if isPowerOfFive(num):
        dp[i] = min(dp[i], dp[j] + 1)
  return dp[n]

if __name__ == ""__main__"":
  s = ""101101""
  print(minCuts(s))
```"
354,Minimum number of cubes whose sum equals to given number N | Java implementation of the approach ; Function to return the minimum number of cubes whose sum is k ; If k is less than the 2 ^ 3 ; Initialize with the maximum number of cubes required ; Driver code,"```java
public static int minCubes(int k) {
    if (k < 8) {
      return k;
    }
    int minCubes = Integer.MAX_VALUE;
    for (int i = 1; i * i * i <= k; i++) {
      minCubes = Math.min(minCubes, 1 + minCubes(k - i * i * i));
    }
    return minCubes;
  }
```","```python
def minCubes(k):
  if k < 2**3:
    return k
  dp = [float('inf')] * (k + 1)
  dp[0] = 0
  for i in range(1, k + 1):
    for j in range(1, i + 1):
      if j**3 <= i:
        dp[i] = min(dp[i], dp[i - j**3] + 1)
  return dp[k]
```"
355,Minimum number of cubes whose sum equals to given number N | Java implementation of the approach ; Function to return the minimum number of cubes whose sum is k ; While current perfect cube is less than current element ; If i is a perfect cube ; i = ( i - 1 ) + 1 ^ 3 ; Next perfect cube ; Re - initialization for next element ; Driver code,"```java
public static int minCubes(int k) {
    int count = 0;
    int i = 1;
    while (i <= k) {
        if (i * i * i == k) {
            return 1;
        }
        if (i * i * i <= k) {
            k -= i * i * i;
            count++;
        }
        i = (int) Math.pow(i + 1, 3);
    }
    return count;
}
```","```python
def min_cubes(k):
  count = 0
  i = 1
  while i <= k:
    if i**3 <= k:
      k -= i**3
      count += 1
      i = (i - 1) + 1**3
    else:
      i += 1
  return count
```"
356,Maximum Subarray Sum after inverting at most two elements | Java implementation of the approach ; Function to return the maximum required sub - array sum ; Creating one based indexing ; 2d array to contain solution for each step ; Case 1 : Choosing current or ( current + previous ) whichever is smaller ; Case 2 : ( a ) Altering sign and add to previous case 1 or value 0 ; Case 2 : ( b ) Adding current element with previous case 2 and updating the maximum ; Case 3 : ( a ) Altering sign and add to previous case 2 ; Case 3 : ( b ) Adding current element with previous case 3 ; Updating the maximum value of variable ans ; Return the final solution ; Driver code,"```java
public static int maxSubarraySum(int[] arr) {
    int n = arr.length;
    int[][] dp = new int[n + 1][4];
    int ans = Integer.MIN_VALUE;
    for (int i = 1; i <= n; i++) {
        dp[i][1] = Math.max(dp[i - 1][1], 0) + arr[i - 1];
        dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - arr[i - 1]);
        dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + arr[i - 1]);
        ans = Math.max(ans, Math.max(dp[i][1], Math.max(dp[i][2], dp[i][3])));
    }
    return ans;
}
```","```python
def maxSubarraySum(arr, n):
  dp = [[0 for _ in range(4)] for _ in range(n + 1)]
  ans = arr[0]
  for i in range(1, n + 1):
    dp[i][1] = max(arr[i - 1], dp[i - 1][1] + arr[i - 1])
    dp[i][2] = max(0, dp[i - 1][1] - arr[i - 1])
    dp[i][3] = max(dp[i - 1][2] + arr[i - 1], dp[i - 1][3] + arr[i - 1])
    ans = max(ans, dp[i][1], dp[i][2], dp[i][3])
  return ans
```"
357,"Maximum sum possible for a sub | Java implementation of the approach ; Function to return the maximum sum possible ; dp [ i ] represent the maximum sum so far after reaching current position i ; Initialize dp [ 0 ] ; Initialize the dp values till k since any two elements included in the sub - sequence must be atleast k indices apart , and thus first element and second element will be k indices apart ; Fill remaining positions ; Return the maximum sum ; Driver code","```java
public static int maxSum(int[] arr, int k) {
    int n = arr.length;
    int[] dp = new int[n];
    dp[0] = arr[0];
    for (int i = 1; i < k; i++) {
      dp[i] = Math.max(dp[i - 1], arr[i]);
    }
    for (int i = k; i < n; i++) {
      dp[i] = Math.max(dp[i - 1], dp[i - k] + arr[i]);
    }
    return dp[n - 1];
  }
```","```python
def maxSumSubsequence(arr, k):
  n = len(arr)
  dp = [0] * n
  dp[0] = arr[0]
  for i in range(1, min(k, n)):
    dp[i] = max(dp[i - 1], arr[i])
  for i in range(k, n):
    dp[i] = max(dp[i - 1], dp[i - k] + arr[i])
  return dp[n - 1]
```"
358,Minimum cost to form a number X by adding up powers of 2 | Java implementation of the approach ; Function to return the minimum cost ; Re - compute the array ; Add answers for set bits ; If bit is set ; Increase the counter ; Right shift the number ; Driver code,"```java
public static int minCostToFormNumber(int X) {
    int[] cost = new int[32];
    cost[0] = 0;
    for (int i = 1; i < 32; i++) {
        cost[i] = cost[i - 1] + 1;
    }
    int count = 0;
    int ans = 0;
    while (X != 0) {
        if ((X & 1) == 1) {
            ans += cost[count];
        }
        count++;
        X >>= 1;
    }
    return ans;
}
```","```python
def minCostToFormNumber(x):
  n = 32
  dp = [0] * n
  for i in range(n):
    dp[i] = i
  for i in range(n):
    for j in range(i):
      if (1 << j) & x:
        dp[i] = min(dp[i], dp[j] + dp[i - j - 1])
  return dp[n - 1]
```"
359,Ways to form an array having integers in given range such that total sum is divisible by 2 | Java implementation of the approach ; Function to return the number of ways to form an array of size n such that sum of all elements is divisible by 2 ; Represents first and last numbers of each type ( modulo 0 and 1 ) ; Count of numbers of each type between range ; Base Cases ; Ways to form array whose sum upto i numbers modulo 2 is 0 ; Ways to form array whose sum upto i numbers modulo 2 is 1 ; Return the required count of ways ; Driver Code,"```java
public static long countWays(int n, int start, int end) {
    long[][] dp = new long[n + 1][2];
    int count0 = (end - start) / 2 + (start % 2 == 0 ? 1 : 0);
    int count1 = (end - start) / 2 + (start % 2 == 1 ? 1 : 0);
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        dp[i][0] = dp[i - 1][1] * count1 + dp[i - 1][0] * count0;
        dp[i][1] = dp[i - 1][0] * count1 + dp[i - 1][1] * count0;
    }
    return dp[n][0];
}
```","```python
def count_arrays(n, a, b):
  dp = [[0 for _ in range(2)] for _ in range(n + 1)]
  dp[0][0] = 1
  for i in range(1, n + 1):
    even_count = (a // 2) + (b // 2) + ((a % 2) and (a >= b))
    odd_count = (a // 2) + (b // 2) + ((b % 2) and (a < b))
    dp[i][0] = dp[i - 1][0] * even_count + dp[i - 1][1] * odd_count
    dp[i][1] = dp[i - 1][0] * odd_count + dp[i - 1][1] * even_count
  return dp[n][0]
```"
360,Color N boxes using M colors such that K boxes have different color from the box on its left | Java Program to Paint N boxes using M colors such that K boxes have color different from color of box on its left ; This function returns the required number of ways where idx is the current index and diff is number of boxes having different color from box on its left ; Base Case ; If already computed ; Either paint with same color as previous one ; Or paint with remaining ( M - 1 ) colors ; Driver code ; Multiply M since first box can be painted with any of the M colors and start solving from 2 nd box,"```java
public static int paintBoxes(int N, int M, int K, int idx, int diff, int[][] dp) {
    if (idx == N) {
        return diff == K ? 1 : 0;
    }
    if (dp[idx][diff] != -1) {
        return dp[idx][diff];
    }
    int ans = 0;
    ans += paintBoxes(N, M, K, idx + 1, diff, dp);
    if (diff < K) {
        ans += (M - 1) * paintBoxes(N, M, K, idx + 1, diff + 1, dp);
    }
    dp[idx][diff] = ans;
    return ans;
}
```","```python
def color_boxes(n, m, k, idx, diff, dp):
  if idx == n:
    return 1 if diff == k else 0
  if dp[idx][diff] != -1:
    return dp[idx][diff]
  dp[idx][diff] = color_boxes(n, m, k, idx + 1, diff, dp) + (m - 1) * color_boxes(n, m, k, idx + 1, diff + 1, dp)
  return dp[idx][diff]

def count_ways(n, m, k):
  dp = [[-1 for _ in range(k + 1)] for _ in range(n + 1)]
  return m * color_boxes(n, m, k, 2, 0, dp)
```"
361,"Maximum path sum in an Inverted triangle | SET 2 | Java program implementation of Max sum problem in a triangle ; Function for finding maximum sum ; Loop for bottom - up calculation ; For each element , check both elements just below the number and below left to the number add the maximum of them to it ; Return the maximum sum ; Driver Code","```java
public static int maxPathSum(int[][] triangle) {
    int n = triangle.length;
    for (int i = n - 2; i >= 0; i--) {
      for (int j = 0; j <= i; j++) {
        triangle[i][j] += Math.max(triangle[i + 1][j], triangle[i + 1][j + 1]);
      }
    }
    return triangle[0][0];
  }
```","```python
def max_path_sum(triangle):
  for i in range(len(triangle) - 2, -1, -1):
    for j in range(len(triangle[i])):
      triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])
  return triangle[0][0]
```"
362,Count no . of ordered subsets having a particular XOR value | Java implementation of the approach ; Returns count of ordered subsets of arr [ ] with XOR value = K ; Find maximum element in arr [ ] ; Maximum possible XOR value ; The value of dp [ i ] [ j ] [ k ] is the number of subsets of length k having XOR of their elements as j from the set arr [ 0. . . i - 1 ] ; Initializing all the values of dp [ i ] [ j ] [ k ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subsets of all lengths from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver code,"```java
public static int countSubsets(int[] arr, int k) {
    int n = arr.length;
    int max = 0;
    for (int i = 0; i < n; i++) {
        max = Math.max(max, arr[i]);
    }
    int maxXor = (1 << (Integer.toBinaryString(max).length())) - 1;
    int[][][] dp = new int[n + 1][maxXor + 1][n + 1];
    dp[0][0][0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= maxXor; j++) {
            for (int l = 1; l <= n; l++) {
                dp[i][j][l] = dp[i - 1][j][l];
                if (l > 0) {
                    dp[i][j][l] += dp[i - 1][j ^ arr[i - 1]][l - 1];
                }
            }
        }
    }
    int count = 0;
    for (int l = 1; l <= n; l++) {
        count += dp[n][k][l];
    }
    return count;
}
```","```python
def count_subsets_xor(arr, k):
  n = len(arr)
  max_element = max(arr)
  max_xor = (1 << (len(bin(max_element)) - 2)) - 1
  dp = [[[0 for _ in range(n + 1)] for _ in range(max_xor + 1)] for _ in range(n + 1)]
  dp[0][0][0] = 1
  for i in range(1, n + 1):
    for j in range(max_xor + 1):
      for k in range(1, i + 1):
        dp[i][j][k] = dp[i - 1][j][k]
        if j ^ arr[i - 1] <= max_xor:
          dp[i][j][k] += dp[i - 1][j ^ arr[i - 1]][k - 1]
  return sum(dp[n][k][i] for i in range(1, n + 1))
```"
363,"Possible cuts of a number such that maximum parts are divisible by 3 | Java program to find the maximum number of numbers divisible by 3 in large number ; This will contain the count of the splits ; This will keep sum of all successive integers , when they are indivisible by 3 ; This is the condition of finding a split ; Driver code","```java
public static int maxDivisibleBy3(int num) {
  int count = 0;
  int sum = 0;
  for (int i = 1; i <= num; i++) {
    sum += i;
    if (sum % 3 == 0) {
      count++;
      sum = 0;
    }
  }
  return count;
}
```","```python
def max_divisible_by_three(n):
  count = 0
  sum = 0
  for i in range(1, n + 1):
    sum += i
    if sum % 3 == 0:
      count += 1
      sum = 0
  return count
```"
364,"Count of Numbers in a Range where digit d occurs exactly K times | Java Program to find the count of numbers in a range where digit d occurs exactly K times ; states - position , count , tight , nonz ; d is required digit and K is occurrence ; This function returns the count of required numbers from 0 to num ; Last position ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; Nonz is true if we placed a non zero digit at the starting of the number ; At this position , number becomes smaller ; Next recursive call , also set nonz to 1 if current digit is non zero ; Function to convert x into its digit vector and uses count ( ) function to return the required count ; Initialize dp ; Driver Code to test above functions","```java
public class CountOfNumbers {

    static int[][] dp = new int[10][10];

    public static int count(int num, int d, int k) {
        if (num == 0) {
            return 0;
        }
        if (dp[num][k] != -1) {
            return dp[num][k];
        }
        int ans = 0;
        int pos = 0;
        int count = 0;
        int tight = 1;
        int nonz = 0;
        while (num > 0) {
            int digit = num % 10;
            num /= 10;
            if (digit == d) {
                count++;
            }
            if (digit != 0) {
                nonz = 1;
            }
            pos++;
        }
        for (int i = 0; i <= 9; i++) {
            if (i == d && count + 1 <= k) {
                ans += count(num, d, k - 1, pos, count + 1, tight, nonz);
            } else if (i != d && count <= k) {
                ans += count(num, d, k, pos, count, tight, nonz);
            }
            if (tight == 1 && i != d) {
                ans += count(num, d, k, pos, count, 0, nonz);
            }
        }
        dp[num][k] = ans;
        return ans;
    }

    public static int count(int num, int d, int k, int pos, int count, int tight, int nonz) {
        if (pos == 0) {
            if (count == k && nonz == 1) {
                return 1;
            }
            return 0;
        }
        int limit = tight == 1 ? 9 : num % 10;
        int ans = 0;
        for (int i = 0; i <= limit; i++) {
            if (i == d && count + 1 <= k) {
                ans += count(num / 10, d, k - 1, pos - 1, count + 1, tight || i < limit, nonz || i != 0);
            } else if (i != d && count <= k) {
                ans += count(num / 10, d, k, pos - 1, count, tight || i < limit, nonz || i != 0);
            }
        }
        return ans;
    }

    public static int countNumbers(int num, int d, int k) {
        for (int i = 0; i <= 10; i++) {
            for (int j = 0; j <= 10; j++) {
                dp[i][j] = -1;
            }
        }
        return count(num, d, k);
    }

    public static void main(String[] args) {
        int num = 1234;
        int d = 2;
        int k = 1;
        int count = countNumbers(num, d, k);
        System.out.println(count); // Output: 4
    }
}
```","```python
def count(num, d, k):
    dp = [[[0 for _ in range(2)] for _ in range(11)] for _ in range(11)]
    def count_helper(pos, count, tight, nonz):
        if pos == 10:
            if count == k:
                return 1
            return 0
        if dp[pos][count][tight] != -1:
            return dp[pos][count][tight]
        limit = 9 if tight else int(num[pos])
        ans = 0
        for i in range(limit + 1):
            new_count = count + (i == d)
            new_tight = tight or (i < limit)
            new_nonz = nonz or (i != 0)
            ans += count_helper(pos + 1, new_count, new_tight, new_nonz)
        dp[pos][count][tight] = ans
        return ans
    num = str(num)
    for i in range(10):
        for j in range(11):
            for k in range(2):
                dp[i][j][k] = -1
    return count_helper(0, 0, 0, 0)

def count_numbers(num, d, k):
    return count(num, d, k)

def main():
    for _ in range(int(input())):
        num, d, k = map(int, input().split())
        print(count_numbers(num, d, k))

if __name__ == ""__main__"":
    main()
```"
365,Count of Numbers in Range where first digit is equal to last digit of the number | Java program to implement the above approach ; Base Case ; Calculating the last digit ; Calculating the first digit ; Driver code,"```java
static int countInRange(int low, int high) {
    int count = 0;
    for (int i = low; i <= high; i++) {
      if (i < 10) {
        count++;
      } else {
        int lastDigit = i % 10;
        int firstDigit = i;
        while (firstDigit >= 10) {
          firstDigit /= 10;
        }
        if (firstDigit == lastDigit) {
          count++;
        }
      }
    }
    return count;
  }
```","```python
def count_numbers_in_range(low, high):
  count = 0
  for num in range(low, high + 1):
    if num < 10:
      count += 1
    else:
      last_digit = num % 10
      temp = num
      while temp >= 10:
        temp //= 10
      first_digit = temp
      if first_digit == last_digit:
        count += 1
  return count
```"
366,"Form N | Java code to find minimum cost to form a N - copy string ; Returns the minimum cost to form a n - copy string Here , x -> Cost to add \/ remove a single character ' G ' and y -> cost to append the string to itself ; Base Case : to form a 1 - copy string we need to perform an operation of type 1 ( i . e Add ) ; Case1 . Perform a Add operation on ( i - 1 ) - copy string , Case2 . Perform a type 2 operation on ( ( i + 1 ) \/ 2 ) - copy string ; Case1 . Perform a Add operation on ( i - 1 ) - copy string , Case2 . Perform a type 3 operation on ( i \/ 2 ) - copy string ; Driver Code","```java
public int minCost(int n, int x, int y) {
    if (n == 1) {
        return x;
    }
    int[] dp = new int[n + 1];
    dp[1] = x;
    for (int i = 2; i <= n; i++) {
        dp[i] = Math.min(dp[i - 1] + x, dp[i / 2] + (i % 2 == 0 ? y : x));
    }
    return dp[n];
}
```","```python
def minCost(n, x, y):
  dp = [0] * (n + 1)
  dp[1] = x
  for i in range(2, n + 1):
    dp[i] = min(dp[i - 1] + x, dp[i // 2] + y if i % 2 == 0 else dp[(i + 1) // 2] + y)
  return dp[n]
```"
367,"Minimum steps to reach any of the boundary edges of a matrix | Set 1 | Java program to find Minimum steps to reach any of the boundary edges of a matrix ; Function to find out minimum steps ; boundary edges reached ; already had a route through this point , hence no need to re - visit ; visiting a position ; vertically up ; horizontally right ; horizontally left ; vertically down ; minimum of every path ; Function that returns the minimum steps ; index to store the location at which you are standing ; find '2' in the matrix ; Initialize dp matrix with - 1 ; Initialize vis matrix with false ; Call function to find out minimum steps using memoization and recursion ; if not possible ; Driver Code","```java
public static int minSteps(int[][] grid, int x, int y, int[][] dp, boolean[][] vis) {
    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || vis[x][y] || grid[x][y] == 0) {
        return Integer.MAX_VALUE;
    }
    if (x == 0 || x == grid.length - 1 || y == 0 || y == grid[0].length - 1) {
        return 0;
    }
    vis[x][y] = true;
    int up = minSteps(grid, x - 1, y, dp, vis);
    int right = minSteps(grid, x, y + 1, dp, vis);
    int left = minSteps(grid, x, y - 1, dp, vis);
    int down = minSteps(grid, x + 1, y, dp, vis);
    vis[x][y] = false;
    dp[x][y] = Math.min(Math.min(up, right), Math.min(left, down)) + 1;
    return dp[x][y];
}

public static int minStepsToReachBoundary(int[][] grid) {
    int n = grid.length;
    int m = grid[0].length;
    int[][] dp = new int[n][m];
    for (int i = 0; i < n; i++) {
        Arrays.fill(dp[i], -1);
    }
    boolean[][] vis = new boolean[n][m];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 2) {
                int minSteps = minSteps(grid, i, j, dp, vis);
                return minSteps == Integer.MAX_VALUE ? -1 : minSteps;
            }
        }
    }
    return -1;
}

public static void main(String[] args) {
    int[][] grid = {
            {1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1},
            {1, 1, 2, 1, 1, 1},
            {1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 1}
    };
    int minSteps = minStepsToReachBoundary(grid);
    System.out.println(minSteps);
}
```","```python
def minStepsToReachBoundary(matrix):
  rows = len(matrix)
  cols = len(matrix[0])
  dp = [[-1 for _ in range(cols)] for _ in range(rows)]
  vis = [[False for _ in range(cols)] for _ in range(rows)]
  for i in range(rows):
    for j in range(cols):
      if matrix[i][j] == 2:
        return findMinSteps(matrix, i, j, rows, cols, dp, vis)
  return -1

def findMinSteps(matrix, i, j, rows, cols, dp, vis):
  if i == 0 or j == 0 or i == rows - 1 or j == cols - 1:
    return 0
  if vis[i][j]:
    return dp[i][j]
  vis[i][j] = True
  up = float('inf')
  right = float('inf')
  left = float('inf')
  down = float('inf')
  if i > 0:
    up = findMinSteps(matrix, i - 1, j, rows, cols, dp, vis) + 1
  if j < cols - 1:
    right = findMinSteps(matrix, i, j + 1, rows, cols, dp, vis) + 1
  if j > 0:
    left = findMinSteps(matrix, i, j - 1, rows, cols, dp, vis) + 1
  if i < rows - 1:
    down = findMinSteps(matrix, i + 1, j, rows, cols, dp, vis) + 1
  dp[i][j] = min(up, right, left, down)
  return dp[i][j]
```"
368,Count the number of special permutations | Java program to count the number of required permutations ; Function to return the number of ways to choose r objects out of n objects ; Function to return the number of derangements of n ; Function to return the required number of permutations ; Ways to choose i indices from n indices ; Dearangements of ( n - i ) indices System . out . println ( ans ) ; ; Driver Code to test above functions,"```java
public static long countSpecialPermutations(int n, int r) {
    long ans = 0;
    for (int i = 0; i <= r; i++) {
      ans += choose(n, i) * derangements(n - i);
    }
    return ans;
  }
  
  public static long choose(int n, int r) {
    if (r > n) {
      return 0;
    }
    if (r == 0 || r == n) {
      return 1;
    }
    return choose(n - 1, r - 1) + choose(n - 1, r);
  }
  
  public static long derangements(int n) {
    if (n == 0) {
      return 1;
    }
    if (n == 1) {
      return 0;
    }
    return (n - 1) * (derangements(n - 1) + derangements(n - 2));
  }
  
  public static void main(String[] args) {
    int n = 5;
    int r = 3;
    long ans = countSpecialPermutations(n, r);
    System.out.println(ans);
  }
```","```python
def nCr(n, r):
  return 1 if r == 0 or r == n else nCr(n - 1, r - 1) + nCr(n - 1, r)

def derangements(n):
  if n == 0:
    return 1
  if n == 1:
    return 0
  return (n - 1) * (derangements(n - 1) + derangements(n - 2))

def countSpecialPermutations(n):
  ans = 0
  for i in range(n + 1):
    ans += nCr(n, i) * derangements(n - i)
  return ans

n = int(input())
print(countSpecialPermutations(n))
```"
369,"Paths with maximum number of ' a ' from ( 1 , 1 ) to ( X , Y ) vertically or horizontally | Java program to find paths with maximum number of ' a ' from ( 1 , 1 ) to ( X , Y ) vertically or horizontally ; Function to answer queries ; Iterate till query ; Decrease to get 0 - based indexing ; Print answer ; Function that pre - computes the dp array ; Check fo the first character ; Iterate in row and columns ; If not first row or not first column ; Not first row ; Not first column ; If it is not ' a ' then increase by 1 ; Driver code ; character N X N array ; queries ; number of queries ; function call to pre - compute ; function call to answer every query","```java
public static int[][] dp;

public static void preCompute(char[][] grid) {
    dp = new int[grid.length][grid[0].length];
    if (grid[0][0] == 'a') {
        dp[0][0] = 1;
    }
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (i != 0 || j != 0) {
                if (i != 0) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
                }
                if (j != 0) {
                    dp[i][j] = Math.max(dp[i][j], dp[i][j - 1]);
                }
                if (grid[i][j] != 'a') {
                    dp[i][j]++;
                }
            }
        }
    }
}

public static int answerQuery(int x, int y) {
    return dp[x - 1][y - 1];
}

public static void main(String[] args) {
    char[][] grid = {
        {'a', 'b', 'c'},
        {'d', 'a', 'e'},
        {'f', 'g', 'a'}
    };
    int queries = 3;
    preCompute(grid);
    for (int i = 0; i < queries; i++) {
        int x = 3;
        int y = 3;
        x--;
        y--;
        System.out.println(answerQuery(x, y));
    }
}
```","```python
def answerQueries(n, x, y, grid, dp):
  for _ in range(queries):
    x, y = map(int, input().split())
    x -= 1
    y -= 1
    print(dp[x][y])

def preCompute(n, grid, dp):
  if grid[0][0] != 'a':
    dp[0][0] = 1
  for i in range(n):
    for j in range(n):
      if i != 0 or j != 0:
        if i != 0:
          dp[i][j] = max(dp[i][j], dp[i - 1][j])
        if j != 0:
          dp[i][j] = max(dp[i][j], dp[i][j - 1])
        if grid[i][j] != 'a':
          dp[i][j] += 1

n = int(input())
grid = []
for _ in range(n):
  grid.append(list(input()))
queries = int(input())
dp = [[0 for _ in range(n)] for _ in range(n)]
preCompute(n, grid, dp)
answerQueries(n, n, n, grid, dp)
```"
370,Ways to place K bishops on an NÃ — N chessboard so that no two attack | Java implementation of the approach ; returns the number of squares in diagonal i ; returns the number of ways to fill a n * n chessboard with k bishops so that no two bishops attack each other . ; return 0 if the number of valid places to be filled is less than the number of bishops ; dp table to store the values ; Setting the base conditions ; calculate the required number of ways ; stores the answer ; Driver code,"```java
public static int countWays(int n, int k) {
    int[][] dp = new int[n + 1][k + 1];
    for (int i = 0; i <= n; i++) {
        dp[i][0] = 1;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= k; j++) {
            if (i - j >= 0) {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * (i - j);
            }
        }
    }
    return dp[n][k];
}
```","```python
def count_bishop_arrangements(n, k):
  def diagonal_size(i):
    return min(i + 1, n - i, n)

  dp = [[0 for _ in range(k + 1)] for _ in range(n * n + 1)]
  for i in range(n * n + 1):
    dp[i][0] = 1
  for i in range(1, n * n + 1):
    for j in range(1, k + 1):
      if i < j:
        dp[i][j] = 0
      else:
        dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * diagonal_size(i - 1)
  return dp[n * n][k]
```"
371,Number of ways to partition a string into two balanced subsequences | Java implementation of the approach ; For maximum length of input string ; Declaring the DP table ; Declaring the prefix array ; Function to calculate the number of valid assignments ; Return 1 if X is balanced . ; Increment the count if it an opening bracket ; Decrement the count if it a closing bracket ; Driver code ; Initializing the DP table ; Creating the prefix array ; Initial value for c_x and c_y is zero,"```java
public static long countWays(String s) {
    int n = s.length();
    long[][] dp = new long[n + 1][n + 1];
    int[] prefix = new int[n + 1];
    for (int i = 1; i <= n; i++) {
        prefix[i] = prefix[i - 1] + (s.charAt(i - 1) == '(' ? 1 : -1);
    }
    for (int i = 0; i <= n; i++) {
        dp[i][0] = 1;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (isBalanced(prefix[i], prefix[j])) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[n][n];
}

private static boolean isBalanced(int c_x, int c_y) {
    return c_x == 0 && c_y == 0;
}
```","```python
def count_partitions(s):
    n = len(s)
    dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
    prefix = [0 for _ in range(n + 1)]
    for i in range(1, n + 1):
        prefix[i] = prefix[i - 1]
        if s[i - 1] == '(':
            prefix[i] += 1
        else:
            prefix[i] -= 1
    for i in range(n + 1):
        dp[i][0] = 1
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if prefix[i] == prefix[j]:
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[n][n]
```"
372,"Minimum sum falling path in a NxN grid | Java Program to minimum required sum ; Function to return minimum path falling sum ; R = Row and C = Column We begin from second last row and keep adding maximum sum . ; best = min ( A [ R + 1 ] [ C - 1 ] , A [ R + 1 ] [ C ] , A [ R + 1 ] [ C + 1 ] ) ; Driver program ; function to print required answer","```java
public static int minFallingPathSum(int[][] A) {
    int R = A.length;
    int C = A[0].length;
    for (int r = R - 2; r >= 0; r--) {
      for (int c = 0; c < C; c++) {
        int best = A[r + 1][c];
        if (c > 0) {
          best = Math.min(best, A[r + 1][c - 1]);
        }
        if (c < C - 1) {
          best = Math.min(best, A[r + 1][c + 1]);
        }
        A[r][c] += best;
      }
    }
    int minSum = A[0][0];
    for (int c = 1; c < C; c++) {
      minSum = Math.min(minSum, A[0][c]);
    }
    return minSum;
  }
```","```python
def minFallingPathSum(A):
  R = len(A)
  C = len(A[0])
  for r in range(R - 2, -1, -1):
    for c in range(C):
      A[r][c] += min(A[r + 1][max(0, c - 1)], A[r + 1][c], A[r + 1][min(C - 1, c + 1)])
  return min(A[0])
```"
373,Find the maximum sum of Plus shape pattern in a 2 | Java program to find the maximum value of a + shaped pattern in 2 - D array ; Function to return maximum Plus value ; Initializing answer with the minimum value ; Initializing all four arrays ; Initializing left and up array . ; Initializing right and down array . ; calculating value of maximum Plus ( + ) sign ; Driver code ; Function call to find maximum value,"```java
public static int maxPlus(int[][] arr) {
    int n = arr.length;
    int m = arr[0].length;
    int ans = Integer.MIN_VALUE;
    int[][] left = new int[n][m];
    int[][] up = new int[n][m];
    int[][] right = new int[n][m];
    int[][] down = new int[n][m];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0) {
                left[i][j] = arr[i][j];
            } else {
                left[i][j] = arr[i][j] + left[i - 1][j];
            }
            if (j == 0) {
                up[i][j] = arr[i][j];
            } else {
                up[i][j] = arr[i][j] + up[i][j - 1];
            }
        }
    }
    for (int i = n - 1; i >= 0; i--) {
        for (int j = m - 1; j >= 0; j--) {
            if (i == n - 1) {
                right[i][j] = arr[i][j];
            } else {
                right[i][j] = arr[i][j] + right[i + 1][j];
            }
            if (j == m - 1) {
                down[i][j] = arr[i][j];
            } else {
                down[i][j] = arr[i][j] + down[i][j + 1];
            }
        }
    }
    for (int i = 1; i < n - 1; i++) {
        for (int j = 1; j < m - 1; j++) {
            int val = arr[i][j] + left[i - 1][j] + up[i][j - 1] + right[i + 1][j] + down[i][j + 1] - 3 * arr[i][j];
            ans = Math.max(ans, val);
        }
    }
    return ans;
}
```","```python
def findMaxPlus(arr):
  n = len(arr)
  m = len(arr[0])
  ans = -1e9
  left = [[0 for _ in range(m)] for _ in range(n)]
  up = [[0 for _ in range(m)] for _ in range(n)]
  right = [[0 for _ in range(m)] for _ in range(n)]
  down = [[0 for _ in range(m)] for _ in range(n)]
  for i in range(n):
    for j in range(m):
      if i == 0:
        up[i][j] = arr[i][j]
      else:
        up[i][j] = up[i - 1][j] + arr[i][j]
      if j == 0:
        left[i][j] = arr[i][j]
      else:
        left[i][j] = left[i][j - 1] + arr[i][j]
  for i in range(n - 1, -1, -1):
    for j in range(m - 1, -1, -1):
      if i == n - 1:
        down[i][j] = arr[i][j]
      else:
        down[i][j] = down[i + 1][j] + arr[i][j]
      if j == m - 1:
        right[i][j] = arr[i][j]
      else:
        right[i][j] = right[i][j + 1] + arr[i][j]
  for i in range(1, n - 1):
    for j in range(1, m - 1):
      ans = max(ans, arr[i][j] + left[i][j - 1] + right[i][j + 1] + up[i - 1][j] + down[i + 1][j] - 3 * arr[i][j])
  return ans
```"
374,"Total number of different staircase that can made from N boxes | Java program to find the total number of different staircase that can made from N boxes ; Function to find the total number of different staircase that can made from N boxes ; DP table , there are two states . First describes the number of boxes and second describes the step ; Initialize all the elements of the table to zero ; Base case ; When step is equal to 2 ; When step is greater than 2 ; Count the total staircase from all the steps ; Driver Code","```java
public static int countStaircase(int N) {
    int[][] dp = new int[N + 1][N + 1];
    for (int i = 0; i <= N; i++) {
      for (int j = 0; j <= N; j++) {
        dp[i][j] = 0;
      }
    }
    for (int i = 1; i <= N; i++) {
      dp[i][1] = 1;
    }
    for (int i = 2; i <= N; i++) {
      dp[i][2] = 1;
    }
    for (int i = 3; i <= N; i++) {
      for (int j = 3; j <= N; j++) {
        for (int k = 1; k < j; k++) {
          dp[i][j] += dp[i - k][k];
        }
      }
    }
    int count = 0;
    for (int i = 1; i <= N; i++) {
      count += dp[N][i];
    }
    return count;
  }
```","```python
def count_staircase(n):
  dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
  for i in range(1, n + 1):
    for j in range(1, n + 1):
      if j == 1:
        dp[i][j] = 1
      elif j == 2:
        dp[i][j] = 2
      elif i >= j:
        dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j]
  return dp[n][n]
```"
375,Find maximum points which can be obtained by deleting elements from array | Java program to find maximum cost after deleting all the elements form the array ; function to return maximum cost obtained ; find maximum element of the array . ; initialize count of all elements to zero . ; calculate frequency of all elements of array . ; stores cost of deleted elements . ; selecting minimum range from L and R . ; finds upto which elements are to be deleted when element num is selected . ; get maximum when selecting element num or not . ; Driver program ; size of array ; function call to find maximum cost,"```java
public static int findMaxCost(int[] arr, int n) {
    int max = 0;
    for (int i = 0; i < n; i++) {
      max = Math.max(max, arr[i]);
    }
    int[] count = new int[max + 1];
    for (int i = 0; i < n; i++) {
      count[arr[i]]++;
    }
    int[] cost = new int[max + 1];
    for (int i = 1; i <= max; i++) {
      cost[i] = i * count[i];
    }
    int L = 0;
    int R = max;
    int maxCost = 0;
    while (L <= R) {
      int mid = (L + R) / 2;
      int deletedElements = 0;
      for (int i = 1; i <= mid; i++) {
        deletedElements += count[i];
      }
      int currentCost = cost[mid] + (n - deletedElements) * mid;
      if (currentCost > maxCost) {
        maxCost = currentCost;
      }
      if (deletedElements == n) {
        R = mid - 1;
      } else {
        L = mid + 1;
      }
    }
    return maxCost;
  }
```","```python
def maxCost(arr, n):
  max_ele = max(arr)
  freq = [0] * (max_ele + 1)
  for i in range(n):
    freq[arr[i]] += 1
  cost = 0
  for num in range(max_ele + 1):
    if freq[num] > 0:
      L = num
      R = max_ele
      while L <= R:
        mid = (L + R) // 2
        count = 0
        for i in range(num, mid + 1):
          count += freq[i]
        if count <= num:
          L = mid + 1
        else:
          R = mid - 1
      cost = max(cost, num * (R + 1))
  return cost

n = int(input())
arr = list(map(int, input().split()))
print(maxCost(arr, n))
```"
376,Count the number of ways to traverse a Matrix | Java program using recursive solution to count number of ways to reach mat [ m - 1 ] [ n - 1 ] from mat [ 0 ] [ 0 ] in a matrix mat [ ] [ ] ; Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Return 1 if it is the first row or first column ; Recursively find the no of way to reach the last cell . ; Driver Code,"```java
public int countWays(int[][] mat, int m, int n) {
    if (m == 1 || n == 1) {
      return 1;
    }
    return countWays(mat, m - 1, n) + countWays(mat, m, n - 1);
  }
```","```python
def count_ways(mat, m, n):
  if m == 0 or n == 0:
    return 1
  return count_ways(mat, m - 1, n) + count_ways(mat, m, n - 1)
```"
377,Count the number of ways to traverse a Matrix | A simple recursive solution to count number of ways to reach mat [ m - 1 ] [ n - 1 ] from mat [ 0 ] [ 0 ] in a matrix mat [ ] [ ] ; Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Driver code,"```java
public int countWays(int[][] mat, int m, int n) {
    if (m == 0 && n == 0) {
        return 1;
    }
    if (m < 0 || n < 0) {
        return 0;
    }
    return countWays(mat, m - 1, n) + countWays(mat, m, n - 1);
}
```","```python
def count_ways(mat, m, n):
  if m == 0 and n == 0:
    return 1
  if m < 0 or n < 0:
    return 0
  return count_ways(mat, m - 1, n) + count_ways(mat, m, n - 1) 
```"
378,"Number of ways a convex polygon of n + 2 sides can split into triangles by connecting vertices | Java program to find the nth catalan number ; Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] \/ [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn \/ ( n + 1 ) ; Driver code","```java
public static int binomialCoefficient(int n, int k) {
    if (k > n - k) {
      k = n - k;
    }
    long result = 1;
    for (int i = 0; i < k; i++) {
      result *= (n - i);
      result /= (i + 1);
    }
    return (int) result;
  }

  public static int catalanNumber(int n) {
    return binomialCoefficient(2 * n, n) / (n + 1);
  }

  public static void main(String[] args) {
    int n = 5;
    System.out.println(catalanNumber(n));
  }
```","```python
def catalan(n):
  def binomialCoeff(n, k):
    if k > n:
      return 0
    if k == 0 or k == n:
      return 1
    return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k)
  return binomialCoeff(2 * n, n) // (n + 1)
```"
379,Alternate Fibonacci Numbers | Alternate Fibonacci Series using Dynamic Programming ; 0 th and 1 st number of the series are 0 and 1 ; Driver Code,"```java
public static int alternateFibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (i % 2 == 0) {
            dp[i] = dp[i - 1];
        } else {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
    }
    return dp[n];
}
```","```python
def alternate_fibonacci(n):
  dp = [0] * (n + 1)
  dp[0] = 0
  dp[1] = 1
  for i in range(2, n + 1):
    if i % 2 == 0:
      dp[i] = dp[i - 1] + dp[i - 2]
    else:
      dp[i] = dp[i - 1]
  return dp[n]
```"
380,"Number of ways to form an array with distinct adjacent elements | Java program to count the number of ways to form arrays of N numbers such that the first and last numbers are fixed and all consecutive numbers are distinct ; Returns the total ways to form arrays such that every consecutive element is different and each element except the first and last can take values from 1 to M ; define the dp [ ] [ ] array ; if the first element is 1 ; there is only one way to place a 1 at the first index ; the value at first index needs to be 1 , thus there is no way to place a non - one integer ; if the first element was 1 then at index 1 , only non one integer can be placed thus there are M - 1 ways to place a non one integer at index 2 and 0 ways to place a 1 at the 2 nd index ; Else there is one way to place a one at index 2 and if a non one needs to be placed here , there are ( M - 2 ) options , i . e neither the element at this index should be 1 , neither should it be equal to the previous element ; Build the dp array in bottom up manner ; f ( i , one ) = f ( i - 1 , non - one ) ; f ( i , non - one ) = f ( i - 1 , one ) * ( M - 1 ) + f ( i - 1 , non - one ) * ( M - 2 ) ; last element needs to be one , so return dp [ n - 1 ] [ 0 ] ; Driver Code","```java
public static long countWays(int n, int m, int first, int last) {
    long[][] dp = new long[n][2];
    if (first == 1) {
      dp[0][0] = 1;
      dp[0][1] = 0;
    } else {
      dp[0][0] = 0;
      dp[0][1] = 1;
    }
    for (int i = 1; i < n; i++) {
      dp[i][0] = dp[i - 1][1];
      dp[i][1] = dp[i - 1][0] * (m - 1) + dp[i - 1][1] * (m - 2);
    }
    return dp[n - 1][0];
  }
```","```python
def countWays(n, m, first):
    dp = [[0 for _ in range(2)] for _ in range(n)]
    if first == 1:
        dp[0][0] = 1
        dp[0][1] = 0
    else:
        dp[0][0] = 0
        dp[0][1] = 1
    for i in range(1, n):
        dp[i][0] = dp[i - 1][1]
        dp[i][1] = dp[i - 1][0] * (m - 1) + dp[i - 1][1] * (m - 2)
    return dp[n - 1][0]
```"
381,"Memoization ( 1D , 2D and 3D ) | Java program to find the Nth term of Fibonacci series ; Fibonacci Series using Recursion ; Base case ; recursive calls ; Driver Code","```java
public class Fibonacci {

    static int[] memoization1D;

    public static int fibonacciRecursive(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
    }

    public static int fibonacciMemoization1D(int n) {
        if (n <= 1) {
            return n;
        }
        if (memoization1D[n] != -1) {
            return memoization1D[n];
        }
        memoization1D[n] = fibonacciMemoization1D(n - 1) + fibonacciMemoization1D(n - 2);
        return memoization1D[n];
    }

    public static int fibonacciMemoization2D(int n) {
        int[][] memoization2D = new int[n + 1][2];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j < 2; j++) {
                memoization2D[i][j] = -1;
            }
        }
        if (n <= 1) {
            return n;
        }
        if (memoization2D[n][0] != -1) {
            return memoization2D[n][0];
        }
        memoization2D[n][0] = fibonacciMemoization2D(n - 1) + fibonacciMemoization2D(n - 2);
        return memoization2D[n][0];
    }

    public static int fibonacciMemoization3D(int n) {
        int[][][] memoization3D = new int[n + 1][2][2];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < 2; k++) {
                    memoization3D[i][j][k] = -1;
                }
            }
        }
        if (n <= 1) {
            return n;
        }
        if (memoization3D[n][0][0] != -1) {
            return memoization3D[n][0][0];
        }
        memoization3D[n][0][0] = fibonacciMemoization3D(n - 1) + fibonacciMemoization3D(n - 2);
        return memoization3D[n][0][0];
    }

    public static void main(String[] args) {
        int n = 10;
        memoization1D = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            memoization1D[i] = -1;
        }
        System.out.println(""Fibonacci Series (Recursive): "" + fibonacciRecursive(n));
        System.out.println(""Fibonacci Series (Memoization 1D): "" + fibonacciMemoization1D(n));
        System.out.println(""Fibonacci Series (Memoization 2D): "" + fibonacciMemoization2D(n));
        System.out.println(""Fibonacci Series (Memoization 3D): "" + fibonacciMemoization3D(n));
    }
}
```","```python
def fibonacci(n, memo={}):
  if n in memo:
    return memo[n]
  if n <= 1:
    return n
  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)
  return memo[n]
```"
382,"Memoization ( 1D , 2D and 3D ) | Java program to find the Nth term of Fibonacci series ; Fibonacci Series using memoized Recursion ; base case ; if fib ( n ) has already been computed we do not do further recursive calls and hence reduce the number of repeated work ; store the computed value of fib ( n ) in an array term at index n to so that it does not needs to be precomputed again ; Driver Code","```java
public class FibonacciMemoization {

    static int[] term;

    public static int fib(int n) {
        if (n <= 1) {
            return n;
        }
        if (term[n] != -1) {
            return term[n];
        }
        term[n] = fib(n - 1) + fib(n - 2);
        return term[n];
    }

    public static void main(String[] args) {
        int n = 10;
        term = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            term[i] = -1;
        }
        System.out.println(fib(n));
    }
}
```","```python
def fib(n, term):
  if n <= 1:
    return n
  if term[n] != -1:
    return term[n]
  term[n] = fib(n - 1, term) + fib(n - 2, term)
  return term[n]
```"
383,"Memoization ( 1D , 2D and 3D ) | A Naive recursive implementation of LCS problem ; Utility function to get max of 2 integers ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Driver Code","```java
public static int lcs(String X, String Y, int m, int n) {
    if (m == 0 || n == 0) {
        return 0;
    }
    if (X.charAt(m - 1) == Y.charAt(n - 1)) {
        return 1 + lcs(X, Y, m - 1, n - 1);
    }
    return max(lcs(X, Y, m, n - 1), lcs(X, Y, m - 1, n));
}

public static int max(int a, int b) {
    return (a > b) ? a : b;
}
```","```python
def lcs(X, Y, m, n):
    if m == 0 or n == 0:
        return 0
    elif X[m - 1] == Y[n - 1]:
        return 1 + lcs(X, Y, m - 1, n - 1)
    else:
        return max(lcs(X, Y, m, n - 1), lcs(X, Y, m - 1, n))

def max(a, b):
    return a if a > b else b
```"
384,Smallest number with given sum of digits and sum of square of digits | Java program to find the Smallest number with given sum of digits and sum of square of digits ; Top down dp to find minimum number of digits with given sum of dits a and sum of square of digits as b ; Invalid condition ; Number of digits satisfied ; Memoization ; Initialize ans as maximum as we have to find the minimum number of digits ; Check for all possible combinations of digits ; recurrence call ; If the combination of digits cannot give sum as a and sum of square of digits as b ; Returns the minimum number of digits ; Function to print the digits that gives sum as a and sum of square of digits as b ; initialize the dp array as - 1 ; base condition ; function call to get the minimum number of digits ; When there does not exists any number ; Printing the digits from the most significant digit ; Trying all combinations ; checking conditions for minimum digits ; Driver Code ; Function call to print the smallest number,"```java
public static int findMinDigits(int a, int b) {
    int[][] dp = new int[a + 1][b + 1];
    for (int i = 0; i <= a; i++) {
        for (int j = 0; j <= b; j++) {
            dp[i][j] = -1;
        }
    }
    return findMinDigitsUtil(a, b, dp);
}

public static int findMinDigitsUtil(int a, int b, int[][] dp) {
    if (a == 0 && b == 0) {
        return 0;
    }
    if (a < 0 || b < 0) {
        return Integer.MAX_VALUE;
    }
    if (dp[a][b] != -1) {
        return dp[a][b];
    }
    int ans = Integer.MAX_VALUE;
    for (int i = 0; i <= 9; i++) {
        ans = Math.min(ans, 1 + findMinDigitsUtil(a - i, b - i * i, dp));
    }
    dp[a][b] = ans;
    return ans;
}

public static void printDigits(int a, int b) {
    int[][] dp = new int[a + 1][b + 1];
    for (int i = 0; i <= a; i++) {
        for (int j = 0; j <= b; j++) {
            dp[i][j] = -1;
        }
    }
    int minDigits = findMinDigitsUtil(a, b, dp);
    if (minDigits == Integer.MAX_VALUE) {
        System.out.println(""No such number exists"");
        return;
    }
    int sum = a;
    int sumSq = b;
    for (int i = 9; i >= 0; i--) {
        while (sum >= i && sumSq >= i * i && dp[sum - i][sumSq - i * i] == minDigits - 1) {
            System.out.print(i);
            sum -= i;
            sumSq -= i * i;
            minDigits--;
        }
    }
}

public static void main(String[] args) {
    int a = 10;
    int b = 30;
    printDigits(a, b);
}
```","```python
def find_smallest_number(a, b):
    dp = [[-1 for _ in range(b + 1)] for _ in range(a + 1)]
    def helper(a, b):
        if a == 0 and b == 0:
            return 0
        if a <= 0 or b <= 0:
            return float('inf')
        if dp[a][b] != -1:
            return dp[a][b]
        ans = float('inf')
        for i in range(1, 10):
            if a - i >= 0 and b - i * i >= 0:
                ans = min(ans, 1 + helper(a - i, b - i * i))
        dp[a][b] = ans
        return ans
    for i in range(a + 1):
        for j in range(b + 1):
            dp[i][j] = -1
    min_digits = helper(a, b)
    if min_digits == float('inf'):
        return -1
    def print_digits(a, b):
        if a == 0 and b == 0:
            return
        for i in range(1, 10):
            if a - i >= 0 and b - i * i >= 0 and dp[a - i][b - i * i] == dp[a][b] - 1:
                print(i, end="""")
                print_digits(a - i, b - i * i)
                return
    print_digits(a, b)
    return min_digits

a = 10
b = 30
min_digits = find_smallest_number(a, b)
if min_digits == -1:
    print(""There does not exist any number"")
else:
    print(f""Minimum number of digits required: {min_digits}"")
```"
385,"Sum of product of consecutive Binomial Coefficients | Java Program to find sum of product of consecutive Binomial Coefficient . ; Find the binomial coefficient up to nth term ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Return the sum of the product of consecutive binomial coefficient . ; Driver Code","```java
public static int sumOfProductOfConsecutiveBinomialCoefficients(int n) {
    int[][] C = new int[n + 1][n + 1];
    C[0][0] = 1;
    for (int i = 1; i <= n; i++) {
      C[i][0] = 1;
      for (int j = 1; j <= i; j++) {
        C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
      }
    }
    int sum = 0;
    for (int i = 1; i <= n; i++) {
      sum += C[n][i] * C[n][i - 1];
    }
    return sum;
  }
```","```python
def sum_of_product_of_consecutive_binomial_coefficients(n):
  C = [0] * (n + 1)
  C[0] = 1
  for i in range(1, n + 1):
    for j in range(i, 0, -1):
      C[j] += C[j - 1]
  sum = 0
  for i in range(1, n):
    sum += C[i] * C[i - 1]
  return sum
```"
386,Check if array sum can be made K by three operations on it | Java Program to find if Array can have a sum of K by applying three types of possible operations on it ; Check if it is possible to achieve a sum with three operation allowed . ; If sum is negative . ; If going out of bound . ; If sum is achieved . ; If the current state is not evaluated yet . ; Replacing element with negative value of the element . ; Substracting index number from the element . ; Adding index number to the element . ; Wrapper Function ; Driver Code,"```java
class Solution {
    boolean[][][] dp;
    int n;
    int k;
    int[] arr;

    public boolean canSum(int[] arr, int k) {
        this.arr = arr;
        this.k = k;
        this.n = arr.length;
        dp = new boolean[n + 1][k + 1][3];
        return helper(0, 0, 0);
    }

    private boolean helper(int index, int sum, int op) {
        if (sum < 0) {
            return false;
        }
        if (index == n) {
            return sum == k;
        }
        if (sum == k) {
            return true;
        }
        if (dp[index][sum][op]) {
            return false;
        }
        dp[index][sum][op] = true;
        boolean res = helper(index + 1, sum + arr[index], op) || helper(index + 1, sum - arr[index], op) || helper(index + 1, sum + index, op) || helper(index + 1, sum - index, op) || helper(index + 1, sum + arr[index] * -1, op) || helper(index + 1, sum, op + 1);
        return res;
    }
}
```","```python
def can_sum_be_k(arr, k, n, dp):
  if sum(arr) == k:
    return True
  if sum(arr) < 0 or n < 0:
    return False
  if dp[n][sum(arr)] != -1:
    return dp[n][sum(arr)]
  dp[n][sum(arr)] = (can_sum_be_k(arr[:n], k, n - 1, dp) or
                    can_sum_be_k(arr[:n], k, n - 1, dp) or
                    can_sum_be_k(arr[:n], k, n - 1, dp))
  return dp[n][sum(arr)]

def check_sum_k(arr, k):
  n = len(arr)
  dp = [[-1 for i in range(k + 1)] for j in range(n + 1)]
  return can_sum_be_k(arr, k, n, dp)

arr = [1, 2, 3]
k = 6
if check_sum_k(arr, k):
  print(""Yes"")
else:
  print(""No"")
```"
387,Print Fibonacci sequence using 2 variables | Simple Java Program to print Fibonacci sequence ; Driver code,"```java
public static void printFibonacci(int n) {
    int a = 0;
    int b = 1;
    for (int i = 0; i < n; i++) {
        System.out.print(a + "" "");
        int temp = a;
        a = b;
        b = temp + b;
    }
}
```","```python
def fibonacci(n):
  a = 0
  b = 1
  for i in range(n):
    print(a, end="" "")
    a, b = b, a + b
```"
388,Maximum sum increasing subsequence from a prefix and a given element after prefix is must | Java program to find maximum sum increasing subsequence tiint i - th index and including k - th index . ; Initializing the first row of the dp [ ] [ ] . ; Creating the dp [ ] [ ] matrix . ; To calculate for i = 4 and k = 6. ; Driver code,"```java
public static int maxSumIncreasingSubsequence(int[] arr, int n, int k) {
    int[][] dp = new int[n + 1][n + 1];
    for (int i = 0; i <= n; i++) {
      dp[i][0] = 0;
    }
    for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= n; j++) {
        if (i == j) {
          dp[i][j] = arr[i - 1];
        } else if (arr[i - 1] > arr[j - 1]) {
          dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][i] + arr[j - 1]);
        } else {
          dp[i][j] = dp[i - 1][j];
        }
      }
    }
    return dp[n][k];
  }
```","```python
def max_sum_increasing_subsequence(arr, n, k):
  dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
  for i in range(n + 1):
    dp[i][0] = 0
  for i in range(1, n + 1):
    for j in range(1, n + 1):
      if i == j:
        dp[i][j] = arr[i - 1]
      elif arr[i - 1] > arr[j - 1]:
        dp[i][j] = max(dp[i - 1][j], arr[i - 1] + dp[i - 1][i])
      else:
        dp[i][j] = dp[i - 1][j]
  return dp[n][k]
```"
389,Moser | Java code to generate first ' n ' terms of the Moser - de Bruijn Sequence ; Function to generate nth term of Moser - de Bruijn Sequence ; S ( 2 * n ) = 4 * S ( n ) ; S ( 2 * n + 1 ) = 4 * S ( n ) + 1 ; Generating the first ' n ' terms of Moser - de Bruijn Sequence ; Driver Code,"```java
public static int[] generateMoserDeBruijnSequence(int n) {
    int[] sequence = new int[n];
    for (int i = 0; i < n; i++) {
      sequence[i] = calculateMoserDeBruijnTerm(i + 1);
    }
    return sequence;
  }

  private static int calculateMoserDeBruijnTerm(int n) {
    if (n == 1) {
      return 1;
    } else if (n % 2 == 0) {
      return 4 * calculateMoserDeBruijnTerm(n / 2);
    } else {
      return 4 * calculateMoserDeBruijnTerm((n - 1) / 2) + 1;
    }
  }
```","```python
def moser_de_bruijn(n):
  result = []
  for i in range(1, n + 1):
    if i % 2 == 0:
      result.append(4 * moser_de_bruijn(i // 2))
    else:
      result.append(4 * moser_de_bruijn((i - 1) // 2) + 1)
  return result
```"
390,"Longest Common Substring ( Space optimized DP solution ) | Space optimized CPP implementation of longest common substring . ; Function to find longest common substring . ; Find length of both the strings . ; Variable to store length of longest common substring . ; Matrix to store result of two consecutive rows at a time . ; Variable to represent which row of matrix is current row . ; For a particular value of i and j , len [ currRow ] [ j ] stores length of longest common substring in string X [ 0. . i ] and Y [ 0. . j ] . ; Make current row as previous row and previous row as new current row . ; Driver Code","```java
public static int longestCommonSubstring(String X, String Y) {
    int n = X.length();
    int m = Y.length();
    int maxLength = 0;
    int[][] len = new int[2][m + 1];
    int currRow = 0;
    for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= m; j++) {
        if (X.charAt(i - 1) == Y.charAt(j - 1)) {
          len[currRow][j] = len[1 - currRow][j - 1] + 1;
          maxLength = Math.max(maxLength, len[currRow][j]);
        } else {
          len[currRow][j] = 0;
        }
      }
      currRow = 1 - currRow;
    }
    return maxLength;
  }
```","```python
def longestCommonSubstring(X, Y):
  m = len(X)
  n = len(Y)
  lcs = 0
  dp = [[0 for _ in range(n + 1)] for _ in range(2)]
  currRow = 0
  prevRow = 1
  for i in range(1, m + 1):
    for j in range(1, n + 1):
      if X[i - 1] == Y[j - 1]:
        dp[currRow][j] = dp[prevRow][j - 1] + 1
        lcs = max(lcs, dp[currRow][j])
      else:
        dp[currRow][j] = 0
    currRow, prevRow = prevRow, currRow
  return lcs
```"
391,"Minimal moves to form a string by adding characters or appending string itself | Java program to print the Minimal moves to form a string by appending string and adding characters ; function to return the minimal number of moves ; initializing dp [ i ] to INT_MAX ; initialize both strings to null ; base case ; check if it can be appended ; addition of character takes one step ; appending takes 1 step , and we directly reach index i * 2 + 1 after appending so the number of steps is stord in i * 2 + 1 ; Driver Code ; function call to return minimal number of moves","```java
public static int minMoves(String s1, String s2) {
    int n = s1.length();
    int[] dp = new int[2 * n + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    for (int i = 0; i < n; i++) {
        if (i < n && s1.charAt(i) == s2.charAt(i)) {
            dp[i + 1] = dp[i];
        }
        if (i * 2 + 1 < 2 * n && s1.substring(0, i + 1).equals(s2.substring(0, i * 2 + 1))) {
            dp[i * 2 + 1] = dp[i] + 1;
        }
        if (i + 1 < 2 * n) {
            dp[i + 1] = Math.min(dp[i + 1], dp[i] + 1);
        }
    }
    return dp[n];
}
```","```python
def minMoves(s1, s2):
  n = len(s1)
  m = len(s2)
  dp = [float('inf')] * (m + 1)
  dp[0] = 0
  for i in range(n):
    for j in range(m):
      if s1[i] == s2[j]:
        dp[j + 1] = min(dp[j + 1], dp[j])
      dp[j + 1] = min(dp[j + 1], dp[j] + 1)
    dp[i * 2 + 1] = min(dp[i * 2 + 1], dp[i] + 1)
  return dp[m]
```"
392,Check if any valid sequence is divisible by M | Java program for the above approach ; Function to check if any valid sequence is divisible by M ; Declare mod array ; Calculate the mod array ; Check if sum is divisible by M ; Check if sum is not divisible by 2 ; Remove the first element from the ModArray since it is not possible to place minus on the first element ; Decrease the size of array ; Sort the array ; Loop until the pointer cross each other ; Check if sum becomes equal ; Increase and decrease the pointer accordingly ; Driver code ; Function call,"```java
public static boolean checkDivisible(int[] arr, int M) {
    int[] mod = new int[arr.length];
    for (int i = 0; i < arr.length; i++) {
      mod[i] = arr[i] % M;
    }
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
      sum += arr[i];
    }
    if (sum % M == 0) {
      return true;
    }
    if (sum % 2 != 0) {
      return false;
    }
    mod = Arrays.copyOfRange(mod, 1, mod.length);
    Arrays.sort(mod);
    int left = 0;
    int right = mod.length - 1;
    while (left < right) {
      if (mod[left] + mod[right] == M) {
        return true;
      } else if (mod[left] + mod[right] < M) {
        left++;
      } else {
        right--;
      }
    }
    return false;
  }
```","```python
def check_sequence(arr, M):
  mod = [0] * len(arr)
  for i in range(len(arr)):
    mod[i] = arr[i] % M
  if sum(mod) % M == 0 and sum(mod) % 2 != 0:
    return True
  mod.pop(0)
  n = len(mod)
  mod.sort()
  l = 0
  r = n - 1
  while l < r:
    if mod[l] + mod[r] == M:
      return True
    elif mod[l] + mod[r] < M:
      l += 1
    else:
      r -= 1
  return False
```"
393,Golomb sequence | Java Program to find first n terms of Golomb sequence . ; Print the first n term of Golomb Sequence ; base cases ; Finding and printing first n terms of Golomb Sequence . ; Driver code,"```java
public static void golombSequence(int n) {
    int[] a = new int[n + 1];
    a[1] = 1;
    for (int i = 2; i <= n; i++) {
      a[i] = 1 + a[i - a[a[i - 1]]];
    }
    for (int i = 1; i <= n; i++) {
      System.out.print(a[i] + "" "");
    }
  }
```","```python
def golomb_sequence(n):
  sequence = [1]
  for i in range(1, n):
    sequence.append(sequence.count(i) + 1)
  return sequence
```"
394,Balanced expressions such that given positions have opening brackets | Java code to find number of ways of arranging bracket with proper expressions ; function to calculate the number of proper bracket sequence ; hash array to mark the positions of opening brackets ; dp 2d array ; mark positions in hash array ; first position marked as 1 ; iterate and formulate the recurrences ; if position has a opening bracket ; return answer ; Driver code ; positions where opening braces will be placed,"```java
public static int countBracketArrangements(int n, int[] positions) {
    int[][] dp = new int[n + 1][n + 1];
    boolean[] hasOpeningBracket = new boolean[n + 1];
    for (int pos : positions) {
      hasOpeningBracket[pos] = true;
    }
    dp[0][0] = 1;
    for (int i = 1; i <= n; i++) {
      for (int j = 0; j <= i; j++) {
        if (j > 0 && hasOpeningBracket[i]) {
          dp[i][j] = dp[i - 1][j - 1];
        }
        if (j < i) {
          dp[i][j] += dp[i - 1][j];
        }
      }
    }
    return dp[n][n / 2];
  }
```","```python
def count_bracket_arrangements(n, positions):
  hash_array = [0] * (n + 1)
  for pos in positions:
    hash_array[pos] = 1
  dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
  dp[0][0] = 1
  for i in range(1, n + 1):
    for j in range(i + 1):
      if hash_array[i] == 1:
        dp[i][j] = dp[i - 1][j - 1]
      else:
        dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]
  return dp[n][n // 2]
```"
395,Maximum difference of zeros and ones in binary string | Set 2 ( O ( n ) time ) | Java Program to find the length of substring with maximum difference of zeroes and ones in binary string . ; Find the length of substring with maximum difference of zeros and ones in binary string ; traverse a binary string from left to right ; add current value to the current_sum according to the Character if it ' s ▁ ' 0 ' add 1 else -1 ; update maximum sum ; return - 1 if string does not contain any zero that means string contains all ones otherwise max_sum ; Driven Program,"```java
public static int maxLenOfSubStr(String str) {
    int current_sum = 0;
    int max_sum = Integer.MIN_VALUE;
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) == '0') {
            current_sum += 1;
        } else {
            current_sum -= 1;
        }
        max_sum = Math.max(max_sum, current_sum);
    }
    if (max_sum < 0) {
        return -1;
    }
    return max_sum;
}
```","```python
def max_diff_zeros_ones(string):
  current_sum = 0
  max_sum = 0
  for char in string:
    if char == '0':
      current_sum += 1
    else:
      current_sum -= 1
    max_sum = max(max_sum, current_sum)
  if '0' not in string:
    return -1
  return max_sum
```"
396,"Number of decimal numbers of length k , that are strict monotone | Java program to count numbers of k digits that are strictly monotone . ; DP [ i ] [ j ] is going to store monotone numbers of length i + 1 considering j + 1 digits ( 1 , 2 , 3 , . .9 ) ; Unit length numbers ; Building dp [ ] in bottom up ; Driver code","```java
public static int countMonotoneNumbers(int k) {
    int[][] dp = new int[k][10];
    for (int i = 0; i < 10; i++) {
        dp[0][i] = 1;
    }
    for (int i = 1; i < k; i++) {
        for (int j = 0; j < 10; j++) {
            for (int l = 0; l <= j; l++) {
                dp[i][j] += dp[i - 1][l];
            }
        }
    }
    int count = 0;
    for (int i = 0; i < 10; i++) {
        count += dp[k - 1][i];
    }
    return count;
}
```","```python
def count_monotone_numbers(k):
  dp = [[0 for _ in range(10)] for _ in range(k)]
  for i in range(10):
    dp[0][i] = 1
  for i in range(1, k):
    for j in range(10):
      for l in range(j):
        dp[i][j] += dp[i - 1][l]
  count = 0
  for i in range(10):
    count += dp[k - 1][i]
  return count
```"
397,Count ways to divide circle using N non | Java code to count ways to divide circle using N non - intersecting chords . ; n = no of points required ; dp array containing the sum ; returning the required number ; Driver function,"```java
public static int countWays(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - j - 1];
        }
    }
    return dp[n];
}
```","```python
def count_ways(n):
  dp = [0] * (n + 1)
  dp[0] = 1
  dp[1] = 1
  for i in range(2, n + 1):
    for j in range(i):
      dp[i] += dp[j] * dp[i - j - 1]
  return dp[n]
```"
398,Check for possible path in 2D matrix | Java program to find if there is path from top left to right bottom ; to find the path from top left to bottom right ; set arr [ 0 ] [ 0 ] = 1 ; Mark reachable ( from top left ) nodes in first row and first column . ; Mark reachable nodes in remaining matrix . ; return yes if right bottom index is 1 ; Driver code ; Given array ; path from arr [ 0 ] [ 0 ] to arr [ row ] [ col ],"```java
public static boolean findPath(int[][] arr) {
    int row = arr.length;
    int col = arr[0].length;
    if (arr[0][0] == 0) {
        return false;
    }
    arr[0][0] = 1;
    for (int i = 1; i < col; i++) {
        if (arr[0][i] == 1 && arr[0][i - 1] == 1) {
            arr[0][i] = 1;
        }
    }
    for (int i = 1; i < row; i++) {
        if (arr[i][0] == 1 && arr[i - 1][0] == 1) {
            arr[i][0] = 1;
        }
    }
    for (int i = 1; i < row; i++) {
        for (int j = 1; j < col; j++) {
            if (arr[i][j] == 1 && (arr[i - 1][j] == 1 || arr[i][j - 1] == 1)) {
                arr[i][j] = 1;
            }
        }
    }
    return arr[row - 1][col - 1] == 1;
}
```","```python
def is_path_possible(arr, row, col):
  if arr[0][0] == 0:
    return False
  for i in range(row):
    arr[i][0] = arr[i][0] * arr[i - 1][0]
  for j in range(col):
    arr[0][j] = arr[0][j] * arr[0][j - 1]
  for i in range(1, row):
    for j in range(1, col):
      if arr[i][j] == 1:
        arr[i][j] = arr[i - 1][j] * arr[i][j - 1] * arr[i][j]
  return arr[row - 1][col - 1] == 1
```"
399,Newmanâ €“ Shanksâ €“ Williams prime | Java Program to find Newman - Shanks - Williams prime ; return nth Newman - Shanks - Williams prime ; Base case ; Recursive step ; Driver code,"```java
public static long nswPrime(long n) {
    if (n == 1) {
        return 2;
    } else {
        return 2 * nswPrime(n - 1) + 1;
    }
}
```","```python
def newman_shanks_williams_prime(n):
  if n == 1:
    return 2
  else:
    return 2 * newman_shanks_williams_prime(n - 1) + 1
```"
400,Newman Shanks Williams prime | Java Program for finding Newman - Shanks - Williams prime ; return nth Newman_Shanks_Williams prime ; Base case ; Finding nth Newman Shanks Williams prime ; Driver Program,"```java
public static int newmanShanksWilliamsPrime(int n) {
    if (n == 1) {
      return 2;
    }
    int count = 1;
    int number = 3;
    while (count < n) {
      number += 2;
      if (isPrime(number)) {
        count++;
      }
    }
    return number;
  }
  private static boolean isPrime(int number) {
    if (number <= 1) {
      return false;
    }
    for (int i = 2; i * i <= number; i++) {
      if (number % i == 0) {
        return false;
      }
    }
    return true;
  }
```","```python
def newman_shanks_williams_prime(n):
  if n == 1:
    return 2
  i = 1
  count = 1
  while count < n:
    i += 1
    if all(i % j for j in range(2, int(i**0.5) + 1)):
      count += 1
  return i
```"
401,Number of ways to insert a character to increase the LCS by one | Java Program for Number of ways to insert a character to increase LCS by one ; Return the Number of ways to insert a character to increase the Longest Common Subsequence by one ; Insert all positions of all characters in string B . ; Longest Common Subsequence ; Longest Common Subsequence from reverse ; inserting character between position i and i + 1 ; Driver Code,"```java
public static int countWaysToIncreaseLCS(String A, String B) {
    int n = A.length();
    int m = B.length();
    int[][] dp = new int[n + 1][m + 1];
    int[][] dpRev = new int[n + 1][m + 1];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (A.charAt(i - 1) == B.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    for (int i = n; i >= 1; i--) {
        for (int j = m; j >= 1; j--) {
            if (A.charAt(i - 1) == B.charAt(j - 1)) {
                dpRev[i][j] = dpRev[i + 1][j + 1] + 1;
            } else {
                dpRev[i][j] = Math.max(dpRev[i + 1][j], dpRev[i][j + 1]);
            }
        }
    }
    int count = 0;
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            if (dp[i][j] + 1 == dp[n][m]) {
                if (i == 0 || j == 0 || dpRev[i + 1][j + 1] + 1 == dp[n][m]) {
                    count++;
                }
            }
        }
    }
    return count;
}
```","```python
def count_ways_to_increase_lcs(A, B):
  n = len(A)
  m = len(B)
  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
  for i in range(1, n + 1):
    for j in range(1, m + 1):
      if A[i - 1] == B[j - 1]:
        dp[i][j] = dp[i - 1][j - 1] + 1
      else:
        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
  dp_rev = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
  for i in range(1, n + 1):
    for j in range(1, m + 1):
      if A[n - i] == B[m - j]:
        dp_rev[i][j] = dp_rev[i - 1][j - 1] + 1
      else:
        dp_rev[i][j] = max(dp_rev[i - 1][j], dp_rev[i][j - 1])
  count = 0
  for i in range(m):
    if dp[n][i + 1] == dp[n][i] + 1:
      count += 1
  for i in range(m):
    if dp_rev[n][i + 1] == dp_rev[n][i] + 1:
      count += 1
  return count
```"
402,Find the winner of game of repeatedly removing the first character to empty given string | Java program to implement the above approach ; Function to find the winner of a game of repeatedly removing the first character to empty a String ; Store characters of each String of the array arr [ ] ; Stores count of Strings in arr [ ] ; Traverse the array arr [ ] ; Stores length of current String ; Traverse the String ; Insert arr [ i ] [ j ] ; 1 st Player starts the game ; Stores the player number for the next turn ; Remove 1 st character of current String ; Update player number for the next turn ; Driver Code,"```java
public static String findWinner(String[] arr) {
    int n = arr.length;
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < arr[i].length(); j++) {
        arr[i] = arr[i].substring(1);
        if (i % 2 == 0) {
          i = (i + 1) % n;
        } else {
          i = (i - 1 + n) % n;
        }
      }
    }
    return arr[0].isEmpty() ? ""Player 2"" : ""Player 1"";
  }
```","```python
def findWinner(arr):
  n = len(arr)
  for i in range(n):
    for j in range(len(arr[i])):
      arr[i] = arr[i][1:]
      if len(arr[i]) == 0:
        return i + 1
      i = (i + 1) % n
  return -1
```"
403,Longest Substring that can be made a palindrome by swapping of characters | Java program for the above approach ; Function to find the Longest substring that can be made a palindrome by swapping of characters ; Initialize dp array of size 1024 ; Initializeing dp array with length of s ; Initializing mask and res ; Traverse the string ; Find the mask of the current character ; Finding the length of the longest substring in s which is a palindrome for even count ; Finding the length of the longest substring in s which is a palindrome for one odd count ; Finding maximum length of substring having one odd count ; dp [ mask ] is minimum of current i and dp [ mask ] ; Return longest length of the substring which forms a palindrome with swaps ; Driver Code ; Input String ; Function Call,"```java
public static int longestPalindromeSubstring(String s) {
    int[] dp = new int[1024];
    for (int i = 0; i < s.length(); i++) {
      dp[i] = i + 1;
    }
    int mask = 0;
    int res = 0;
    for (int i = 0; i < s.length(); i++) {
      mask ^= 1 << (s.charAt(i) - 'a');
      int even = dp[mask];
      int odd = 0;
      for (int j = 0; j < 26; j++) {
        if ((mask & (1 << j)) != 0) {
          odd = Math.max(odd, dp[mask ^ (1 << j)]);
        }
      }
      int maxOdd = Math.max(odd, res);
      dp[mask] = Math.min(i + 1, dp[mask]);
      res = Math.max(res, Math.max(even, maxOdd));
    }
    return res;
  }
```","```python
def longestPalindrome(s):
  dp = [0] * 1024
  for i in range(len(s)):
    dp[i] = i + 1
  mask = 0
  res = 0
  for i in range(len(s)):
    mask ^= 1 << (ord(s[i]) - ord('a'))
    even = dp[mask]
    odd = dp[mask ^ (1 << (ord(s[i]) - ord('a'))) ]
    dp[mask] = min(i + 1, dp[mask])
    res = max(res, max(even, odd))
  return res
```"
404,"Convert given string to a valid mobile number | Java program for the above approach ; Function to print the valid and formatted phone number ; Length of given String ; Store digits in temp ; Iterate given M ; If any digit , append it to temp ; Find new length of String ; If length is not equal to 10 ; Store final result ; Make groups of 3 digits and enclose them within ( ) and separate them with "" - "" 0 to 2 index 1 st group ; 3 to 5 index 2 nd group ; 6 to 8 index 3 rd group ; 9 to 9 index last group ; Print final result ; Driver Code ; Given String ; Function Call","```java
public static void printFormattedPhoneNumber(String M) {
    String temp = """";
    for (int i = 0; i < M.length(); i++) {
      if (Character.isDigit(M.charAt(i))) {
        temp += M.charAt(i);
      }
    }
    if (temp.length() != 10) {
      System.out.println(""Invalid Phone Number"");
      return;
    }
    String finalResult = ""("" + temp.substring(0, 3) + "") "" + temp.substring(3, 6) + "" - "" + temp.substring(6, 9) + temp.substring(9, 10);
    System.out.println(finalResult);
  }
```","```python
def format_phone_number(M):
  temp = """"
  for i in M:
    if i.isdigit():
      temp += i
  if len(temp) != 10:
    return ""Invalid phone number""
  final_result = ""("" + temp[0:3] + "") "" + temp[3:6] + ""-"" + temp[6:9] + ""-"" + temp[9]
  return final_result

```"
405,"Modulus of two Hexadecimal Numbers | Java program to implement the above approach ; Function to calculate modulus of two Hexadecimal numbers ; Store all possible hexadecimal digits ; Iterate over the range [ '0' , '9' ] ; Convert given string to long ; Base to get 16 power ; Store N % K ; Iterate over the digits of N ; Stores i - th digit of N ; Update ans ; Update base ; Print the answer converting into hexadecimal ; Driver Code ; Given string N and K ; Function Call","```java
public static String modHex(String N, String K) {
    char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    long n = Long.parseLong(N, 16);
    long k = Long.parseLong(K, 16);
    long ans = n % k;
    long base = 1;
    for (int i = N.length() - 1; i >= 0; i--) {
      char digit = N.charAt(i);
      ans = (ans + (hexDigits[digit - '0'] * base)) % k;
      base = (base * 16) % k;
    }
    return Long.toHexString(ans).toUpperCase();
  }
```","```python
def hex_modulus(N, K):
  hex_digits = '0123456789ABCDEF'
  n = int(N, 16)
  k = int(K, 16)
  ans = n % k
  return hex(ans)[2:].upper()
```"
406,Print all combinations generated by characters of a numeric string which does not exceed N | Java program for the above approach ; Store the current sequence of s ; Store the all the required sequences ; Function to print all sequences of S satisfying the required condition ; Print all Strings in the set ; Function to generate all sequences of String S that are at most N ; Iterate over String s ; Push ith character to combination ; Convert the String to number ; Check if the condition is true ; Push the current String to the final set of sequences ; Recursively call function ; Backtrack to its previous state ; Driver Code ; Function Call ; Print required sequences,"```java
import java.util.*;
public class PrintCombinations {
    public static void printCombinations(String s, int n, Set<String> result, String combination) {
        if (combination.length() > 0) {
            int num = Integer.parseInt(combination);
            if (num <= n) {
                result.add(combination);
            }
        }
        for (int i = 0; i < s.length(); i++) {
            combination += s.charAt(i);
            printCombinations(s, n, result, combination);
            combination = combination.substring(0, combination.length() - 1);
        }
    }
    public static void main(String[] args) {
        String s = ""123"";
        int n = 5;
        Set<String> result = new HashSet<>();
        printCombinations(s, n, result, """");
        for (String str : result) {
            System.out.println(str);
        }
    }
}
```","```python
def print_combinations(s, n, combination, sequences):
  if len(combination) > 0:
    num = int("""".join(combination))
    if num <= n:
      sequences.append("""".join(combination))
  if len(combination) == len(s):
    return
  for i in range(len(s)):
    combination.append(s[i])
    print_combinations(s, n, combination, sequences)
    combination.pop()

def generate_sequences(s, n):
  sequences = []
  print_combinations(s, n, [], sequences)
  return sequences

def main():
  s = ""123""
  n = 5
  sequences = generate_sequences(s, n)
  for sequence in sequences:
    print(sequence)

if __name__ == ""__main__"":
  main()
```"
407,Count Distinct Strings present in an array using Polynomial rolling hash function | Java program to implement the above approach ; Function to find the hash value of a string ; Traverse the string ; Update hash_val ; Update mul ; Return hash_val of str ; Function to find the count of distinct strings present in the given array ; Store the hash values of the strings ; Traverse the array ; Stores hash value of arr [ i ] ; Sort hash [ ] array ; Stores count of distinct strings in the array ; Traverse hash [ ] array ; Update cntElem ; Driver Code,"```java
public static int countDistinctStrings(String[] arr) {
    int[] hash = new int[arr.length];
    for (int i = 0; i < arr.length; i++) {
        hash[i] = hashFunction(arr[i]);
    }
    Arrays.sort(hash);
    int cntElem = 1;
    for (int i = 1; i < hash.length; i++) {
        if (hash[i] != hash[i - 1]) {
            cntElem++;
        }
    }
    return cntElem;
}

public static int hashFunction(String str) {
    int hash_val = 0;
    int mul = 1;
    for (int i = 0; i < str.length(); i++) {
        hash_val = (hash_val + (str.charAt(i) - 'a' + 1) * mul) % 1000000007;
        mul = (mul * 26) % 1000000007;
    }
    return hash_val;
}
```","```python
def hash_val(str):
  hash_val = 0
  mul = 1
  for i in range(len(str)):
    hash_val = (hash_val + ord(str[i]) * mul) % 1000000007
    mul = (mul * 26) % 1000000007
  return hash_val

def countDistinct(arr):
  hash = []
  for i in range(len(arr)):
    hash.append(hash_val(arr[i]))
  hash.sort()
  cntElem = 1
  for i in range(1, len(hash)):
    if hash[i] != hash[i - 1]:
      cntElem += 1
  return cntElem
```"
408,Remove characters from given string whose frequencies are a Prime Number | Java program for the above approach ; Function to perform the seive of eratosthenes algorithm ; Initialize all entries in prime [ ] as true ; Initialize 0 and 1 as non prime ; Traversing the prime array ; If i is prime ; All multiples of i must be marked false as they are non prime ; Function to remove characters which have prime frequency in the String ; Length of the String ; Create a boolean array prime ; Sieve of Eratosthenes ; Stores the frequency of character ; Storing the frequencies ; New String that will be formed ; Removing the characters which have prime frequencies ; If the character has prime frequency then skip ; Else concatenate the character to the new String ; Print the modified String ; Driver Code ; Function Call,"```java
public static String removePrimeFrequencyChars(String str) {
    int n = str.length();
    boolean[] prime = new boolean[n + 1];
    sieveOfEratosthenes(prime);
    int[] freq = new int[256];
    for (int i = 0; i < n; i++) {
      freq[str.charAt(i)]++;
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < n; i++) {
      char ch = str.charAt(i);
      if (prime[freq[ch]]) {
        continue;
      } else {
        sb.append(ch);
      }
    }
    return sb.toString();
  }
  public static void sieveOfEratosthenes(boolean[] prime) {
    Arrays.fill(prime, true);
    prime[0] = prime[1] = false;
    for (int i = 2; i * i <= prime.length; i++) {
      if (prime[i]) {
        for (int j = i * i; j < prime.length; j += i) {
          prime[j] = false;
        }
      }
    }
  }
```","```python
def removePrimeFrequencyChars(s):
  n = len(s)
  prime = [True] * (n + 1)
  prime[0] = prime[1] = False
  for i in range(2, int(n**0.5) + 1):
    if prime[i]:
      for j in range(i * i, n + 1, i):
        prime[j] = False
  freq = [0] * 256
  for i in range(n):
    freq[ord(s[i])] += 1
  new_string = """"
  for i in range(n):
    if prime[freq[ord(s[i])]]:
      continue
    else:
      new_string += s[i]
  print(new_string)

```"
409,Rearrange string such that no pair of adjacent characters are of the same type | Java program to implement the above approach ; Function to rearrange given alphanumeric String such that no two adjacent characters are of the same type ; Stores alphabets and digits ; Store the alphabets and digits separately in the Strings ; Stores the count of alphabets and digits ; If respective counts differ by 1 ; Desired arrangement not possible ; Stores the indexes ; Check if first character should be alphabet or digit ; Place alphabets and digits alternatively ; If current character needs to be alphabet ; If current character needs to be a digit ; Flip flag for alternate arrangement ; Return resultant String ; Driver Code ; Given String ; Function Call,"```java
public static String rearrangeString(String str) {
    StringBuilder alphabets = new StringBuilder();
    StringBuilder digits = new StringBuilder();
    for (char ch : str.toCharArray()) {
        if (Character.isLetter(ch)) {
            alphabets.append(ch);
        } else {
            digits.append(ch);
        }
    }
    int alphaCount = alphabets.length();
    int digitCount = digits.length();
    if (Math.abs(alphaCount - digitCount) > 1) {
        return """";
    }
    int[] indexes = new int[str.length()];
    boolean isAlpha = alphaCount >= digitCount;
    int i = 0;
    int j = 0;
    int k = 0;
    while (i < alphaCount || j < digitCount) {
        if (isAlpha) {
            if (i < alphaCount) {
                indexes[k] = i;
                i++;
            }
        } else {
            if (j < digitCount) {
                indexes[k] = j + alphaCount;
                j++;
            }
        }
        isAlpha = !isAlpha;
        k++;
    }
    StringBuilder result = new StringBuilder();
    for (int index : indexes) {
        if (index < alphaCount) {
            result.append(alphabets.charAt(index));
        } else {
            result.append(digits.charAt(index - alphaCount));
        }
    }
    return result.toString();
}
```","```python
def rearrangeString(s):
  alphabets = """"
  digits = """"
  for char in s:
    if char.isalpha():
      alphabets += char
    else:
      digits += char
  alphabets_count = len(alphabets)
  digits_count = len(digits)
  if abs(alphabets_count - digits_count) > 1:
    return """"
  result = """"
  i = 0
  j = 0
  is_alphabet = alphabets_count >= digits_count
  while i < alphabets_count or j < digits_count:
    if is_alphabet:
      result += alphabets[i]
      i += 1
    else:
      result += digits[j]
      j += 1
    is_alphabet = not is_alphabet
  return result
```"
410,Find value after N operations to remove N characters of string S with given constraints | Java program for the above approach ; Function to find the value after N operations to remove all the N characters of String S ; Iterate till N ; Remove character at ind and decrease n ( size of String ) ; Increase count by ind + 1 ; Driver Code ; Given String str ; Function call,"```java
public static int findValue(String str, int n) {
    int count = 0;
    for (int i = 0; i < n; i++) {
      str = str.substring(0, str.length() - 1);
      count += str.length() + 1;
    }
    return count;
  }
```","```python
def find_value(s, n):
  count = 0
  for _ in range(n):
    count += s.index(s[0]) + 1
    s = s[1:]
  return count
```"
411,Print the middle character of a string | Java program for the above approach ; Function that prints the middle character of a string ; Finding string length ; Finding middle index of string ; Print the middle character of the string ; Driver Code ; Given string str ; Function Call,"```java
public static void printMiddleCharacter(String str) {
    int len = str.length();
    int middleIndex = len / 2;
    System.out.println(str.charAt(middleIndex));
}
```","```python
def print_middle_character(str):
  length = len(str)
  middle_index = length // 2
  print(str[middle_index])
```"
412,Maximize length of the String by concatenating characters from an Array of Strings | Java program to implement the above approach ; Function to check if all the string characters are unique ; Check for repetition in characters ; Function to generate all possible strings from the given array ; Base case ; Consider every string as a starting substring and store the generated string ; Add current string to result of other strings and check if characters are unique or not ; Function to find the maximum possible length of a string ; Return max length possible ; Return the answer ; Driver code,"```java
public static int maxLength(String[] arr) {
    int maxLen = 0;
    for (int i = 0; i < arr.length; i++) {
        maxLen = Math.max(maxLen, helper(arr, i, arr[i]));
    }
    return maxLen;
}

private static int helper(String[] arr, int index, String current) {
    if (index == arr.length) {
        return current.length();
    }
    int len1 = helper(arr, index + 1, current);
    int len2 = 0;
    if (isUnique(current + arr[index])) {
        len2 = helper(arr, index + 1, current + arr[index]);
    }
    return Math.max(len1, len2);
}

private static boolean isUnique(String str) {
    Set<Character> seen = new HashSet<>();
    for (char c : str.toCharArray()) {
        if (seen.contains(c)) {
            return false;
        }
        seen.add(c);
    }
    return true;
}
```","```python
def isUnique(s):
  return len(set(s)) == len(s)

def generateStrings(arr, index, current, result):
  if index == len(arr):
    result.append(current)
    return
  generateStrings(arr, index + 1, current, result)
  generateStrings(arr, index + 1, current + arr[index], result)

def maxLength(arr):
  result = []
  generateStrings(arr, 0, """", result)
  maxLength = 0
  for s in result:
    if isUnique(s):
      maxLength = max(maxLength, len(s))
  return maxLength

def main():
  arr = [""un"", ""iq"", ""ue""]
  ans = maxLength(arr)
  print(ans)

if __name__ == ""__main__"":
  main()
```"
413,Perform range sum queries on string as per given condition | Java program for the above approach ; Function to perform range sum queries on String as per the given condition ; Initialize N by String size ; Create array A [ ] for prefix sum ; Iterate till N ; Traverse the queries ; Check if if L == 1 range sum will be A [ R - 1 ] ; Condition if L > 1 range sum will be A [ R - 1 ] - A [ L - 2 ] ; Driver Code ; Given String ; Given Queries ; Function call,"```java
public static int rangeSum(String s, int L, int R) {
    int N = s.length();
    int[] A = new int[N];
    for (int i = 0; i < N; i++) {
        A[i] = (i == 0) ? s.charAt(i) : A[i - 1] + s.charAt(i);
    }
    if (L == 1) {
        return A[R - 1];
    } else {
        return A[R - 1] - A[L - 2];
    }
}
```","```python
def rangeSumQueries(s, queries):
  N = len(s)
  A = [0] * N
  for i in range(N):
    A[i] = A[i-1] + ord(s[i])
  for L, R in queries:
    if L == 1:
      print(A[R-1])
    else:
      print(A[R-1] - A[L-2]) 
```"
414,Generate all possible permutations of a Number divisible by N | Java program to implement the above approach ; Function to Swap two characters ; Function to generate all permutations and print the ones that are divisible by the N ; Convert String to integer ; Check for divisibility and print it ; Print all the permutations ; Swap characters ; Permute remaining characters ; Revoke the swaps ; Driver Code,"```java
public static void generatePermutationsDivisibleByN(String str, int n) {
    if (str.length() == 0) {
        return;
    }
    char[] chars = str.toCharArray();
    permute(chars, 0, chars.length, n);
}

private static void permute(char[] chars, int l, int r, int n) {
    if (l == r) {
        if (Integer.parseInt(new String(chars)) % n == 0) {
            System.out.println(new String(chars));
        }
        return;
    }
    for (int i = l; i < r; i++) {
        swap(chars, l, i);
        permute(chars, l + 1, r, n);
        swap(chars, l, i);
    }
}

private static void swap(char[] chars, int i, int j) {
    char temp = chars[i];
    chars[i] = chars[j];
    chars[j] = temp;
}
```","```python
def swap(a, i, j):
  temp = a[i]
  a[i] = a[j]
  a[j] = temp

def permute(a, l, r, n):
  if l == r:
    num = int("""".join(a))
    if num % n == 0:
      print("""".join(a))
  else:
    for i in range(l, r + 1):
      swap(a, l, i)
      permute(a, l + 1, r, n)
      swap(a, l, i)

def generate_permutations(number, n):
  a = list(str(number))
  permute(a, 0, len(a) - 1, n)
```"
415,"Check if binary representations of 0 to N are present as substrings in given binary string | Java program for the above approach ; Function to convert decimal to binary representation ; Iterate over all bits of N ; If bit is 1 ; Return binary representation ; Function to check if binary conversion of numbers from N to 1 exists in the String as a subString or not ; To store the count of number exists as a subString ; Traverse from N to 1 ; If current number is not present in map ; Store current number ; Find binary of t ; If the String s is a subString of str ; Mark t as true ; Increment the count ; Update for t \/ 2 ; Special judgment '0' ; If the count is N + 1 , return "" yes "" ; Driver Code ; Given String ; Given number ; Function call","```java
public static String checkBinarySubstrings(String str, int N) {
    Map<Integer, Boolean> map = new HashMap<>();
    int count = 0;
    for (int t = N; t >= 1; t--) {
      if (!map.containsKey(t)) {
        map.put(t, false);
        String binary = decimalToBinary(t);
        if (str.contains(binary)) {
          map.put(t, true);
          count++;
          t /= 2;
        }
      }
    }
    if (count == N + 1) {
      return ""yes"";
    }
    return ""no"";
  }

  public static String decimalToBinary(int num) {
    if (num == 0) {
      return ""0"";
    }
    StringBuilder binary = new StringBuilder();
    while (num > 0) {
      binary.insert(0, num % 2);
      num /= 2;
    }
    return binary.toString();
  }
```","```python
def check_binary_substrings(s, n):
  def decimal_to_binary(num):
    if num == 0:
      return ""0""
    binary = """"
    while num > 0:
      binary = str(num % 2) + binary
      num //= 2
    return binary
  
  count = 0
  present = {}
  for i in range(n, 0, -1):
    if i not in present:
      present[i] = False
      binary = decimal_to_binary(i)
      if binary in s:
        present[i] = True
        count += 1
        present[i // 2] = True
  if count == n + 1:
    return ""yes""
  return ""no""

# Driver Code
s = ""10110110001111100011111111101011011000111110001111111110101101100011111000111111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010110110001111100011111111010"
416,Find the word with most anagrams in a given sentence | Java Program to find the word with most anagrams in a sentence ; Function to find the word with maximum number of anagrams ; Primes assigned to 26 alphabets ; Stores the product and word mappings ; Stores the frequencies of products ; Calculate the product of primes assigned ; If product already exists ; Otherwise ; Fetch the most frequent product ; Return a string with that product ; Driver Code,"```java
public static String findWordWithMostAnagrams(String sentence) {
    int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};
    Map<Long, String> productWordMap = new HashMap<>();
    Map<Long, Integer> productFrequencyMap = new HashMap<>();
    String[] words = sentence.split("" "");
    for (String word : words) {
        long product = 1;
        for (char c : word.toCharArray()) {
            product *= primes[c - 'a'];
        }
        if (productWordMap.containsKey(product)) {
            productWordMap.put(product, productWordMap.get(product) + "" "" + word);
        } else {
            productWordMap.put(product, word);
            productFrequencyMap.put(product, 1);
        }
    }
    long maxProduct = Collections.max(productFrequencyMap.entrySet(), Map.Entry.comparingByValue()).getKey();
    return productWordMap.get(maxProduct);
}
```","```python
def find_word_with_most_anagrams(sentence):
  primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]
  product_to_word = {}
  product_frequencies = {}
  words = sentence.split()
  for word in words:
    product = 1
    for char in word:
      product *= primes[ord(char) - ord('a')]
    if product in product_to_word:
      product_to_word[product].append(word)
    else:
      product_to_word[product] = [word]
    if product in product_frequencies:
      product_frequencies[product] += 1
    else:
      product_frequencies[product] = 1
  max_frequency = 0
  max_frequency_product = 0
  for product, frequency in product_frequencies.items():
    if frequency > max_frequency:
      max_frequency = frequency
      max_frequency_product = product
  return "" "".join(product_to_word[max_frequency_product])
```"
417,Replace every vowels with lexicographically next vowel in a String | Java program to convert all the vowels in in the String to the next vowel ; Function to replace every vowel with next vowel lexicographically ; storing the vowels in the map with custom numbers showing their index ; Iterate over the String ; If the current character is a vowel Find the index in Hash and Replace it with next vowel from Hash ; Driver code,"```java
public static String replaceVowels(String str) {
    Map<Character, Integer> vowelMap = new HashMap<>();
    vowelMap.put('a', 0);
    vowelMap.put('e', 1);
    vowelMap.put('i', 2);
    vowelMap.put('o', 3);
    vowelMap.put('u', 4);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < str.length(); i++) {
        char ch = str.charAt(i);
        if (vowelMap.containsKey(ch)) {
            int index = vowelMap.get(ch);
            if (index == 4) {
                sb.append('a');
            } else {
                sb.append(vowelMap.keySet().toArray()[index + 1]);
            }
        } else {
            sb.append(ch);
        }
    }
    return sb.toString();
}
```","```python
def replaceVowels(s):
  vowels = {'a': 0, 'e': 1, 'i': 2, 'o': 3, 'u': 4}
  new_string = ''
  for char in s:
    if char in vowels:
      index = (vowels[char] + 1) % 5
      new_string += list(vowels.keys())[index]
    else:
      new_string += char
  return new_string
```"
418,"Check if string is palindrome after removing all consecutive duplicates | Java program for the above approach ; Function to check if a String is palindrome or not ; Length of the String ; Check if its a palindrome ; If the palindromic condition is not met ; Return true as str is palindromic ; Function to check if String str is palindromic after removing every consecutive characters from the str ; Length of the String str ; Create an empty compressed String ; The first character will always be included in the final String ; Check all the characters of the String ; If the current character is not same as its previous one , then insert it in the final String ; Check if the compressed String is a palindrome ; Driver Code ; Given String ; Function call","```java
public static boolean isPalindromeAfterRemovingDuplicates(String str) {
    int n = str.length();
    if (n <= 1) {
        return true;
    }
    if (str.charAt(0) != str.charAt(n - 1)) {
        return false;
    }
    return isPalindromic(str.substring(1, n - 1));
}

public static boolean isPalindromic(String str) {
    int n = str.length();
    String compressedStr = """";
    compressedStr += str.charAt(0);
    for (int i = 1; i < n; i++) {
        if (str.charAt(i) != str.charAt(i - 1)) {
            compressedStr += str.charAt(i);
        }
    }
    return isPalindrome(compressedStr);
}

public static boolean isPalindrome(String str) {
    int n = str.length();
    for (int i = 0; i < n / 2; i++) {
        if (str.charAt(i) != str.charAt(n - i - 1)) {
            return false;
        }
    }
    return true;
}

public static void main(String[] args) {
    String str = ""abbaca"";
    System.out.println(isPalindromeAfterRemovingDuplicates(str));
}
```","```python
def isPalindromeAfterRemovingConsecutiveDuplicates(str):
  n = len(str)
  compressedStr = """"
  compressedStr += str[0]
  for i in range(1, n):
    if str[i] != str[i - 1]:
      compressedStr += str[i]
  return compressedStr == compressedStr[::-1]

str = input()
print(isPalindromeAfterRemovingConsecutiveDuplicates(str))
```"
419,Count of substrings consisting only of vowels | Java program to Count all substrings in a string which contains only vowels ; Function to check vowel or not ; Function to find largest string which satisfy condition ; Check if current character is vowel ; Increment count ; Count all possible substrings of calculated length ; Reset the length ; Add remaining possible substrings consisting of vowels occupying last indices of the string ; Driver Program,"```java
public static int countVowelSubstrings(String str) {
    int count = 0;
    int len = str.length();
    for (int i = 0; i < len; i++) {
        int j = i;
        int currentLength = 0;
        while (j < len && isVowel(str.charAt(j))) {
            currentLength++;
            j++;
        }
        count += (currentLength * (currentLength + 1)) / 2;
        i = j - 1;
    }
    for (int i = len - 1; i >= 0; i--) {
        if (isVowel(str.charAt(i))) {
            count++;
        } else {
            break;
        }
    }
    return count;
}

public static boolean isVowel(char ch) {
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||
           ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
}
```","```python
def count_vowel_substrings(s):
  def is_vowel(char):
    return char.lower() in 'aeiou'

  def find_largest_substring(s):
    length = 0
    for i in range(len(s)):
      if is_vowel(s[i]):
        length += 1
      else:
        length = 0
    return length

  count = 0
  max_length = find_largest_substring(s)
  for i in range(max_length):
    count += max_length - i
  for i in range(len(s) - max_length):
    if is_vowel(s[i + max_length]):
      count += 1
  return count
```"
420,"Number formed by flipping all bits to the left of rightmost set bit | Java program to find the integer formed after flipping all bits to the left of the rightmost set bit ; Function to get the total count ; Moving until we get the rightmost set bit ; To get total number of bits in a number ; Function to find the integer formed after flipping all bits to the left of the rightmost set bit ; Find the total count of bits and the rightmost set bit ; XOR given number with the number which has is made up of only totbits set ; To avoid flipping the bits to the right of the set bit , take XOR with the number made up of only set firstbits ; Driver Code","```java
public static int flipBitsToLeft(int n) {
    int totbits = Integer.toBinaryString(n).length();
    int rightmost = n & -n;
    int firstbits = (1 << (totbits - Integer.numberOfTrailingZeros(rightmost))) - 1;
    return n ^ (firstbits ^ ((1 << totbits) - 1));
  }
```","```python
def flipBitsToLeft(n):
  totbits = 0
  rightmostsetbit = n & -n
  while n:
    totbits += 1
    n >>= 1
  firstbits = totbits - rightmostsetbit.bit_length()
  return (n ^ ((1 << totbits) - 1)) ^ ((1 << firstbits) - 1) 
```"
421,"Longest substring of vowels with no two adjacent alphabets same | Java implementation of the above approach ; Function to check a character is vowel or not ; Function to find length of longest substring consisting only of vowels and no similar adjacent alphabets ; Stores max length of valid subString ; Stores length of current valid subString ; If curr and prev character are not same , include it ; If same as prev one , start new subString from here ; Store max in maxLen ; Driver code","```java
public static int longestSubstring(String str) {
    int maxLen = 0;
    int currLen = 0;
    char prev = ' ';
    for (int i = 0; i < str.length(); i++) {
        char curr = str.charAt(i);
        if (isVowel(curr) && (prev != curr || prev == ' ')) {
            currLen++;
        } else {
            currLen = 1;
        }
        maxLen = Math.max(maxLen, currLen);
        prev = curr;
    }
    return maxLen;
}

public static boolean isVowel(char ch) {
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';
}
```","```python
def isVowel(ch):
  return ch in 'aeiouAEIOU'

def longestSubstring(s):
  maxLen = 0
  currLen = 0
  prev = '#'
  for i in range(len(s)):
    if isVowel(s[i]) and s[i] != prev:
      currLen += 1
      prev = s[i]
    else:
      currLen = 1
      prev = s[i]
    maxLen = max(maxLen, currLen)
  return maxLen

```"
422,Count of non | Java program to count non - palindromic strings of length M using N distinct characters ; Iterative Function to calculate base ^ pow in O ( log y ) ; Function to return the count of non palindromic strings ; Count of strings using n characters with repetitions allowed ; Count of palindromic strings ; Count of non - palindromic strings ; Driver code,"```java
public class CountNonPalindromicStrings {

    public static int power(int base, int pow) {
        if (pow == 0) {
            return 1;
        }
        if (pow == 1) {
            return base;
        }
        int res = power(base, pow / 2);
        if (pow % 2 == 0) {
            return res * res;
        } else {
            return base * res * res;
        }
    }

    public static int countNonPalindromicStrings(int n, int m) {
        int totalStrings = power(n, m);
        int palindromicStrings = 0;
        if (m % 2 == 0) {
            palindromicStrings = power(n, m / 2);
        } else {
            palindromicStrings = n * power(n, (m - 1) / 2);
        }
        return totalStrings - palindromicStrings;
    }

    public static void main(String[] args) {
        int n = 3, m = 4;
        int count = countNonPalindromicStrings(n, m);
        System.out.println(""Count of non-palindromic strings: "" + count);
    }
}
```","```python
def countNonPalindromicStrings(n, m):
  count = 0
  for i in range(1, n + 1):
    count += n ** (m // 2) * (n - 1) ** (m % 2)
  return count - n ** (m // 2)
```"
423,Count of K | Java program for the above approach ; To store the frequency array ; Function to check palindromic of of any subString using frequency array ; Initialise the odd count ; Traversing frequency array to compute the count of characters having odd frequency ; Returns true if odd count is atmost 1 ; Function to count the total number subString whose any permutations are palindromic ; Computing the frequency of first K character of the String ; To store the count of palindromic permutations ; Checking for the current window if it has any palindromic permutation ; Start and end point of window ; Decrementing count of first element of the window ; Incrementing count of next element of the window ; Checking current window character frequency count ; Return the final count ; Driver Code ; Given String str ; Window of size K ; Function Call,"```java
public static int countK(String str, int k) {
    int[] freq = new int[26];
    int count = 0;
    for (int i = 0; i < k; i++) {
        freq[str.charAt(i) - 'a']++;
    }
    if (isPalindromic(freq)) {
        count++;
    }
    for (int i = k; i < str.length(); i++) {
        freq[str.charAt(i - k) - 'a']--;
        freq[str.charAt(i) - 'a']++;
        if (isPalindromic(freq)) {
            count++;
        }
    }
    return count;
}

private static boolean isPalindromic(int[] freq) {
    int oddCount = 0;
    for (int i = 0; i < freq.length; i++) {
        if (freq[i] % 2 != 0) {
            oddCount++;
        }
    }
    return oddCount <= 1;
}
```","```python
def count_palindromic_permutations(str, k):
  freq = [0] * 26
  count = 0
  for i in range(k):
    freq[ord(str[i]) - ord('a')] += 1
  for i in range(len(str) - k + 1):
    if is_palindromic_permutation(freq):
      count += 1
    freq[ord(str[i]) - ord('a')] -= 1
    if i + k < len(str):
      freq[ord(str[i + k]) - ord('a')] += 1
  return count

def is_palindromic_permutation(freq):
  odd_count = 0
  for i in range(26):
    if freq[i] % 2 != 0:
      odd_count += 1
  return odd_count <= 1
```"
424,Minimum flips required to form given binary string where every flip changes all bits to its right as well | Java program for the above approach ; Function to return the count of minimum flips required ; If curr occurs in the final string ; Switch curr to '0' if '1' or vice - versa ; Driver Code,"```java
public static int minFlips(String s) {
    int flips = 0;
    char curr = '0';
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == curr) {
            flips++;
            curr = curr == '0' ? '1' : '0';
        }
    }
    return flips;
}
```","```python
def minFlips(s):
  n = len(s)
  flips = 0
  curr = '0'
  for i in range(n):
    if s[i] == curr:
      flips += 1
      curr = '1' if curr == '0' else '0'
  return flips
```"
425,"Check if a number ends with another number or not | Java program for the above approach ; Function to check if B is a suffix of A or not ; Find the number of digit in B ; Subtract B from A ; Returns true , if B is a suffix of A ; Driver code ; Given numbers ; Function call ; If B is a suffix of A , then print "" Yes ""","```java
public static boolean isSuffix(int A, int B) {
    int digitsInB = (int) Math.log10(B) + 1;
    return A % (int) Math.pow(10, digitsInB) == B;
}
```","```python
def is_suffix(A, B):
  len_B = len(str(B))
  A -= B
  return len(str(A)) < len_B
```"
426,"Minimum length of substring whose rotation generates a palindromic substring | Java Program to find the minimum length of substring whose rotation generates a palindromic substring ; Function to return the minimum length of substring ; Store the index of previous occurrence of the character ; Variable to store the maximum length of substring ; If the current character hasn 't appeared yet ; If the character has occured within one or two previous index , a palindromic substring already exists ; Update the maximum ; Replace the previous index of the character by the current index ; If character appeared at least twice ; Driver code","```java
public static int minLengthSubstring(String str) {
    int[] prevIndex = new int[256];
    int maxLength = 0;
    for (int i = 0; i < str.length(); i++) {
      char ch = str.charAt(i);
      if (prevIndex[ch] == 0) {
        if (i - prevIndex[ch] <= 2) {
          maxLength = Math.max(maxLength, i + 1);
        }
        prevIndex[ch] = i + 1;
      } else if (prevIndex[ch] != 0) {
        maxLength = Math.max(maxLength, i - prevIndex[ch] + 1);
        prevIndex[ch] = i + 1;
      }
    }
    return maxLength;
  }
```","```python
def minLength(s):
  prev = {}
  maxLen = 0
  for i in range(len(s)):
    if s[i] not in prev:
      prev[s[i]] = i
    elif i - prev[s[i]] <= 2:
      maxLen = max(maxLen, i - prev[s[i]] + 1)
      prev[s[i]] = i
    else:
      prev[s[i]] = i
  return maxLen if maxLen > 0 else len(s)
```"
427,Program to remove HTML tags from a given String | Java program for the above approach ; Function to remove the HTML tags from the given tags ; Use replaceAll function in regex to erase every tags enclosed in < > ; Print string after removing tags ; Driver Code ; Given String ; Function call to print the HTML string after removing tags,"```java
public static void removeHTMLTags(String str) {
    System.out.println(str.replaceAll(""<[^>]+>"", """"));
  }
```","```python
import re

def remove_html_tags(text):
  return re.sub('<.*?>', '', text)
```"
428,"Score of Parentheses using Tree | Java program to find the score of parentheses using Tree ; Customized tree class or struct , contains all required methods . ; Function to add a child into the list of children ; Function to change the parent pointer to the node passed ; Function to return the parent of the current node ; Function to compute the score recursively . ; Base case ; Adds scores of all children ; Function to create the tree structure ; Creating a node for every "" ( ) "" ; If we find "" ( "" we add a node as a child ; On finding "" ) "" which confirms that a pair is closed , we go back to the parent ; Driver code ; Generating the tree ; Computing the score","```java
class Node {
    int score;
    Node parent;
    List<Node> children;

    Node() {
        score = 0;
        parent = null;
        children = new ArrayList<>();
    }

    void addChild(Node child) {
        children.add(child);
        child.parent = this;
    }

    Node getParent() {
        return parent;
    }

    int computeScore() {
        if (children.isEmpty()) {
            return 1;
        }
        int sum = 0;
        for (Node child : children) {
            sum += child.computeScore();
        }
        return 2 * sum;
    }
}

class Tree {
    Node root;

    Tree() {
        root = new Node();
    }

    void createTree(String s) {
        Node current = root;
        for (char c : s.toCharArray()) {
            if (c == '(') {
                Node newNode = new Node();
                current.addChild(newNode);
                current = newNode;
            } else if (c == ')') {
                current = current.getParent();
            }
        }
    }

    int getScore() {
        return root.computeScore();
    }
}

public class ParenthesesScore {
    public static void main(String[] args) {
        String s = ""(()())"";
        Tree tree = new Tree();
        tree.createTree(s);
        int score = tree.getScore();
        System.out.println(score);
    }
}
```","```python
class Node:
    def __init__(self):
        self.children = []
        self.parent = None

    def add_child(self, child):
        self.children.append(child)
        child.parent = self

    def get_parent(self):
        return self.parent

    def compute_score(self):
        if len(self.children) == 0:
            return 1
        score = 0
        for child in self.children:
            score += child.compute_score()
        return 2 * score

def create_tree(expression):
    root = Node()
    current = root
    for char in expression:
        if char == '(':
            node = Node()
            current.add_child(node)
            current = node
        elif char == ')':
            current = current.get_parent()
    return root

def main():
    expression = ""(())(())""
    tree = create_tree(expression)
    score = tree.compute_score()
    print(score)

if __name__ == ""__main__"":
    main()
```"
429,Move all occurrence of letter ' x ' from the string s to the end using Recursion | Java program for the above approach ; Recursive program to bring ' x ' to the end ; When the string is completed from reverse direction end of recursion ; If the character x is found ; Transverse the whole string ; Swap the x so that it moves to the last ; call to the smaller problem now ; Driver code ; Size of a ; Call to rec,"```java
public static String moveXToEnd(String s) {
    if (s.length() == 0) {
      return s;
    }
    if (s.charAt(0) == 'x') {
      return moveXToEnd(s.substring(1)) + 'x';
    }
    return s.charAt(0) + moveXToEnd(s.substring(1));
  }
```","```python
def move_x_to_end(s, i):
  if i == len(s):
    return s
  if s[i] == 'x':
    s = s[:i] + s[i+1:] + 'x'
    return move_x_to_end(s, i)
  return move_x_to_end(s, i+1)
```"
430,Find the largest Alphabetic character present in the string | Java program to Find the Largest Alphabetic Character present in the string of both uppercase and lowercase English characters ; Function to find the Largest Alphabetic Character ; Array for keeping track of both uppercase and lowercase english alphabets ; Iterate from right side of array to get the largest index character ; Check for the character if both its uppercase and lowercase exist or not ; Return - 1 if no such character whose uppercase and lowercase present in string str ; Driver code,"```java
public static char findLargestAlphabeticCharacter(String str) {
    boolean[] alphabet = new boolean[26];
    for (char c : str.toCharArray()) {
      if (Character.isLetter(c)) {
        alphabet[Character.toLowerCase(c) - 'a'] = true;
      }
    }
    for (int i = 25; i >= 0; i--) {
      if (alphabet[i]) {
        if (alphabet[i - ('A' - 'a')] || i == 0) {
          return (char) ('a' + i);
        }
      }
    }
    return -1;
  }
```","```python
def find_largest_alphabetic_char(str):
  alphabets = [False] * 52
  for char in str:
    if char.isupper():
      alphabets[ord(char) - ord('A')] = True
    elif char.islower():
      alphabets[ord(char) - ord('a') + 26] = True
  for i in range(51, -1, -1):
    if alphabets[i] and alphabets[i - 26]:
      return chr(i + ord('A'))
  return -1
```"
431,"Generate a string of size N whose each substring of size M has exactly K distinct characters | Java program to generate a String of size N whose each subString of size M has exactly K distinct characters ; Function to generate the String ; Declare empty String ; counter for M ; counter for K ; Loop to generate String size of N ; Generating K distinct letters one by one ; After generating b distinct letters , append rest a - b letters as ' a ' ; Reset the counter value and repeat the process ; return final result String ; Driver code","```java
public static String generateString(int N, int M, int K) {
    StringBuilder sb = new StringBuilder();
    int mCount = 0;
    int kCount = 0;
    for (int i = 0; i < N; i++) {
      if (kCount < K) {
        sb.append((char)('a' + kCount));
        kCount++;
      } else {
        sb.append('a');
      }
      mCount++;
      if (mCount == M) {
        mCount = 0;
        kCount = 0;
      }
    }
    return sb.toString();
  }
```","```python
def generate_string(N, M, K):
  result = """"
  m_counter = 0
  k_counter = 0
  for i in range(N):
    if k_counter < K:
      result += chr(ord('a') + k_counter)
      k_counter += 1
    else:
      result += 'a'
    m_counter += 1
    if m_counter == M:
      m_counter = 0
      k_counter = 0
  return result
```"
432,"Print string after removing all ( “ 10 ” or “ 01 ” ) from the binary string | Java program to print the final String after removing all the occurrences of ""10"" and ""01"" from the given binary String ; Function to print the final String after removing all the occurrences of ""10"" and ""01"" from the given binary String ; Variables to store the count of 1 ' s ▁ and ▁ 0' s ; Variable left will store whether 0 ' s ▁ or ▁ 1' s is left in the final String ; Length of the String ; For loop to count the occurrences of 1 ' s ▁ and ▁ 0' s in the String ; To check if the count of 1 ' s ▁ is ▁ ▁ greater ▁ than ▁ the ▁ count ▁ of ▁ 0' s or not . If x is greater , then those many 1 's  are printed. ; Length of the final remaining String after removing all the occurrences ; Printing the final String ; Driver Code","```java
public static void removeOccurrences(String str) {
    int count1 = 0, count0 = 0;
    boolean left = false;
    int n = str.length();
    for (int i = 0; i < n; i++) {
      if (str.charAt(i) == '1') {
        count1++;
      } else {
        count0++;
      }
    }
    if (count1 > count0) {
      left = true;
    }
    int len = Math.abs(count1 - count0);
    for (int i = 0; i < len; i++) {
      if (left) {
        System.out.print(""1"");
      } else {
        System.out.print(""0"");
      }
    }
  }
```","```python
def remove_10_01(binary_string):
  count_1 = 0
  count_0 = 0
  for i in range(len(binary_string)):
    if binary_string[i] == '1':
      count_1 += 1
    else:
      count_0 += 1
  left = '1' if count_1 > count_0 else '0'
  final_length = abs(count_1 - count_0)
  return left * final_length
```"
433,Longest palindrome formed by concatenating and reordering strings of equal length | Java program to find the Longest palindrome that can be formed by concatenating and reordering given N Strings of equal length ; Function to print the longest palindrome ; Printing every String in left vector ; Printing the palindromic String in the middle ; Printing the reverse of the right vector to make the final output palindromic ; Function to find and print the longest palindrome that can be formed ; Inserting each String in the set ; Vectors to add the Strings in the left and right side ; To add the already present palindrome String in the middle of the solution ; Iterating through all the given Strings ; If the String is a palindrome it is added in the middle ; Checking if the reverse of the String is already present in the set ;  ; Driver code,"```java
import java.util.*;
public class LongestPalindrome {
    public static void printLongestPalindrome(List<String> strs) {
        Set<String> set = new HashSet<>();
        List<String> left = new ArrayList<>();
        List<String> right = new ArrayList<>();
        for (String str : strs) {
            set.add(str);
            if (isPalindrome(str)) {
                left.add(str);
                right.add(str);
            } else if (set.contains(new StringBuilder(str).reverse().toString())) {
                left.add(str);
                right.add(0, str);
            } else {
                right.add(str);
            }
        }
        for (String str : left) {
            System.out.print(str + "" "");
        }
        for (String str : right) {
            System.out.print(str + "" "");
        }
    }
    public static boolean isPalindrome(String str) {
        int left = 0;
        int right = str.length() - 1;
        while (left < right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
    public static void main(String[] args) {
        List<String> strs = new ArrayList<>(Arrays.asList(""aba"", ""cdc"", ""aba"", ""dcd"", ""dad""));
        printLongestPalindrome(strs);
    }
}
```","```python
def longest_palindrome(strings):
  middle = []
  left = []
  right = []
  seen = set()
  for s in strings:
    if s == s[::-1]:
      middle.append(s)
    elif s[::-1] in seen:
      left.append(s)
      right.append(s[::-1])
    else:
      seen.add(s)
  print("" "".join(left) + "" "" + "" "".join(middle) + "" "" + "" "".join(right[::-1]))
```"
434,Lexicographically smaller string by swapping at most one character pair | Java program check whether is it possible to make String A lexicographically smaller than String B ; Swap function ; Function that finds whether is it possible to make String A lexicographically smaller than String B ; Condition if String A is already smaller than B ; Sorting temp String ; Condition for first changed character of String A and temp ; Condition if String A is already sorted ; Finding first changed character from last of String A ; Swap the two characters ; Condition if String A is smaller than B ; Driver Code,"```java
public static boolean makeSmaller(String A, String B) {
    if (A.compareTo(B) < 0) {
        return true;
    }
    String temp = new String(A);
    char[] tempArr = temp.toCharArray();
    Arrays.sort(tempArr);
    temp = new String(tempArr);
    int firstChange = -1;
    for (int i = 0; i < A.length(); i++) {
        if (A.charAt(i) != temp.charAt(i)) {
            firstChange = i;
            break;
        }
    }
    if (firstChange == -1) {
        return false;
    }
    int lastChange = -1;
    for (int i = A.length() - 1; i >= 0; i--) {
        if (A.charAt(i) != temp.charAt(i)) {
            lastChange = i;
            break;
        }
    }
    char[] aArr = A.toCharArray();
    char tempChar = aArr[firstChange];
    aArr[firstChange] = aArr[lastChange];
    aArr[lastChange] = tempChar;
    A = new String(aArr);
    return A.compareTo(B) < 0;
}
```","```python
def make_smaller(A, B):
  if A < B:
    return True
  temp = list(A)
  temp.sort()
  temp = ''.join(temp)
  first_changed = -1
  for i in range(len(A)):
    if A[i] != temp[i]:
      first_changed = i
      break
  if first_changed == -1:
    return False
  last_changed = len(A) - 1
  for i in range(len(A) - 1, -1, -1):
    if A[i] != temp[i]:
      last_changed = i
      break
  A = list(A)
  A[first_changed], A[last_changed] = A[last_changed], A[first_changed]
  A = ''.join(A)
  return A < B
```"
435,Length of longest palindromic sub | Java implementation to find the length of longest palindromic sub - String using Recursion ; Function to find maximum of the two variables ; Function to find the longest palindromic subString : Recursion ; Base condition when the start index is greater than end index ; Base condition when both the start and end index are equal ; Condition when corner characters are equal in the String ; Recursive call to find the longest Palindromic String by excluding the corner characters ; Recursive call to find the longest Palindromic String by including one corner character at a time ; Function to find the longest palindromic sub - String ; Utility function call ; Driver Code ; Function Call,"```java
public static int max(int a, int b) {
    return a > b ? a : b;
}

public static int longestPalindrome(String str, int start, int end) {
    if (start > end) {
        return 0;
    }
    if (start == end) {
        return 1;
    }
    if (str.charAt(start) == str.charAt(end)) {
        return 2 + longestPalindrome(str, start + 1, end - 1);
    }
    return max(longestPalindrome(str, start + 1, end), longestPalindrome(str, start, end - 1));
}

public static int longestPalindrome(String str) {
    return longestPalindrome(str, 0, str.length() - 1);
}

public static void main(String[] args) {
    String str = ""abaxyzzyxf"";
    System.out.println(""Length of longest palindromic substring is: "" + longestPalindrome(str));
}
```","```python
def max(a, b):
  return a if a > b else b

def longestPalindrome(s, start, end):
  if start > end:
    return 0
  if start == end:
    return 1
  if s[start] == s[end]:
    return 2 + longestPalindrome(s, start + 1, end - 1)
  return max(longestPalindrome(s, start + 1, end), longestPalindrome(s, start, end - 1))

def longestPalindromicSubstring(s):
  return longestPalindrome(s, 0, len(s) - 1)

s = ""babad""
print(longestPalindromicSubstring(s))
```"
436,Maximum length prefix such that frequency of each character is atmost number of characters with minimum frequency | Java implementation to find the prefix of the s such that occurrence of each character is atmost the count of minimum frequency in the s ; Function to find the maximum possible prefix of the s ; Hash map to store the frequency of the characters in the s ; Iterate over the s to find the occurence of each Character ; Minimum frequency of the Characters ; Loop to find the count of minimum frequency in the hash - map ; Loop to find the maximum possible length of the prefix in the s ; Condition to check if the frequency is greater than minimum possible freq ; maxprefix s and its length . ; Driver code ; s is initialize . ; str is passed in MaxPrefix function .,"```java
public static int MaxPrefix(String s) {
    HashMap<Character, Integer> charFreq = new HashMap<>();
    for (char c : s.toCharArray()) {
      charFreq.put(c, charFreq.getOrDefault(c, 0) + 1);
    }
    int minFreq = Collections.min(charFreq.values());
    int minFreqCount = 0;
    for (int freq : charFreq.values()) {
      if (freq == minFreq) {
        minFreqCount++;
      }
    }
    int maxPrefixLength = 0;
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      if (charFreq.get(c) > minFreqCount) {
        break;
      }
      maxPrefixLength++;
    }
    return maxPrefixLength;
  }
```","```python
def MaxPrefix(s):
  freq = {}
  for char in s:
    if char in freq:
      freq[char] += 1
    else:
      freq[char] = 1
  min_freq = min(freq.values())
  min_freq_count = 0
  for count in freq.values():
    if count == min_freq:
      min_freq_count += 1
  maxprefix = """"
  i = 0
  while i < len(s):
    if freq[s[i]] > min_freq_count:
      break
    maxprefix += s[i]
    i += 1
  return maxprefix, len(maxprefix)
```"
437,"Count of Substrings that can be formed without using the given list of Characters | Java implementation of the above approach ; Function to find the Number of sub - Strings without using given character ; Mark the given characters in the freq array ; Count variable to store the count of the characters until a character from given L is encountered ; If a character from L is encountered , then the answer variable is incremented by the value obtained by using the mentioned formula and count is set to 0 ; For last remaining characters ; Driver code","```java
public static int countSubstringsWithoutChars(String s, char[] L) {
    int[] freq = new int[26];
    for (char c : L) {
      freq[c - 'a'] = 1;
    }
    int count = 0;
    int answer = 0;
    for (int i = 0; i < s.length(); i++) {
      if (freq[s.charAt(i) - 'a'] == 1) {
        answer += (count * (count + 1)) / 2;
        count = 0;
      } else {
        count++;
      }
    }
    answer += (count * (count + 1)) / 2;
    return answer;
  }
```","```python
def count_substrings_without_chars(s, L):
  freq = [0] * 26
  for char in L:
    freq[ord(char) - ord('a')] = 1
  count = 0
  answer = 0
  for i in range(len(s)):
    if freq[ord(s[i]) - ord('a')] == 1:
      answer += (count * (count + 1)) // 2
      count = 0
    else:
      count += 1
  answer += (count * (count + 1)) // 2
  return answer
```"
438,Program to accept Strings starting with a Vowel | Java program to accept String starting with Vowel ; Function to check if first character is vowel ; Function to check ; Driver code,"```java
import java.util.Scanner;

public class VowelStart {

    public static boolean startsWithVowel(String str) {
        if (str.length() == 0) {
            return false;
        }
        char firstChar = Character.toLowerCase(str.charAt(0));
        return firstChar == 'a' || firstChar == 'e' || firstChar == 'i' || firstChar == 'o' || firstChar == 'u';
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        if (startsWithVowel(inputString)) {
            System.out.println(""The string starts with a vowel."");
        } else {
            System.out.println(""The string does not start with a vowel."");
        }
    }
}
```","```python
def check_vowel(string):
  vowels = ""aeiouAEIOU""
  return string[0] in vowels
```"
439,Find the Nth occurrence of a character in the given String | Java implementation to find the Nth occurrence of a character ; Function to find the Nth occurrence of a character ; Loop to find the Nth occurrence of the character ; Driver Code,"```java
public static int findNthOccurrence(String str, char ch, int n) {
    int count = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) == ch) {
            count++;
            if (count == n) {
                return i;
            }
        }
    }
    return -1;
}
```","```python
def findNthOccurrence(string, char, n):
  count = 0
  for i in range(len(string)):
    if string[i] == char:
      count += 1
      if count == n:
        return i
  return -1
```"
440,Longest equal substring with cost less than K | Java program to find the maximum length of equal subString within a given cost ; Function to find the maximum length ; Fill the prefix array with the difference of letters ; Update the maximum length ; Driver code,"```java
public static int longestEqualSubstring(String s, int k) {
    int n = s.length();
    int[] prefix = new int[n + 1];
    for (int i = 1; i <= n; i++) {
        prefix[i] = prefix[i - 1] + (s.charAt(i - 1) - 'a');
    }
    int maxLength = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j <= n; j++) {
            int cost = Math.abs(prefix[j] - prefix[i]);
            if (cost <= k) {
                maxLength = Math.max(maxLength, j - i);
            }
        }
    }
    return maxLength;
}
```","```python
def longest_equal_substring(s, k):
  n = len(s)
  prefix = [0] * (n + 1)
  for i in range(1, n + 1):
    prefix[i] = prefix[i - 1] + ord(s[i - 1]) - ord('a')
  max_len = 0
  for i in range(n):
    for j in range(i + 1, n + 1):
      cost = abs(prefix[j] - prefix[i])
      if cost <= k:
        max_len = max(max_len, j - i)
  return max_len
```"
441,Jaro and Jaro | Java implementation of above approach ; Function to calculate the Jaro Similarity of two strings ; If the strings are equal ; Length of two strings ; Maximum distance upto which matching is allowed ; Count of matches ; Hash for matches ; Traverse through the first string ; Check if there is any matches ; If there is a match ; If there is no match ; Number of transpositions ; Count number of occurrences where two characters match but there is a third matched character in between the indices ; Find the next matched character in second string ; Return the Jaro Similarity ; Jaro Winkler Similarity ; If the jaro Similarity is above a threshold ; Find the length of common prefix ; If the characters match ; Else break ; Maximum of 4 characters are allowed in prefix ; Calculate jaro winkler Similarity ; Driver code ; Print Jaro - Winkler Similarity of two strings,"```java
public static double jaroWinklerSimilarity(String s1, String s2) {
    if (s1.equals(s2)) {
        return 1.0;
    }
    int len1 = s1.length();
    int len2 = s2.length();
    int maxDist = Math.max(len1, len2) / 2 - 1;
    int matches = 0;
    boolean[] s1Matches = new boolean[len1];
    boolean[] s2Matches = new boolean[len2];
    for (int i = 0; i < len1; i++) {
        for (int j = Math.max(0, i - maxDist); j <= Math.min(len2 - 1, i + maxDist); j++) {
            if (!s2Matches[j] && s1.charAt(i) == s2.charAt(j)) {
                s1Matches[i] = true;
                s2Matches[j] = true;
                matches++;
                break;
            }
        }
    }
    if (matches == 0) {
        return 0.0;
    }
    int transpositions = 0;
    int k = 0;
    for (int i = 0; i < len1; i++) {
        if (s1Matches[i]) {
            while (!s2Matches[k]) {
                k++;
            }
            if (s1.charAt(i) != s2.charAt(k)) {
                transpositions++;
            }
            k++;
        }
    }
    double jaro = (double) matches / len1 + (double) matches / len2 + (double) (matches - transpositions / 2) / matches;
    if (jaro > 0.7) {
        int prefixLen = 0;
        for (int i = 0; i < Math.min(4, Math.min(len1, len2)); i++) {
            if (s1.charAt(i) == s2.charAt(i)) {
                prefixLen++;
            } else {
                break;
            }
        }
        return jaro + 0.1 * prefixLen * (1 - jaro);
    }
    return jaro;
}

public static void main(String[] args) {
    String s1 = ""DWAYNE JOHNSON"";
    String s2 = ""THE ROCK"";
    System.out.println(""Jaro-Winkler Similarity: "" + jaroWinklerSimilarity(s1, s2));
}
```","```python
def jaro_winkler(str1, str2):
    if str1 == str2:
        return 1.0
    len1 = len(str1)
    len2 = len(str2)
    max_dist = max(len1, len2) // 2
    match_count = 0
    matches = [False] * len1
    for i in range(len1):
        for j in range(max(0, i - max_dist), min(len2, i + max_dist + 1)):
            if str1[i] == str2[j] and not matches[i]:
                matches[i] = True
                match_count += 1
                break
    transpositions = 0
    k = 0
    for i in range(len1):
        if matches[i]:
            while k < len2 and not matches[k]:
                k += 1
            if str1[i] != str2[k]:
                transpositions += 1
            k += 1
    jaro_sim = match_count / len1 + match_count / len2 + (match_count - transpositions / 2) / match_count if match_count else 0
    if jaro_sim > 0.7:
        prefix_len = 0
        for i in range(min(4, len1, len2)):
            if str1[i] == str2[i]:
                prefix_len += 1
            else:
                break
        return jaro_sim + 0.1 * prefix_len * (1 - jaro_sim)
    else:
        return jaro_sim

```"
442,Check if a word is present in a sentence | Java implementation of the approach ; Function that returns true if the word is found ; To break the sentence in words ; To temporarily store each individual word ; Comparing the current word with the word to be searched ; Driver code,"```java
public static boolean isWordPresent(String sentence, String word) {
    String[] words = sentence.split("" "");
    for (String currentWord : words) {
        if (currentWord.equals(word)) {
            return true;
        }
    }
    return false;
}
```","```python
def is_word_present(sentence, word):
  words = sentence.split()
  for current_word in words:
    if current_word == word:
      return True
  return False
```"
443,Check if a word is present in a sentence | Java implementation of the approach ; Function that returns true if the word is found ; To convert the word in uppercase ; To convert the complete sentence in uppercase ; To break the sentence in words ; To store the individual words of the sentence ; Comparing the current word with the word to be searched ; Driver code,"```java
public static boolean isWordPresent(String sentence, String word) {
  word = word.toUpperCase();
  sentence = sentence.toUpperCase();
  String[] words = sentence.split("" "");
  for (String currentWord : words) {
    if (currentWord.equals(word)) {
      return true;
    }
  }
  return false;
}
```","```python
def is_word_present(sentence, word):
  word = word.upper()
  sentence = sentence.upper()
  words = sentence.split()
  for current_word in words:
    if current_word == word:
      return True
  return False
```"
444,Count of 1 | Java implementation of the above approach ; Function to return the count of required characters ; While there are characters left ; Single bit character ; Two - bit character ; Update the count ; Driver code,"```java
public static int countOf1(int[] bits) {
    int count = 0;
    int i = 0;
    while (i < bits.length) {
      if (bits[i] == 0) {
        count++;
        i++;
      } else {
        count++;
        if (i + 1 < bits.length) {
          i += 2;
        } else {
          return -1;
        }
      }
    }
    return count;
  }
```","```python
def count_of_1(bits):
  count = 0
  i = 0
  while i < len(bits):
    if bits[i] == 1:
      count += 1
    i += 1
  return count
```"
445,Print the frequency of each character in Alphabetical order | Java implementation of the approach ; Function to print the frequency of each of the characters of s in alphabetical order ; To store the frequency of the characters ; Update the frequency array ; Print the frequency in alphatecial order ; If the current alphabet doesn 't  appear in the string ; Driver code,"```java
public static void printCharFrequency(String s) {
    int[] frequency = new int[26];
    for (int i = 0; i < s.length(); i++) {
      char ch = s.charAt(i);
      if (Character.isLetter(ch)) {
        frequency[Character.toLowerCase(ch) - 'a']++;
      }
    }
    for (int i = 0; i < 26; i++) {
      if (frequency[i] != 0) {
        System.out.println((char) (i + 'a') + "": "" + frequency[i]);
      }
    }
  }
```","```python
def print_char_frequencies(s):
  freq = [0] * 26
  for char in s:
    if char.isalpha():
      freq[ord(char.lower()) - ord('a')] += 1
  for i in range(26):
    if freq[i] > 0:
      print(chr(i + ord('a')), "":"", freq[i])
```"
446,Find the number obtained after concatenation of binary representation of M and N | Java implementation of the approach ; Function to convert decimal number n to its binary representation stored as an array arr [ ] ; Funtion to convert the number represented as a binary array arr [ ] into its decimal equivalent ; Function to concatenate the binary numbers and return the decimal result ; Number of bits in both the numbers ; Convert the bits in both the integers to the arrays a [ ] and b [ ] ; c [ ] will be the binary array for the result ; Update the c [ ] array ; Return the decimal equivalent of the result ; Driver code,"```java
public static int concatenateBinary(int M, int N) {
    int[] a = decimalToBinary(M);
    int[] b = decimalToBinary(N);
    int[] c = new int[a.length + b.length];
    for (int i = 0; i < a.length; i++) {
      c[i] = a[i];
    }
    for (int i = 0; i < b.length; i++) {
      c[i + a.length] = b[i];
    }
    return binaryToDecimal(c);
  }
  
  public static int[] decimalToBinary(int n) {
    int[] arr = new int[32];
    int i = 0;
    while (n > 0) {
      arr[i] = n % 2;
      n /= 2;
      i++;
    }
    return arr;
  }
  
  public static int binaryToDecimal(int[] arr) {
    int result = 0;
    int power = 0;
    for (int i = arr.length - 1; i >= 0; i--) {
      result += arr[i] * Math.pow(2, power);
      power++;
    }
    return result;
  }
```","```python
def decimalToBinary(n):
  arr = []
  while n:
    arr.append(n % 2)
    n //= 2
  return arr[::-1]

def binaryToDecimal(arr):
  n = 0
  for i in range(len(arr)):
    n += arr[i] * (2 ** i)
  return n

def concatenateBinary(M, N):
  a = decimalToBinary(M)
  b = decimalToBinary(N)
  c = a + b
  return binaryToDecimal(c)
```"
447,Find the number obtained after concatenation of binary representation of M and N | Java implementation of the approach ; Utility function to calculate binary length of a number . ; Function to concatenate the binary numbers and return the decimal result ; Find binary length of n ; left binary shift m and then add n ; Driver code,"```java
public static int concatenateBinary(int m, int n) {
    int binaryLength = binaryLength(n);
    return (m << binaryLength) + n;
  }
  
  public static int binaryLength(int n) {
    int count = 0;
    while (n != 0) {
      n >>= 1;
      count++;
    }
    return count;
  }
```","```python
def find_decimal(m, n):
  def binary_length(n):
    return len(bin(n)) - 2
  m <<= binary_length(n)
  return m + n
```"
448,XOR two binary strings of unequal lengths | Java implementation of the approach ; Function to insert n 0 s in the beginning of the given string ; Function to return the XOR of the given strings ; Lengths of the given strings ; Make both the strings of equal lengths by inserting 0 s in the beginning ; Updated length ; To store the resultant XOR ; Driver code,"```java
public static String xorOfUnequalStrings(String str1, String str2) {
    int len1 = str1.length();
    int len2 = str2.length();
    int maxLength = Math.max(len1, len2);
    str1 = insertZeros(str1, maxLength - len1);
    str2 = insertZeros(str2, maxLength - len2);
    String result = """";
    for (int i = 0; i < maxLength; i++) {
      if (str1.charAt(i) == str2.charAt(i)) {
        result += ""0"";
      } else {
        result += ""1"";
      }
    }
    return result;
  }
  
  public static String insertZeros(String str, int n) {
    return String.valueOf(new char[n]).replace('\0', '0') + str;
  }
```","```python
def xor_strings(str1, str2):
  len1 = len(str1)
  len2 = len(str2)
  if len1 < len2:
    str1 = '0' * (len2 - len1) + str1
  elif len2 < len1:
    str2 = '0' * (len1 - len2) + str2
  result = ''
  for i in range(len(str1)):
    if str1[i] == str2[i]:
      result += '0'
    else:
      result += '1'
  return result
```"
449,Generate Binary Strings of length N using Branch and Bound | Java Program to generate Binary Strings using Branch and Bound ; Creating a Node class ; Queue that maintains the list of live Nodes ; Utility function to generate binary strings of length n ; If list is full print combination ; Create a new vector for new combination ; iterate while length is not equal to n ; Driver code ; Initiate Generation Create a root Node ; Instantiate the Queue,"```java
import java.util.*;

class Node {
    String str;
    int len;

    Node(String str, int len) {
        this.str = str;
        this.len = len;
    }
}

class Solution {
    public void generateBinaryStrings(int n) {
        Queue<Node> q = new LinkedList<>();
        Node root = new Node("""", 0);
        q.offer(root);

        while (!q.isEmpty()) {
            Node curr = q.poll();
            if (curr.len == n) {
                System.out.println(curr.str);
            } else {
                q.offer(new Node(curr.str + ""0"", curr.len + 1));
                q.offer(new Node(curr.str + ""1"", curr.len + 1));
            }
        }
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        int n = 3;
        sol.generateBinaryStrings(n);
    }
}
```","```python
from collections import deque

class Node:
    def __init__(self, data, level):
        self.data = data
        self.level = level

def generate_binary_strings(n):
    q = deque()
    root = Node([], 0)
    q.append(root)
    while q:
        curr = q.popleft()
        if curr.level == n:
            print(''.join(str(i) for i in curr.data))
        else:
            for i in range(2):
                new_data = curr.data[:]
                new_data.append(i)
                new_node = Node(new_data, curr.level + 1)
                q.append(new_node)

def main():
    n = 3
    generate_binary_strings(n)

if __name__ == '__main__':
    main()
```"
450,Minimum operations required to make the string satisfy the given condition | Java implementation of the approach ; Function to return the minimum operations required ; To store the first and the last occurrence of all the characters ; Set the first and the last occurrence of all the characters to - 1 ; Update the occurrences of the characters ; Only set the first occurrence if it hasn 't already been set ; To store the minimum operations ; If the frequency of the current character in the string is less than 2 ; Count of characters to be removed so that the string starts and ends at the current character ; Driver code,"```java
public static int minOperations(String s) {
    int[] first = new int[26];
    int[] last = new int[26];
    Arrays.fill(first, -1);
    Arrays.fill(last, -1);
    for (int i = 0; i < s.length(); i++) {
        int index = s.charAt(i) - 'a';
        if (first[index] == -1) {
            first[index] = i;
        }
        last[index] = i;
    }
    int minOps = s.length();
    for (int i = 0; i < 26; i++) {
        if (first[i] != -1 && last[i] != -1) {
            int count = s.length() - (last[i] - first[i] + 1);
            minOps = Math.min(minOps, count);
        }
    }
    return minOps;
}
```","```python
def minOperations(s):
  first = {}
  last = {}
  for i in range(len(s)):
    if s[i] not in first:
      first[s[i]] = i
    last[s[i]] = i
  minOps = len(s)
  for char in first:
    if s.count(char) < 2:
      continue
    count = last[char] - first[char] + 1
    minOps = min(minOps, len(s) - count)
  return minOps
```"
451,"Queries to find the count of vowels in the substrings of the given string | Java implementation of the approach ; Function that returns true if ch is a vowel ; Function to return the count of vowels in the substring str [ l ... r ] ; To store the count of vowels ; For every character in the index range [ l , r ] ; If the current character is a vowel ; For every query ; Find the count of vowels for the current query ; Driver code","```java
public static boolean isVowel(char ch) {
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u';
}

public static int countVowels(String str, int l, int r) {
    int count = 0;
    for (int i = l; i <= r; i++) {
      if (isVowel(str.charAt(i))) {
        count++;
      }
    }
    return count;
  }
```","```python
def isVowel(ch):
  return ch.lower() in 'aeiou'

def countVowels(str, l, r):
  count = 0
  for i in range(l, r + 1):
    if isVowel(str[i]):
      count += 1
  return count

def main():
  str = ""aeioubcde""
  queries = [[0, 4], [1, 3], [2, 5]]
  for l, r in queries:
    print(countVowels(str, l, r))

if __name__ == ""__main__"":
  main()
```"
452,Convert a String to a Singly Linked List | Java program to Convert a String to a Singly Linked List ; Structure for a Singly Linked List ; Function to add a new node to the Linked List ; Function to convert the string to Linked List . ; curr pointer points to the current node where the insertion should take place ; Function to print the data present in all the nodes ; Driver code,"```java
class Node {
    char data;
    Node next;

    Node(char data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    Node head;

    public void addNode(char data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = newNode;
        } else {
            Node curr = head;
            while (curr.next != null) {
                curr = curr.next;
            }
            curr.next = newNode;
        }
    }

    public Node stringToLinkedList(String str) {
        for (int i = 0; i < str.length(); i++) {
            addNode(str.charAt(i));
        }
        return head;
    }

    public void printList() {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + "" "");
            curr = curr.next;
        }
    }
}

public class StringToLinkedList {
    public static void main(String[] args) {
        LinkedList list = new LinkedList();
        String str = ""GeeksForGeeks"";
        list.stringToLinkedList(str);
        list.printList();
    }
}
```","```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return

        curr = self.head
        while curr.next is not None:
            curr = curr.next
        curr.next = new_node

    def string_to_linked_list(self, string):
        for char in string:
            self.append(char)

    def print_list(self):
        curr = self.head
        while curr:
            print(curr.data, end="" "")
            curr = curr.next

# Driver Code
string = ""Hello""
linked_list = LinkedList()
linked_list.string_to_linked_list(string)
linked_list.print_list()
```"
453,Reduce the string to minimum length with the given operation | Java implementation of the approach ; Function to return the minimum possible length str can be reduced to with the given operation ; Stack to store the characters of the given string ; For every character of the string ; If the stack is empty then push the current character in the stack ; Get the top character ; If the top element is not equal to the current element and it only differs in the case ; Pop the top element from stack ; Else push the current element ; Driver code,"```java
public static int minLength(String str) {
    Stack<Character> stack = new Stack<>();
    for (int i = 0; i < str.length(); i++) {
      if (stack.isEmpty()) {
        stack.push(str.charAt(i));
      } else {
        char top = stack.peek();
        if (top != str.charAt(i) && Character.toLowerCase(top) == Character.toLowerCase(str.charAt(i))) {
          stack.pop();
        } else {
          stack.push(str.charAt(i));
        }
      }
    }
    return stack.size();
  }
```","```python
def reduce_string(str):
  stack = []
  for char in str:
    if not stack:
      stack.append(char)
    else:
      top = stack[-1]
      if top != char and top.lower() == char.lower():
        stack.pop()
      else:
        stack.append(char)
  return len(stack)
```"
454,Check whether two strings can be made equal by copying their characters with the adjacent ones | Java implementation of the above approach ; Function that returns true if both the strings can be made equal with the given operation ; Lengths of both the strings have to be equal ; To store the frequency of the characters of str1 ; For every character of str2 ; If current character of str2 also appears in str1 ; Driver code,"```java
public boolean canMakeEqual(String str1, String str2) {
    if (str1.length() != str2.length()) {
      return false;
    }
    int[] charCount = new int[26];
    for (char ch : str1.toCharArray()) {
      charCount[ch - 'a']++;
    }
    for (char ch : str2.toCharArray()) {
      if (charCount[ch - 'a'] == 0) {
        return false;
      }
      charCount[ch - 'a']--;
    }
    return true;
  }
```","```python
def can_be_equal(str1, str2):
  if len(str1) != len(str2):
    return False
  freq1 = {}
  for char in str1:
    if char in freq1:
      freq1[char] += 1
    else:
      freq1[char] = 1
  for char in str2:
    if char in freq1 and freq1[char] > 0:
      freq1[char] -= 1
    else:
      return False
  return True
```"
455,Minimum characters that are to be inserted such that no three consecutive characters are same | Java implementation of the approach ; Function to return the count of characters that are to be inserted in str such that no three consecutive characters are same ; To store the count of operations required ; A character needs to be inserted after str [ i + 1 ] ; Current three consecutive characters are not same ; Driver code,"```java
public static int countMinInsertions(String str) {
    int operations = 0;
    for (int i = 1; i < str.length() - 1; i++) {
      if (str.charAt(i) == str.charAt(i - 1) && str.charAt(i) == str.charAt(i + 1)) {
        operations++;
      }
    }
    return operations;
  }
```","```python
def min_insertions(str):
  n = len(str)
  count = 0
  for i in range(n - 2):
    if str[i] == str[i + 1] and str[i] == str[i + 2]:
      count += 1
  return count
```"
456,Find the number of strings formed using distinct characters of a given string | Java implementation of the approach ; Function to return the factorial of n ; Function to return the count of all possible strings that can be formed with the characters of the given string without repeating characters ; To store the distinct characters of the string str ; Driver code,"```java
public static int factorial(int n) {
    if (n == 0) {
        return 1;
    }
    return n * factorial(n - 1);
}

public static int countStrings(String str) {
    Set<Character> distinctChars = new HashSet<>();
    for (char c : str.toCharArray()) {
        distinctChars.add(c);
    }
    return factorial(distinctChars.size());
}

public static void main(String[] args) {
    String str = ""abcabc"";
    int count = countStrings(str);
    System.out.println(count);
}
```","```python
def factorial(n):
  if n == 0:
    return 1
  else:
    return n * factorial(n - 1)

def countStrings(str):
  distinctChars = set(str)
  return factorial(len(distinctChars))

def main():
  str = ""abcabc""
  print(countStrings(str))

if __name__ == ""__main__"":
  main()
```"
457,Find the character made by adding all the characters of the given string | Java implementation of the approach ; Function to return the required character ; To store the sum of the characters of the given string ; Add the current character to the sum ; Return the required character ; Driver code,"```java
char findCharacter(String str) {
  int sum = 0;
  for (int i = 0; i < str.length(); i++) {
    sum += str.charAt(i);
  }
  return (char) sum;
}
```","```python
def find_char(s):
  sum = 0
  for char in s:
    sum += ord(char)
  return chr(sum)
```"
458,"Reverse the given string in the range [ L , R ] | Java implementation of the approach ; Function to return the string after reversing characters in the range [ L , R ] ; Invalid range ; While there are characters to swap ; Swap ( str [ l ] , str [ r ] ) ; Driver code","```java
public static String reverseString(String str, int l, int r) {
    if (l < 0 || r >= str.length() || l > r) {
        return str;
    }
    while (l < r) {
        char temp = str.charAt(l);
        str = str.substring(0, l) + str.charAt(r) + str.substring(l + 1, r) + temp + str.substring(r + 1);
        l++;
        r--;
    }
    return str;
}
```","```python
def reverseString(str, l, r):
  if l < 0 or r >= len(str) or l > r:
    return str
  while l < r:
    str[l], str[r] = str[r], str[l]
    l += 1
    r -= 1
  return str
```"
459,"Program to Encrypt a String using ! and @ | Java program to Encrypt the String using ! and @ ; Function to encrypt the string ; evenPos is for storing encrypting char at evenPosition oddPos is for storing encrypting char at oddPosition ; Get the number of times the character is to be repeated ; if i is odd , print ' ! ' else print ' @ ' ; Driver code ; Encrypt the String","```java
public static String encryptString(String str) {
    StringBuilder evenPos = new StringBuilder();
    StringBuilder oddPos = new StringBuilder();
    for (int i = 0; i < str.length(); i++) {
        if (i % 2 == 0) {
            evenPos.append(str.charAt(i));
        } else {
            oddPos.append(str.charAt(i));
        }
    }
    StringBuilder encryptedStr = new StringBuilder();
    for (int i = 0; i < str.length(); i++) {
        if (i % 2 == 0) {
            encryptedStr.append('@');
        } else {
            encryptedStr.append('!');
        }
        for (int j = 0; j < evenPos.length(); j++) {
            encryptedStr.append(evenPos.charAt(j));
        }
        for (int j = 0; j < oddPos.length(); j++) {
            encryptedStr.append(oddPos.charAt(j));
        }
    }
    return encryptedStr.toString();
}
```","```python
def encrypt_string(string):
  evenPos = """"
  oddPos = """"
  for i in range(len(string)):
    if i % 2 == 0:
      evenPos += ""@""
    else:
      oddPos += ""!""
  return evenPos + oddPos
```"
460,Check if expression contains redundant bracket or not | Set 2 | Java program to check for redundant braces in the string ; Function to check for redundant braces ; count of no of signs ; Driver Code,"```java
public static boolean checkRedundantBraces(String expression) {
    int count = 0;
    for (int i = 0; i < expression.length(); i++) {
        if (expression.charAt(i) == '(') {
            count++;
        } else if (expression.charAt(i) == ')') {
            count--;
        } else if (expression.charAt(i) == '+' || expression.charAt(i) == '-' || expression.charAt(i) == '*' || expression.charAt(i) == '/' || expression.charAt(i) == '^' || expression.charAt(i) == '%') {
            if (count == 0) {
                return true;
            }
        }
    }
    return count != 0;
}
```","```python
def checkRedundantBrackets(expression):
  stack = []
  for char in expression:
    if char in ['+', '-', '*', '/', '(']:
      stack.append(char)
    elif char == ')':
      count = 0
      while stack[-1] != '(':
        stack.pop()
        count += 1
      stack.pop()
      if count == 0:
        return True
  return False
```"
461,Convert an unbalanced bracket sequence to a balanced sequence | Java implementation of the approach ; Function to return balancedBrackets string ; Initializing dep to 0 ; Stores maximum negative depth ; if dep is less than minDep ; if minDep is less than 0 then there is need to add ' ( ' at the front ; Reinitializing to check the updated string ; if dep is not 0 then there is need to add ' ) ' at the back ; Driver code,"```java
public static String balancedBrackets(String str) {
    int dep = 0;
    int minDep = 0;
    for (char c : str.toCharArray()) {
        if (c == '(') {
            dep++;
        } else if (c == ')') {
            dep--;
        }
        minDep = Math.min(minDep, dep);
    }
    if (minDep < 0) {
        str = new String(new char[-minDep]).replace('\0', '(') + str;
        dep = 0;
        for (char c : str.toCharArray()) {
            if (c == '(') {
                dep++;
            } else if (c == ')') {
                dep--;
            }
        }
    }
    if (dep != 0) {
        str = str + new String(new char[dep]).replace('\0', ')');
    }
    return str;
}
```","```python
def balancedBrackets(s):
  dep = 0
  minDep = 0
  for c in s:
    if c == '(':
      dep += 1
    elif c == ')':
      dep -= 1
    if dep < minDep:
      minDep = dep
  if minDep < 0:
    s = '(' * abs(minDep) + s
    dep = 0
    minDep = 0
    for c in s:
      if c == '(':
        dep += 1
      elif c == ')':
        dep -= 1
      if dep < minDep:
        minDep = dep
  if dep != 0:
    s += ')' * abs(dep)
  return s
```"
462,Minimum operations required to convert a binary string to all 0 s or all 1 s | Java implementation of the approach ; Function to return the count of minimum operations required ; Increment count when consecutive characters are different ; Answer is rounding off the ( count \/ 2 ) to lower ; Driver code,"```java
public static int minOperations(String s) {
    int count = 0;
    for (int i = 1; i < s.length(); i++) {
      if (s.charAt(i) != s.charAt(i - 1)) {
        count++;
      }
    }
    return (int) Math.floor((double) count / 2);
  }
```","```python
def minOperations(s):
  count = 0
  for i in range(1, len(s)):
    if s[i] != s[i - 1]:
      count += 1
  return count // 2
```"
463,Append a digit in the end to make the number equal to the length of the remaining string | Java implementation of the approach ; Function to return the required digit ; To store the position of the first numeric digit in the string ; To store the length of the string without the numeric digits in the end ; pw stores the current power of 10 and num is to store the number which is appended in the end ; If current character is a numeric digit ; Get the current digit ; Build the number ; If number exceeds the length ; Next power of 10 ; Append 0 in the end ; Required number that must be added ; If number is not a single digit ; Driver code,"```java
public static int appendDigit(String s) {
    int firstDigitPos = -1;
    int len = 0;
    int pw = 1;
    int num = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
        if (Character.isDigit(s.charAt(i))) {
            if (firstDigitPos == -1) {
                firstDigitPos = i;
            }
            len++;
        } else {
            if (firstDigitPos != -1) {
                break;
            }
        }
    }
    for (int i = firstDigitPos; i < s.length(); i++) {
        if (Character.isDigit(s.charAt(i))) {
            num += (s.charAt(i) - '0') * pw;
            pw *= 10;
            if (num > len) {
                pw *= 10;
                num = 0;
            }
        }
    }
    if (num == 0) {
        num = 1;
    }
    return num;
}
```","```python
def appendDigit(s):
  pos = -1
  l = 0
  pw = 1
  num = 0
  for i in range(len(s) - 1, -1, -1):
    if s[i].isdigit():
      pos = i
      break
    l += 1
  for i in range(pos, -1, -1):
    if s[i].isdigit():
      num += int(s[i]) * pw
      pw *= 10
      if num > l:
        pw *= 10
        num = 0
        s += '0'
  return num if num != 0 else 10 ** l - num
```"
464,Check whether str1 can be converted to str2 with the given operations | Java implementation of the approach ; Function that returns true if str1 can be converted to str2 with the given operations ; Traverse from left to right ; If the two characters do not match ; If possible to combine ; If not possible to combine ; If the two characters match ; If possible to convert one string to another ; Driver code,"```java
public static boolean canConvert(String str1, String str2) {
    if (str1.length() != str2.length()) {
        return false;
    }
    for (int i = 0; i < str1.length(); i++) {
        if (str1.charAt(i) != str2.charAt(i)) {
            if (str1.charAt(i) == 'a' && str2.charAt(i) == 'b') {
                continue;
            } else if (str1.charAt(i) == 'b' && str2.charAt(i) == 'a') {
                continue;
            } else {
                return false;
            }
        }
    }
    return true;
}
```","```python
def canConvert(str1, str2, operations):
  n = len(str1)
  m = len(str2)
  if n != m:
    return False
  i = 0
  while i < n:
    if str1[i] != str2[i]:
      if (str1[i], str2[i]) in operations or (str2[i], str1[i]) in operations:
        i += 1
      else:
        return False
    else:
      i += 1
  return True
```"
465,Reverse the Words of a String using Stack | Java implementation of the above approach ; Function to reverse the words of the given String without using strtok ( ) . ; Create an empty String stack ; Create an empty temporary String ; Traversing the entire String ; Push the temporary variable into the stack ; Assigning temporary variable as empty ; For the last word of the String ; Get the words in reverse order ; Driver code,"```java
public static String reverseWords(String str) {
    Stack<String> stack = new Stack<>();
    String temp = """";
    for (int i = 0; i < str.length(); i++) {
      if (str.charAt(i) != ' ') {
        temp += str.charAt(i);
      } else {
        stack.push(temp);
        temp = """";
      }
    }
    stack.push(temp);
    StringBuilder reversed = new StringBuilder();
    while (!stack.isEmpty()) {
      reversed.append(stack.pop()).append("" "");
    }
    return reversed.toString().trim();
  }
```","```python
def reverseWords(s):
  stack = []
  temp = """"
  for i in range(len(s)):
    if s[i] != "" "":
      temp += s[i]
    else:
      stack.append(temp)
      temp = """"
  stack.append(temp)
  result = """"
  while len(stack) > 0:
    result += stack.pop() + "" ""
  return result[:-1]
```"
466,Print an N x M matrix such that each row and column has all the vowels in it | Java implementation of the approach ; Function to print the required matrix ; Impossible to generate the required matrix ; Store all the vowels ; Print the matrix ; Print vowels for every index ; Shift the vowels by one ; Driver code,"```java
public static void printMatrix(int N, int M) {
    if (N * M < 5) {
        System.out.println(""Impossible to generate the required matrix"");
        return;
    }
    char[] vowels = {'a', 'e', 'i', 'o', 'u'};
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            System.out.print(vowels[(i * M + j) % 5] + "" "");
        }
        System.out.println();
    }
}
```","```python
def print_matrix(N, M):
  vowels = ['a', 'e', 'i', 'o', 'u']
  matrix = [['' for _ in range(M)] for _ in range(N)]
  for i in range(N):
    for j in range(M):
      matrix[i][j] = vowels[(i * M + j) % 5]
  for i in range(N):
    for j in range(M):
      print(matrix[i][j], end=' ')
    print()
```"
467,Check if a given string is made up of two alternating characters | Java implementation of the approach ; Function that returns true if the string is made up of two alternating characters ; Check if ith character matches with the character at index ( i + 2 ) ; If string consists of a single character repeating itself ; Driver code,"```java
public static boolean isAlternating(String str) {
    if (str.length() <= 1) {
      return true;
    }
    for (int i = 0; i < str.length() - 2; i++) {
      if (str.charAt(i) != str.charAt(i + 2)) {
        return false;
      }
    }
    return true;
  }
```","```python
def checkAlternatingCharacters(s):
  if len(s) <= 1:
    return True
  for i in range(len(s) - 2):
    if s[i] == s[i + 2]:
      return False
  return True
```"
468,Number of character corrections in the given strings to make them equal | Java implementation of the approach ; Function to return the count of operations required ; To store the count of operations ; No operation required ; One operation is required when any two characters are equal ; Two operations are required when none of the characters are equal ; Return the minimum count of operations required ; Driver code,"```java
public static int countOperations(String s1, String s2) {
    int operations = 0;
    for (int i = 0; i < s1.length(); i++) {
      if (s1.charAt(i) == s2.charAt(i)) {
        operations++;
      } else {
        operations += 2;
      }
    }
    return operations;
  }
```","```python
def count_operations(str1, str2):
  operations = 0
  for i in range(len(str1)):
    if str1[i] == str2[i]:
      operations += 1
    else:
      operations += 2
  return operations
```"
469,Check if string can be made lexicographically smaller by reversing any substring | Java implementation of the approach ; Function that returns true if s can be made lexicographically smaller by reversing a sub - string in s ; Traverse in the string ; Check if s [ i + 1 ] < s [ i ] ; Not possible ; Driver code,"```java
public static boolean canBeMadeLexicographicallySmaller(String s) {
    for (int i = 0; i < s.length() - 1; i++) {
      if (s.charAt(i + 1) < s.charAt(i)) {
        return true;
      }
    }
    return false;
  }
```","```python
def can_be_smaller(s):
  for i in range(len(s) - 1):
    if s[i + 1] < s[i]:
      return True
  return False
```"
470,Count of sub | Java implementation of the approach ; Function to return the count of required sub - strings ; Number of sub - strings from position of current x to the end of str ; To store the number of characters before x ; Driver code,"```java
public static int countOfSub(String str, char x) {
    int count = 0;
    int charBeforeX = 0;
    for (int i = 0; i < str.length(); i++) {
      if (str.charAt(i) == x) {
        count += str.length() - i;
        charBeforeX = 0;
      } else {
        charBeforeX++;
      }
    }
    return count;
  }
```","```python
def countOfSub(str, x):
  n = len(str)
  count = 0
  for i in range(n):
    if str[i] == x:
      count += n - i
  return count
```"
471,Count of sub | Java implementation of the approach ; Function to return the count of possible sub - strings of length n ; Driver code,"```java
public static int countOfSub(int n) {
    if (n <= 0) {
        return 0;
    }
    return (int) Math.pow(2, n);
}
```","```python
def count_sub(n):
  return 2**n
```"
472,Count of sub | Java implementation of the approach ; Function to return the number of sub - strings that do not contain the given character c ; Length of the string ; Traverse in the string ; If current character is different from the given character ; Update the number of sub - strings ; Reset count to 0 ; For the characters appearing after the last occurrence of c ; Driver code,"```java
public static int countOfSub(String str, char c) {
    int count = 0;
    int n = str.length();
    for (int i = 0; i < n; i++) {
      if (str.charAt(i) != c) {
        count++;
      } else {
        count = 0;
      }
    }
    return count;
  }
```","```python
def count_sub(s, c):
  n = len(s)
  count = 0
  for i in range(n):
    if s[i] != c:
      count += 1
    else:
      count = 0
  return count
```"
473,Minimize ASCII values sum after removing all occurrences of one character | Java implementation of the approach ; Function to return the minimized sum ; To store the occurrences of each character of the string ; Update the occurrence ; Calculate the sum ; Get the character which is contributing the maximum value to the sum ; Count of occurrence of the character multiplied by its ASCII value ; Return the minimized sum ; Driver code,"```java
public static int minimizedASCIISum(String str) {
    int[] charCount = new int[256];
    for (int i = 0; i < str.length(); i++) {
        charCount[str.charAt(i)]++;
    }
    int sum = 0;
    for (int i = 0; i < 256; i++) {
        sum += i * charCount[i];
    }
    int maxChar = 0;
    for (int i = 0; i < 256; i++) {
        if (charCount[i] * i > charCount[maxChar] * maxChar) {
            maxChar = i;
        }
    }
    return sum - charCount[maxChar] * maxChar;
}
```","```python
def minimize_ascii_sum(s):
  occurrences = {}
  for char in s:
    if char in occurrences:
      occurrences[char] += 1
    else:
      occurrences[char] = 1
  total_sum = sum(ord(char) * count for char, count in occurrences.items())
  max_char = max(occurrences, key=lambda char: ord(char) * occurrences[char])
  return total_sum - ord(max_char) * occurrences[max_char]
```"
474,Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | Java implementation of the approach ; Function that returns true if s is palindrome ; Function to return the required index ; Copy the ith character in S ; Copy all the character of string s2 in Temp ; Check whether the string is palindrome ; Driver code,"```java
public static boolean isPalindrome(String s) {
    int n = s.length();
    for (int i = 0; i < n / 2; i++) {
        if (s.charAt(i) != s.charAt(n - i - 1)) {
            return false;
        }
    }
    return true;
}

public static int findIndex(String s1, String s2) {
    int n1 = s1.length();
    int n2 = s2.length();
    for (int i = 0; i <= n2; i++) {
        String temp = s1.substring(0, n1 - i) + s2.substring(i);
        if (isPalindrome(temp)) {
            return i;
        }
    }
    return -1;
}
```","```python
def isPalindrome(s):
  return s == s[::-1]

def findIndex(S1, S2):
  for i in range(len(S2)):
    temp = S1[:i+1] + S2[i:]
    if isPalindrome(temp):
      return i
  return -1
```"
475,"Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | Java implementation of the above approach ; Function that returns true if the sub - String starting from index i and ending at index j is a palindrome ; Function to get the required index ; Start comparing the two Strings from both ends . ; Break from the loop at first mismatch ; If it is possible to concatenate the Strings to form palindrome , return index ; If remaining part for s2 is palindrome ; If remaining part for s1 is palindrome ; If not possible , return - 1 ; Driver Code","```java
public static int findPalindromeIndex(String s1, String s2) {
    int i = s1.length() - 1;
    int j = 0;
    while (i >= 0 && j < s2.length()) {
        if (s1.charAt(i) == s2.charAt(j)) {
            i--;
            j++;
        } else {
            break;
        }
    }
    if (i < 0) {
        return j;
    } else if (isPalindrome(s2.substring(j))) {
        return j;
    } else if (isPalindrome(s1.substring(0, i + 1))) {
        return i + 1;
    }
    return -1;
}

private static boolean isPalindrome(String s) {
    int i = 0;
    int j = s.length() - 1;
    while (i < j) {
        if (s.charAt(i) != s.charAt(j)) {
            return false;
        }
        i++;
        j--;
    }
    return true;
}
```","```python
def isPalindrome(s, i, j):
  while i < j:
    if s[i] != s[j]:
      return False
    i += 1
    j -= 1
  return True

def findIndex(s1, s2):
  n1 = len(s1)
  n2 = len(s2)
  i = n1 - 1
  j = 0
  while i >= 0 and j < n2:
    if s1[i] != s2[j]:
      break
    i -= 1
    j += 1
  if i < 0 or j == n2:
    return j
  if isPalindrome(s2, j, n2 - 1):
    return j
  if isPalindrome(s1, 0, i):
    return i + 1
  return -1 
```"
476,Acronym words | Java implementation of the approach ; Function to return the number of strings that can be an acronym for other strings ; Frequency array to store the frequency of the first character of every string in the array ; To store the count of required strings ; Current word ; Frequency array to store the frequency of each of the character of the current string ; Check if the frequency of every character in the current string is <= its value in freq [ ] ; First character of the current string ; Driver code,"```java
public static int countAcronyms(String[] words) {
    int[] freq = new int[26];
    int count = 0;
    for (String word : words) {
      freq[word.charAt(0) - 'a']++;
    }
    for (String word : words) {
      int[] charFreq = new int[26];
      for (char c : word.toCharArray()) {
        charFreq[c - 'a']++;
      }
      boolean valid = true;
      for (int i = 0; i < 26; i++) {
        if (charFreq[i] > freq[i]) {
          valid = false;
          break;
        }
      }
      if (valid) {
        count++;
      }
    }
    return count;
  }
```","```python
def count_acronyms(words):
  freq = [0] * 26
  count = 0
  for word in words:
    freq[ord(word[0]) - ord('a')] += 1
  for word in words:
    current_freq = [0] * 26
    for char in word:
      current_freq[ord(char) - ord('a')] += 1
    flag = True
    for i in range(26):
      if current_freq[i] > freq[i]:
        flag = False
        break
    if flag:
      count += 1
  return count
```"
477,Sub | Java implementation of the approach ; Function that returns true if every lowercase character appears atmost once ; every character frequency must be not greater than one ; Function that returns the modified good string if possible ; If the length of the string is less than n ; To store frequency of each character ; Sub - strings of length 26 ; Get the frequency of each character in the current sub - string ; Check if we can get sub - string containing all the 26 characters ; Find which character is missing ; Fill with missing characters ; Find the next missing character ; Return the modified good string ; Driver code,"```java
public static String goodString(String s, int n) {
    if (s.length() < n) {
        return """";
    }
    int[] freq = new int[26];
    for (int i = 0; i <= s.length() - n; i++) {
        Arrays.fill(freq, 0);
        for (int j = i; j < i + n; j++) {
            freq[s.charAt(j) - 'a']++;
        }
        boolean allPresent = true;
        int missing = -1;
        for (int j = 0; j < 26; j++) {
            if (freq[j] == 0) {
                allPresent = false;
                missing = j;
                break;
            }
        }
        if (allPresent) {
            return s.substring(i, i + n);
        } else {
            if (missing != -1) {
                String temp = s.substring(i, i + n);
                for (int j = 0; j < n; j++) {
                    if (freq[temp.charAt(j) - 'a'] > 1) {
                        temp = temp.substring(0, j) + (char)('a' + missing) + temp.substring(j + 1);
                        break;
                    }
                }
                return temp;
            }
        }
    }
    return """";
}
```","```python
def goodString(s, n):
  if len(s) < n:
    return ""Not possible""
  freq = [0] * 26
  for i in range(n):
    freq[ord(s[i]) - ord('a')] += 1
  for i in range(n, len(s)):
    if all(x <= 1 for x in freq):
      return s[:i]
    freq[ord(s[i - n]) - ord('a')] -= 1
    freq[ord(s[i]) - ord('a')] += 1
  if all(x <= 1 for x in freq):
    return s
  missing = -1
  for i in range(26):
    if freq[i] == 0:
      missing = i
      break
  res = s
  for i in range(len(s) - n, -1, -1):
    if ord(s[i]) - ord('a') == missing:
      res = s[:i] + chr(missing + ord('a')) + s[i:]
      break
  if missing == -1:
    return ""Not possible""
  for i in range(26):
    if freq[i] == 0 and i != missing:
      res = res + chr(i + ord('a'))
      break
  return res
```"
478,Modify the string by swapping continuous vowels or consonants | Java implementation of the above approach ; Function to check if a character is a vowel ; Function to swap two consecutively repeated vowels or consonants ; Traverse through the length of the string ; Check if the two consecutive characters are vowels or consonants ; swap the two characters ; Driver code,"```java
public static String modifyString(String str) {
    StringBuilder sb = new StringBuilder(str);
    for (int i = 0; i < sb.length() - 1; i++) {
        if (isVowel(sb.charAt(i)) == isVowel(sb.charAt(i + 1))) {
            swap(sb, i, i + 1);
        }
    }
    return sb.toString();
}

public static boolean isVowel(char ch) {
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
}

public static void swap(StringBuilder sb, int i, int j) {
    char temp = sb.charAt(i);
    sb.setCharAt(i, sb.charAt(j));
    sb.setCharAt(j, temp);
}
```","```python
def swap_consecutive_vowels_consonants(s):
  def is_vowel(ch):
    return ch.lower() in 'aeiou'

  def swap(i):
    if i < len(s) - 1:
      if (is_vowel(s[i]) and is_vowel(s[i + 1])) or (not is_vowel(s[i]) and not is_vowel(s[i + 1])):
        s[i], s[i + 1] = s[i + 1], s[i]

  for i in range(len(s)):
    swap(i)
  return ''.join(s)
```"
479,Find the lexicographically largest palindromic Subsequence of a String | Java program to find the largest palindromic subsequence ; Function to find the largest palindromic subsequence ; Find the largest character ; Append all occurrences of largest character to the resultant string ; Driver Code,"```java
public static String longestPalindromeSubsequence(String s) {
    int n = s.length();
    if (n <= 1) {
        return s;
    }
    char largestChar = 'a';
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) > largestChar) {
            largestChar = s.charAt(i);
        }
    }
    StringBuilder result = new StringBuilder();
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == largestChar) {
            result.append(s.charAt(i));
        }
    }
    return result.toString();
}
```","```python
def longestPalindromeSubsequence(s):
  n = len(s)
  dp = [[0 for _ in range(n)] for _ in range(n)]
  for i in range(n):
    dp[i][i] = 1
  for i in range(n - 2, -1, -1):
    for j in range(i + 1, n):
      if s[i] == s[j]:
        dp[i][j] = dp[i + 1][j - 1] + 2
      else:
        dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
  i = 0
  j = n - 1
  result = """"
  while i <= j:
    if s[i] == s[j]:
      result += s[i]
      i += 1
      j -= 1
    elif dp[i + 1][j] > dp[i][j - 1]:
      i += 1
    else:
      j -= 1
  return result
```"
480,"Generate lexicographically smallest string of 0 , 1 and 2 with adjacent swaps allowed | Java implementation of the approach ; Function to print the required string ; count number of 1 s ; To check if the all the 1 s have been used or not ; Print all the 1 s if any 2 is encountered ; If str [ i ] = 0 or str [ i ] = 2 ; If 1 s are not printed yet ; Driver code","```java
public static void smallestString(int n, int k) {
    char[] str = new char[n];
    int count1 = 0;
    for (int i = 0; i < n; i++) {
        if (k > 0) {
            str[i] = '1';
            k--;
            count1++;
        } else {
            str[i] = '0';
        }
    }
    boolean flag = false;
    for (int i = 0; i < n; i++) {
        if (str[i] == '2') {
            flag = true;
        }
        if (str[i] == '0' || str[i] == '2') {
            if (flag && count1 > 0) {
                for (int j = 0; j < count1; j++) {
                    System.out.print('1');
                }
                count1 = 0;
            }
            System.out.print(str[i]);
        }
    }
    if (count1 > 0) {
        for (int i = 0; i < count1; i++) {
            System.out.print('1');
        }
    }
    System.out.println();
}
```","```python
def lexicographicallySmallestString(n, k):
  str = ['0'] * n
  count = k
  i = 0
  while i < n:
    if str[i] == '0' or str[i] == '2':
      if count > 0:
        str[i] = '1'
        count -= 1
    if str[i] == '2':
      while count > 0:
        str[i] = '1'
        count -= 1
        i += 1
        if i == n:
          break
    i += 1
  return ''.join(str)
```"
481,"K length words that can be formed from given characters without repetition | Java implementation of the approach ; Function to return the required count ; To store the count of distinct characters in str ; Traverse str character by character ; If current character is appearing for the first time in str ; Increment the distinct character count ; Update the appearance of the current character ; Since P ( n , r ) = n ! \/ ( n - r ) ! ; Return the answer ; Driver code","```java
public static int countKLengthWords(String str, int k) {
    int[] charCount = new int[26];
    int distinctChars = 0;
    for (int i = 0; i < str.length(); i++) {
      if (charCount[str.charAt(i) - 'a'] == 0) {
        distinctChars++;
      }
      charCount[str.charAt(i) - 'a']++;
    }
    return factorial(distinctChars) / factorial(distinctChars - k);
  }

  private static int factorial(int n) {
    if (n == 0) {
      return 1;
    }
    return n * factorial(n - 1);
  }
```","```python
def countKLengthWords(str, k):
  n = len(str)
  distinct_char_count = 0
  char_count = {}
  for i in range(n):
    if str[i] not in char_count:
      distinct_char_count += 1
      char_count[str[i]] = 1
    else:
      char_count[str[i]] += 1
  fact = [1] * (distinct_char_count + 1)
  for i in range(1, distinct_char_count + 1):
    fact[i] = fact[i - 1] * i
  return fact[distinct_char_count] // fact[distinct_char_count - k]
```"
482,Find the number in a range having maximum product of the digits | Java Program to find the number in a range having maximum product of the digits ; Returns the product of digits of number x ; This function returns the number having maximum product of the digits ; Converting both integers to strings string a = l . ToString ( ) ; ; Let the current answer be r ; Stores the current number having current digit one less than current digit in b ; Replace all following digits with 9 to maximise the product ; Convert string to number ; Check if it lies in range and its product is greater than max product ; Driver Code,"```java
public static int maxDigitProduct(int l, int r) {
    String a = String.valueOf(l);
    int r1 = l;
    int maxProduct = productOfDigits(l);
    for (int i = 0; i < a.length(); i++) {
        String b = a.substring(0, i) + (char) (a.charAt(i) - 1) + ""9"".repeat(a.length() - i - 1);
        int num = Integer.parseInt(b);
        if (num >= l && num <= r && productOfDigits(num) > maxProduct) {
            r1 = num;
            maxProduct = productOfDigits(num);
        }
    }
    return r1;
}

public static int productOfDigits(int x) {
    int prod = 1;
    while (x > 0) {
        prod *= x % 10;
        x /= 10;
    }
    return prod;
}
```","```python
def find_max_product_number(l, r):
  a = str(l)
  r = l
  for i in range(len(a) - 1, -1, -1):
    b = a[:i] + str(int(a[i]) - 1) + '9' * (len(a) - i - 1)
    b = int(b)
    if l <= b <= r and product_of_digits(b) > product_of_digits(r):
      r = b
  return r

def product_of_digits(x):
  product = 1
  for digit in str(x):
    product *= int(digit)
  return product
```"
483,Concatenate suffixes of a String | Java implementation of the approach ; Function to print the expansion of the string ; Take sub - string from i to n - 1 ; Print the sub - string ; Driver code,"```java
public static void printSuffixes(String str) {
    for (int i = 0; i < str.length(); i++) {
        System.out.println(str.substring(i));
    }
}
```","```python
def print_expansions(s):
  n = len(s)
  for i in range(n):
    print(s[i:n])
```"
484,"Construct a binary string following the given constraints | Java implementation of the approach ; Function to print a binary string which has ' a ' number of 0 ' s , ▁ ' b ' ▁ number ▁ of ▁ 1' s and there are at least ' x ' indices such that s [ i ] != s [ i + 1 ] ; Divide index value by 2 and store it into d ; If index value x is even and x \/ 2 is not equal to a ; Loop for d for each d print 10 ; subtract d from a and b ; Loop for b to print remaining 1 's ; Loop for a to print remaining 0 's ; Driver code","```java
public static void printBinaryString(int a, int b, int x) {
    int d = x / 2;
    if (x % 2 == 0 && x / 2 != a) {
      for (int i = 0; i < d; i++) {
        System.out.print(""10"");
      }
      a -= d;
      b -= d;
    }
    for (int i = 0; i < b; i++) {
      System.out.print(""1"");
    }
    for (int i = 0; i < a; i++) {
      System.out.print(""0"");
    }
  }
```","```python
def printBinaryString(a, b, x):
  d = x // 2
  if x % 2 == 0 and d != a:
    for _ in range(d):
      print(""10"", end="""")
    a -= d
    b -= d
  for _ in range(b):
    print(""1"", end="""")
  for _ in range(a):
    print(""0"", end="""")
```"
485,Check If every group of a ' s ▁ is ▁ followed ▁ by ▁ a ▁ group ▁ of ▁ b ' s of same length | Java implementation of the above approach ; Function to match whether there are always n consecutive b ' s ▁ followed ▁ by ▁ n ▁ consecutive ▁ a ' s throughout the string ; Traverse through the string ; Count a 's in current segment ; Count b 's in current segment ; If both counts are not same . ; Driver code,"```java
public static boolean checkAB(String str) {
    int aCount = 0;
    int bCount = 0;
    for (int i = 0; i < str.length(); i++) {
      if (str.charAt(i) == 'a') {
        aCount++;
      } else if (str.charAt(i) == 'b') {
        bCount++;
      } else {
        return false;
      }
      if (aCount != 0 && bCount != 0 && aCount != bCount) {
        return false;
      }
      if (aCount != 0 && bCount != 0 && aCount == bCount) {
        aCount = 0;
        bCount = 0;
      }
    }
    return (aCount == 0 && bCount == 0);
  }
```","```python
def check_groups(s: str) -> bool:
  n = len(s)
  i = 0
  while i < n:
    count_a = 0
    count_b = 0
    while i < n and s[i] == 'a':
      count_a += 1
      i += 1
    while i < n and s[i] == 'b':
      count_b += 1
      i += 1
    if count_a != count_b:
      return False
  return True
```"
486,Length of longest consecutive ones by at most one swap in a Binary String | Java program to find length of longest consecutive ones by at most one swap in a Binary String ; Function to calculate the length of the longest consecutive 1 's ; To count all 1 's in the string ; To store cumulative 1 's ; Counting cumulative 1 's from left ; If 0 then start new cumulative one from that i ; perform step 3 of the approach ; step 3 ; Driver Code ; string,"```java
public static int longestConsecutiveOnes(String s) {
    int n = s.length();
    int[] ones = new int[n + 1];
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '1') {
            count++;
        }
        ones[i + 1] = count;
    }
    int maxLen = 0;
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == '0') {
            maxLen = Math.max(maxLen, ones[i] + ones[i + 2]);
        } else {
            maxLen = Math.max(maxLen, ones[i + 1]);
        }
    }
    return maxLen;
}
```","```python
def longestOnes(s):
  n = len(s)
  max_len = 0
  cumulative_ones = [0] * (n + 1)
  for i in range(n):
    if s[i] == '1':
      cumulative_ones[i + 1] = cumulative_ones[i] + 1
    else:
      cumulative_ones[i + 1] = cumulative_ones[i]
  for i in range(n):
    for j in range(i + 1, n + 1):
      if s[i] == '0' and s[j - 1] == '0':
        max_len = max(max_len, cumulative_ones[j] - cumulative_ones[i] + j - i - 1)
      else:
        max_len = max(max_len, cumulative_ones[j] - cumulative_ones[i])
  return max_len
```"
487,Maximum length substring with highest frequency in a string | Java program to find maximum occurred subString of a String ; Function to return maximum occurred subString of a String ; Size of the String ; To store maximum frequency ; To store String which has maximum frequency ; Return subString which has maximum frequency ; Driver code ; Function call,"```java
public static String maxFreqSubstring(String str) {
    if (str == null || str.isEmpty()) {
        return """";
    }
    int maxFreq = 0;
    String maxFreqStr = """";
    for (int i = 0; i < str.length(); i++) {
        for (int j = i + 1; j <= str.length(); j++) {
            String subStr = str.substring(i, j);
            int freq = 0;
            for (int k = 0; k <= str.length() - subStr.length(); k++) {
                if (str.substring(k, k + subStr.length()).equals(subStr)) {
                    freq++;
                }
            }
            if (freq > maxFreq) {
                maxFreq = freq;
                maxFreqStr = subStr;
            }
        }
    }
    return maxFreqStr;
}
```","```python
def max_freq_substring(s):
  n = len(s)
  max_freq = 0
  max_substring = """"
  for i in range(n):
    for j in range(i, n):
      substring = s[i:j+1]
      freq = s.count(substring)
      if freq > max_freq:
        max_freq = freq
        max_substring = substring
  return max_substring

```"
488,Lexicographically smallest substring with maximum occurrences containing a ' s ▁ and ▁ b ' s only | Java program to Find the lexicographically smallest substring in a given string with maximum frequency and contains a ' s ▁ and ▁ b ' s only ; Function to Find the lexicographically smallest substring in a given string with maximum frequency and contains a ' s ▁ and ▁ b ' s only . ; To store frequency of digits ; size of string ; Take lexicographically larger digit in b ; get frequency of each character ; If no such string exits ; Maximum frequency ; Driver program,"```java
public static String smallestSubstring(String str) {
    if (str == null || str.isEmpty()) {
        return """";
    }
    int n = str.length();
    int[] freq = new int[26];
    for (int i = 0; i < n; i++) {
        if (str.charAt(i) == 'a' || str.charAt(i) == 'b') {
            freq[str.charAt(i) - 'a']++;
        }
    }
    if (freq['b' - 'a'] == 0 || freq['s' - 'a'] == 0) {
        return """";
    }
    int maxFreq = Math.max(freq['b' - 'a'], freq['s' - 'a']);
    String smallestSubstring = """";
    int start = 0;
    int end = 0;
    int currentFreq = 0;
    while (end < n) {
        if (str.charAt(end) == 'a' || str.charAt(end) == 'b') {
            currentFreq++;
        }
        if (currentFreq == maxFreq) {
            if (smallestSubstring.isEmpty() || str.substring(start, end + 1).compareTo(smallestSubstring) < 0) {
                smallestSubstring = str.substring(start, end + 1);
            }
            if (str.charAt(start) == 'a' || str.charAt(start) == 'b') {
                currentFreq--;
            }
            start++;
        }
        end++;
    }
    return smallestSubstring;
}
```","```python
def findLexicographicallySmallestSubstring(str1):
  frequency = {}
  n = len(str1)
  for i in range(n):
    if str1[i] in frequency:
      frequency[str1[i]] += 1
    else:
      frequency[str1[i]] = 1
  max_frequency = 0
  for key in frequency:
    if key == 's' or key == 'b':
      max_frequency = max(max_frequency, frequency[key])
  if max_frequency == 0:
    return ""No such string exists""
  result = ''
  for key in frequency:
    if key == 's' or key == 'b':
      if frequency[key] == max_frequency:
        if result == '':
          result = key * max_frequency
        else:
          if key > result[0]:
            result = key * max_frequency
  return result
```"
489,Minimum steps to convert one binary string to other only using negation | Java implementation of the above approach ; Function to find the minimum steps to convert string a to string b ; array to mark the positions needed to be negated ; If two character are not same then they need to be negated ; To count the blocks of 1 ; To count the number of 1 ' s ▁ in ▁ ▁ each ▁ block ▁ of ▁ 1' s ; For the last block of 1 's ; Driver code,"```java
public static int minSteps(String a, String b) {
    if (a.length() != b.length()) {
        return -1;
    }
    int[] negated = new int[a.length()];
    for (int i = 0; i < a.length(); i++) {
        if (a.charAt(i) != b.charAt(i)) {
            negated[i] = 1;
        }
    }
    int count = 0;
    int steps = 0;
    for (int i = 0; i < negated.length; i++) {
        if (negated[i] == 1) {
            count++;
        } else {
            if (count > 0) {
                steps += count / 2 + count % 2;
                count = 0;
            }
        }
    }
    if (count > 0) {
        steps += count / 2 + count % 2;
    }
    return steps;
}
```","```python
def minSteps(a, b):
  n = len(a)
  negated = [False] * n
  for i in range(n):
    if a[i] != b[i]:
      negated[i] = True
  blocks = 0
  count = 0
  for i in range(n):
    if negated[i]:
      blocks += 1
      count = 1
    elif negated[i] == False and count > 0:
      count += 1
    else:
      count = 0
  if count > 0:
    blocks += 1
  return blocks
```"
490,Generate a sequence with the given operations | Java Implementation of above approach ; function to find minimum required permutation ; Driver code,"```java
import java.util.*;
public class Solution {
    public static int[] findMinPermutation(int[] arr, int n, int k) {
        int[] res = new int[n];
        for (int i = 0; i < n; i++) {
            res[i] = i + 1;
        }
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (res[i] != arr[i]) {
                count++;
            }
        }
        if (count > k) {
            return new int[]{-1};
        }
        int[] temp = new int[n];
        for (int i = 0; i < n; i++) {
            temp[i] = arr[i];
        }
        Arrays.sort(temp);
        int j = 0;
        for (int i = 0; i < n; i++) {
            if (res[i] != arr[i]) {
                res[i] = temp[j];
                j++;
            }
        }
        return res;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        int[] res = findMinPermutation(arr, n, k);
        if (res[0] == -1) {
            System.out.println(""Not Possible"");
        } else {
            for (int i = 0; i < n; i++) {
                System.out.print(res[i] + "" "");
            }
        }
    }
}
```","```python
def findMinPerm(arr, n):
  res = 0
  for i in range(n - 1):
    if arr[i] > arr[i + 1]:
      res += 1
  return res
```"
491,Number of ways to swap two bit of s1 so that bitwise OR of s1 and s2 changes | Java program to find no of ways to swap bits of s1 so that bitwise OR of s1 and s2 changes ; Function to find number of ways ; initialise result that store No . of swaps required ; Traverse both strings and check the bits as explained ; calculate result ; Driver code,"```java
public static int countSwaps(String s1, String s2) {
    int result = 0;
    for (int i = 0; i < s1.length(); i++) {
      if (s1.charAt(i) != s2.charAt(i) && s1.charAt(i) == '0' && s2.charAt(i) == '1') {
        result++;
      }
    }
    return result;
  }
```","```python
def count_swaps(s1, s2):
  result = 0
  for i in range(len(s1)):
    if s1[i] != s2[i]:
      if s1[i] == '0':
        result += 1
  return result
```"
492,Find the player who rearranges the characters to get a palindrome string first | Java program to print the winner of the game ; Function that returns the winner of the game ; Initialize the freq array to 0 ; Iterate and count the frequencies of each character in the string ; Count the odd occurring character ; If odd occurrence ; Check condition for Player - 1 winning the game ; Driver code ; Function call that returns the winner,"```java
public static String findWinner(String str) {
    int[] freq = new int[26];
    for (int i = 0; i < str.length(); i++) {
      freq[str.charAt(i) - 'a']++;
    }
    int oddCount = 0;
    for (int i = 0; i < 26; i++) {
      if (freq[i] % 2 != 0) {
        oddCount++;
      }
    }
    if (oddCount > 1) {
      return ""Player 2"";
    }
    return ""Player 1"";
  }
```","```python
def find_winner(s):
  freq = [0] * 26
  for char in s:
    freq[ord(char) - ord('a')] += 1
  odd_count = 0
  for count in freq:
    if count % 2 != 0:
      odd_count += 1
  if odd_count <= 1:
    return ""Player 1""
  else:
    return ""Player 2""
```"
493,Maximum sum and product of the M consecutive digits in a number | Java implementation of the above approach ; Function to find the maximum product ; Driver code,"```java
public static int maxProduct(int num, int k) {
    if (num < 0) {
        num = -num;
    }
    String str = String.valueOf(num);
    if (str.length() < k) {
        return -1;
    }
    int maxProduct = 0;
    for (int i = 0; i <= str.length() - k; i++) {
        int product = 1;
        for (int j = i; j < i + k; j++) {
            product *= Character.getNumericValue(str.charAt(j));
        }
        maxProduct = Math.max(maxProduct, product);
    }
    return maxProduct;
}
```","```python
def max_product(num, M):
  n = len(str(num))
  if M > n:
    return -1
  max_prod = 1
  for i in range(n - M + 1):
    prod = 1
    for j in range(i, i + M):
      prod *= int(str(num)[j])
    max_prod = max(max_prod, prod)
  return max_prod
```"
494,"Replace all consonants with nearest vowels in a string | Java program to replace all consonants with nearest vowels in a string ; Function to check if a character is vowel or not ; Function to replace consonant with nearest vowels ; if , string element is vowel , jump to next element ; check if consonant lies between two vowels , if it lies , than replace it with nearest vowel ; here the bsolute difference of ascii value is considered ; when s . charAt ( i ) is equal to either ' v ' , ' w ' , ' x ' , ' y ' , ' z ' ; Driver code","```java
public static String replaceConsonantsWithNearestVowels(String s) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        char ch = s.charAt(i);
        if (isVowel(ch)) {
            sb.append(ch);
        } else {
            if (i > 0 && i < s.length() - 1) {
                char prev = s.charAt(i - 1);
                char next = s.charAt(i + 1);
                if (isVowel(prev) && isVowel(next)) {
                    if (Math.abs(ch - prev) < Math.abs(ch - next)) {
                        sb.append(prev);
                    } else {
                        sb.append(next);
                    }
                } else {
                    sb.append(ch);
                }
            } else {
                sb.append(ch);
            }
        }
    }
    return sb.toString();
}

private static boolean isVowel(char ch) {
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||
           ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
}
```","```python
def replaceConsonantsWithNearestVowels(s):
  vowels = 'aeiouAEIOU'
  result = ''
  for i in range(len(s)):
    if s[i] in vowels:
      result += s[i]
    else:
      nearestVowel = ''
      minDiff = float('inf')
      for vowel in vowels:
        diff = abs(ord(s[i]) - ord(vowel))
        if diff < minDiff:
          minDiff = diff
          nearestVowel = vowel
      result += nearestVowel
  return result
```"
495,"Find time taken for signal to reach all positions in a string | Java program to Find time taken for signal to reach all positions in a string ; Returns time needed for signal to traverse through complete string . ; for the calculation of last index ; for strings like oxoooo , xoxxoooo . . ; if coun is greater than max_length ; if ' x ' is present at the right side of max_length ; if ' x ' is present at left side of max_length ; We use ceiling function to handle odd number ' o ' s ; Driver code","```java
public static int findTime(String s) {
    int n = s.length();
    int max_length = 0;
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (s.charAt(i) == 'o') {
            count++;
        } else {
            max_length = Math.max(max_length, count);
            count = 0;
        }
    }
    max_length = Math.max(max_length, count);
    if (count > max_length) {
        if (s.charAt(n - 1) == 'x') {
            return (int) Math.ceil((double) (max_length + count) / 2);
        } else {
            return (int) Math.ceil((double) (max_length + count - 1) / 2);
        }
    } else {
        if (s.charAt(n - 1) == 'x') {
            return (int) Math.ceil((double) max_length / 2);
        } else {
            return (int) Math.ceil((double) (max_length - 1) / 2);
        }
    }
}
```","```python
def signal_time(s):
  max_length = len(s)
  coun = 0
  for i in range(max_length):
    if s[i] == 'x':
      coun += 1
  if coun > max_length:
    return max_length
  if s[max_length - 1] == 'x':
    return max_length
  if s[0] == 'x':
    return max_length
  return -(-max_length // 2)
```"
496,Lexicographically largest string formed from the characters in range L and R | Java program to print the lexicographically largest String that can be formed from the characters in range L and R ; Function to return the lexicographically largest String ; hash array ; make 0 - based indexing ; iterate and count frequencies of character ; ans String ; iterate in frequency array ; add til all characters are added ; Driver Code,"```java
public static String largestString(char L, char R) {
    int[] freq = new int[26];
    for (char ch = L; ch <= R; ch++) {
      freq[ch - 'a']++;
    }
    StringBuilder ans = new StringBuilder();
    for (int i = 25; i >= 0; i--) {
      while (freq[i]-- > 0) {
        ans.append((char) (i + 'a'));
      }
    }
    return ans.toString();
  }
```","```python
def largest_string(L, R):
  freq = [0] * (R - L + 2)
  for i in range(L, R + 1):
    freq[i - L + 1] += 1
  ans = ''
  for i in range(len(freq) - 1, -1, -1):
    while freq[i] > 0:
      ans += chr(i + L - 1)
      freq[i] -= 1
  return ans
```"
497,Arrange a binary string to get maximum value within a range of indices | Java implementation of the approach ; Storing the count of 1 's in the String ; Query of l and r ; Applying range update technique . ; Taking prefix sum to get the range update values ; Final array which will store the arranged String ; if after maximizing the ranges any 1 is left then we maximize the String lexicographically . ; Driver Code,"```java
public static String arrange(String s, int[][] queries) {
    int n = s.length();
    int[] count = new int[n + 1];
    for (int i = 0; i < n; i++) {
      count[i + 1] = count[i] + (s.charAt(i) == '1' ? 1 : 0);
    }
    int[] rangeUpdate = new int[n + 1];
    for (int[] query : queries) {
      int l = query[0];
      int r = query[1];
      rangeUpdate[l] += 1;
      rangeUpdate[r + 1] -= 1;
    }
    for (int i = 1; i <= n; i++) {
      rangeUpdate[i] += rangeUpdate[i - 1];
    }
    char[] result = new char[n];
    int j = 0;
    for (int i = 0; i < n; i++) {
      if (rangeUpdate[i] > 0) {
        result[j++] = '1';
      }
    }
    for (int i = 0; i < n; i++) {
      if (rangeUpdate[i] == 0 && s.charAt(i) == '1') {
        result[j++] = '1';
      } else if (rangeUpdate[i] == 0 && s.charAt(i) == '0') {
        result[j++] = '0';
      }
    }
    return new String(result);
  }
```","```python
def arrange_binary_string(s, queries):
  n = len(s)
  ones_count = [0] * (n + 1)
  for i in range(n):
    ones_count[i + 1] = ones_count[i] + (1 if s[i] == '1' else 0)
  range_update = [0] * (n + 1)
  for l, r in queries:
    range_update[l] += 1
    range_update[r + 1] -= 1
  for i in range(1, n + 1):
    range_update[i] += range_update[i - 1]
  arranged_string = [''] * n
  j = 0
  for i in range(n):
    if range_update[i + 1] > 0:
      arranged_string[j] = '1'
      j += 1
  for i in range(n):
    if arranged_string[i] == '':
      arranged_string[i] = s[i]
  return ''.join(arranged_string)
```"
498,Check whether the vowels in a string are in alphabetical order or not | Java implementation of above approach ; Function that checks whether the vowel characters in a string are in alphabetical order or not ; ASCII Value 64 is less than all the alphabets so using it as a default value ; check if the vowels in the string are sorted or not ; if the vowel is smaller than the previous vowel ; store the vowel ; Driver code ; check whether the vowel characters in a string are in alphabetical order or not,"```java
public static boolean areVowelsSorted(String str) {
    char prevVowel = (char) 64;
    for (int i = 0; i < str.length(); i++) {
      char ch = str.charAt(i);
      if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {
        if (ch < prevVowel) {
          return false;
        }
        prevVowel = ch;
      }
    }
    return true;
  }
```","```python
def check_vowel_order(string):
  prev_vowel = 64
  for char in string:
    if char in 'aeiouAEIOU':
      if ord(char.lower()) < ord(prev_vowel.lower()):
        return False
      prev_vowel = char
  return True
```"
499,Program to replace every space in a string with hyphen | Java implementation of the above approach ; Split by space and converting String to list and ; returning the string ; Driver code,"```java
public static String replaceSpaceWithHyphen(String str) {
    String[] words = str.split("" "");
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < words.length; i++) {
      sb.append(words[i]);
      if (i < words.length - 1) {
        sb.append(""-"");
      }
    }
    return sb.toString();
  }
```","```python
def replace_space_with_hyphen(text):
  return ""-"".join(text.split())
```"
500,Rearrange the string to maximize the number of palindromic substrings | Java program to rearrange the string such to maximize the number of palindromic substrings ; Function to return the newString ; length of string ; hashing array ; iterate and count ; resulting string ; form the resulting string ; number of times character appears ; append to resulting string ; Driver code,"```java
public static String rearrangeString(String str) {
    int n = str.length();
    int[] hash = new int[26];
    for (int i = 0; i < n; i++) {
        hash[str.charAt(i) - 'a']++;
    }
    StringBuilder newString = new StringBuilder();
    for (int i = 0; i < 26; i++) {
        if (hash[i] > 0) {
            for (int j = 0; j < hash[i] / 2; j++) {
                newString.append((char) (i + 'a'));
            }
        }
    }
    for (int i = 0; i < 26; i++) {
        if (hash[i] % 2 != 0) {
            newString.append((char) (i + 'a'));
        }
    }
    for (int i = 25; i >= 0; i--) {
        if (hash[i] > 0) {
            for (int j = 0; j < hash[i] / 2; j++) {
                newString.insert(0, (char) (i + 'a'));
            }
        }
    }
    return newString.toString();
}
```","```python
def rearrangeString(s):
  n = len(s)
  hashing_array = [0] * 26
  for i in range(n):
    hashing_array[ord(s[i]) - ord('a')] += 1
  newString = """"
  for i in range(26):
    if hashing_array[i] > 0:
      for j in range(hashing_array[i]):
        newString += chr(i + ord('a'))
  return newString
```"
501,Program to find remainder when large number is divided by r | Java implementation to find Remainder when a large Number is divided by R ; Function to Return Remainder ; len is variable to store the length of Number string . ; loop that find Remainder ; Return the remainder ; Driver code ; Get the large number as string ; Get the divisor R ; Find and print the remainder,"```java
public static int findRemainder(String number, int r) {
    int len = number.length();
    int remainder = 0;
    for (int i = 0; i < len; i++) {
        remainder = ((remainder * 10) + (number.charAt(i) - '0')) % r;
    }
    return remainder;
}
```","```python
def find_remainder(number, r):
  len = len(number)
  remainder = 0
  for i in range(len):
    remainder = (remainder * 10 + int(number[i])) % r
  return remainder
```"
502,Number of balanced bracket subsequence of length 2 and 4 | Java implementation of above approach ; Taking the frequency suffix sum of the number of 2 's present after every index ; Storing the count of subsequence ; Subsequence of length 2 ; Subsequence of length 4 of type 1 1 2 2 ; Subsequence of length 4 of type 1 2 1 2 ; Driver Code,"```java
public static int countBalancedSubsequences(String s) {
    int n = s.length();
    int[] twoCountSuffix = new int[n + 1];
    int count = 0;
    for (int i = n - 1; i >= 0; i--) {
        twoCountSuffix[i] = twoCountSuffix[i + 1];
        if (s.charAt(i) == '2') {
            twoCountSuffix[i]++;
        }
    }
    for (int i = 0; i < n - 1; i++) {
        if (s.charAt(i) == '1') {
            count += twoCountSuffix[i + 1];
        }
    }
    for (int i = 0; i < n - 3; i++) {
        if (s.charAt(i) == '1') {
            for (int j = i + 1; j < n - 2; j++) {
                if (s.charAt(j) == '1') {
                    count += twoCountSuffix[j + 2];
                }
            }
        }
    }
    return count;
}
```","```python
def count_balanced_subsequences(s):
  n = len(s)
  freq = [0] * (n + 1)
  for i in range(n - 1, -1, -1):
    freq[i] = freq[i + 1]
    if s[i] == '2':
      freq[i] += 1
  count = 0
  for i in range(n):
    if s[i] == '1':
      count += freq[i + 1]
  count2 = 0
  for i in range(n - 3):
    if s[i] == '1' and s[i + 1] == '1' and s[i + 2] == '2' and s[i + 3] == '2':
      count2 += 1
  count3 = 0
  for i in range(n - 3):
    if s[i] == '1' and s[i + 1] == '2' and s[i + 2] == '1' and s[i + 3] == '2':
      count3 += 1
  return count + count2 + count3
```"
503,"Count the number of carry operations required to add two numbers | Java implementation of above approach ; Function to count the number of carry operations ; Initialize the value of carry to 0 ; Counts the number of carry operations ; Initialize len_a and len_b with the sizes of strings ; Assigning the ascii value of the character ; Add both numbers \/ digits ; If sum > 0 , increment count and set carry to 1 ; Else , set carry to 0 ; Driver code","```java
public static int countCarryOperations(String a, String b) {
    int carry = 0;
    int count = 0;
    int len_a = a.length();
    int len_b = b.length();
    for (int i = 0; i < Math.max(len_a, len_b); i++) {
      int digit_a = i < len_a ? a.charAt(len_a - 1 - i) - '0' : 0;
      int digit_b = i < len_b ? b.charAt(len_b - 1 - i) - '0' : 0;
      int sum = digit_a + digit_b + carry;
      if (sum > 9) {
        count++;
        carry = 1;
      } else {
        carry = 0;
      }
    }
    return count;
  }
```","```python
def countCarryOperations(a, b):
  carry = 0
  count = 0
  len_a = len(a)
  len_b = len(b)
  i = len_a - 1
  j = len_b - 1
  while i >= 0 or j >= 0 or carry:
    sum = carry
    if i >= 0:
      sum += ord(a[i]) - ord('0')
      i -= 1
    if j >= 0:
      sum += ord(b[j]) - ord('0')
      j -= 1
    if sum > 9:
      count += 1
      carry = 1
    else:
      carry = 0
  return count
```"
504,"Check if a number is in given base or not | Java program to check if given number is in given base or not . ; Allowed bases are till 16 ( Hexadecimal ) ; If base is below or equal to 10 , then all digits should be from 0 to 9. ; If base is below or equal to 16 , then all digits should be from 0 to 9 or from ' A ' ; Driver Class","```java
public static boolean isValidNumber(String number, int base) {
    if (base < 2 || base > 16) {
        return false;
    }
    for (int i = 0; i < number.length(); i++) {
        char digit = number.charAt(i);
        if (Character.isDigit(digit)) {
            if (digit - '0' >= base) {
                return false;
            }
        } else if (Character.isLetter(digit)) {
            if (base <= 10 || digit < 'A' || digit > 'A' + base - 11) {
                return false;
            }
        } else {
            return false;
        }
    }
    return true;
}
```","```python
def is_valid_number(number, base):
  if base <= 10:
    for digit in str(number):
      if not ('0' <= digit <= '9'):
        return False
  elif base <= 16:
    for digit in str(number):
      if not ('0' <= digit <= '9' or 'A' <= digit <= 'F'):
        return False
  else:
    return False
  return True
```"
505,Find indices of all occurrence of one string in other | Java program to find indices of all occurrences of one String in other . ; Driver code,"```java
public static List<Integer> findIndices(String text, String pattern) {
    List<Integer> indices = new ArrayList<>();
    int index = 0;
    while (index < text.length()) {
      index = text.indexOf(pattern, index);
      if (index == -1) {
        break;
      }
      indices.add(index);
      index += pattern.length();
    }
    return indices;
  }
```","```python
def find_all_indices(text, pattern):
  indices = []
  i = 0
  while i < len(text):
    if text[i:i+len(pattern)] == pattern:
      indices.append(i)
      i += len(pattern)
    else:
      i += 1
  return indices
```"
506,Alternatively Merge two Strings in Java | Java code to alternatively merge two strings ; Function for alternatively merging two strings ; To store the final string ; For every index in the strings ; First choose the ith character of the first string if it exists ; Then choose the ith character of the second string if it exists ; Driver code,"```java
public static String mergeStrings(String str1, String str2) {
    StringBuilder mergedString = new StringBuilder();
    for (int i = 0; i < str1.length() || i < str2.length(); i++) {
      if (i < str1.length()) {
        mergedString.append(str1.charAt(i));
      }
      if (i < str2.length()) {
        mergedString.append(str2.charAt(i));
      }
    }
    return mergedString.toString();
  }
```","```python
def merge_strings(str1, str2):
  result = """"
  for i in range(max(len(str1), len(str2))):
    if i < len(str1):
      result += str1[i]
    if i < len(str2):
      result += str2[i]
  return result
```"
507,"Maximum occurring character in an input string | Set | Java implementation to find the maximum occurring character in an input string which is lexicographically first ; function to find the maximum occurring character in an input string which is lexicographically first ; freq [ ] used as hash table ; to store maximum frequency ; to store the maximum occurring character ; length of ' str ' ; get frequency of each character of ' str ' ; for each character , where character is obtained by ( i + ' a ' ) check whether it is the maximum character so far and accodingly update ' result ' ; maximum occurring character ; Driver Code","```java
public static char maxOccurringCharacter(String str) {
    int[] freq = new int[26];
    int maxFreq = 0;
    char result = 'a';
    int len = str.length();
    for (int i = 0; i < len; i++) {
      freq[str.charAt(i) - 'a']++;
    }
    for (int i = 0; i < 26; i++) {
      if (freq[i] > maxFreq) {
        maxFreq = freq[i];
        result = (char) (i + 'a');
      }
    }
    return result;
  }
```","```python
def max_occurring_char(str):
  freq = [0] * 26
  max_freq = 0
  result = 'a'
  n = len(str)
  for i in range(n):
    freq[ord(str[i]) - ord('a')] += 1
  for i in range(26):
    if freq[i] > max_freq:
      max_freq = freq[i]
      result = chr(i + ord('a'))
  return result
```"
508,"Given two numbers as strings , find if one is a power of other | Java program to check if one number is power of other ; Multiply the numbers . It multiplies each digit of second string to each digit of first and stores the result . ; If the digit exceeds 9 , add the cumulative carry to previous digit . ; if all zeroes , return ""0"" . ; Remove starting zeroes . ; Removes Extra zeroes from front of a string . ; Make sure there are no leading zeroes in the string . ; Making sure that s1 is smaller . If it is greater , we recur we reversed parameters . ; Driver Code","```java
public static String multiply(String s1, String s2) {
    if (s1.length() == 0 || s2.length() == 0) {
      return ""0"";
    }
    if (s1.equals(""0"") || s2.equals(""0"")) {
      return ""0"";
    }
    if (s1.length() > s2.length()) {
      return multiply(s2, s1);
    }
    StringBuilder sb = new StringBuilder();
    int carry = 0;
    for (int i = s1.length() - 1; i >= 0; i--) {
      for (int j = s2.length() - 1; j >= 0; j--) {
        int product = (s1.charAt(i) - '0') * (s2.charAt(j) - '0') + carry;
        carry = product / 10;
        sb.insert(0, product % 10);
      }
      if (carry > 0) {
        sb.insert(0, carry);
        carry = 0;
      }
    }
    while (sb.length() > 1 && sb.charAt(0) == '0') {
      sb.deleteCharAt(0);
    }
    return sb.toString();
  }
```","```python
def is_power(s1, s2):
    if len(s1) > len(s2):
        return is_power(s2, s1)
    if s1 == ""0"":
        return ""0""
    if len(s1) == 1 and s1 == ""1"":
        return ""1""
    result = """"
    carry = 0
    for i in range(len(s1) - 1, -1, -1):
        for j in range(len(s2) - 1, -1, -1):
            product = int(s1[i]) * int(s2[j]) + carry
            carry = product // 10
            product %= 10
            result = str(product) + result
        if carry > 0:
            result = str(carry) + result
            carry = 0
    result = result.lstrip(""0"")
    if result == """":
        return ""0""
    return result
```"
509,"Check for balanced parentheses in an expression | O ( 1 ) space | Java code to check balanced parentheses with O ( 1 ) space . ; Function1 to match closing bracket ; Function1 to match opening bracket ; Function to check balanced parentheses ; helper variables ; Handling case of opening parentheses ; } Handling case of closing parentheses ; If corresponding matching opening parentheses doesn 't  lie in given interval return 0 ; else continue ; If corresponding closing parentheses doesn 't lie in given interval  return 0 ; if found , now check for each opening and closing parentheses in this interval ; Driver Code","```java
public class BalancedParentheses {

    public static boolean isBalanced(String expr) {
        int openCount = 0;
        for (char c : expr.toCharArray()) {
            if (c == '(') {
                openCount++;
            } else if (c == ')') {
                if (openCount == 0) {
                    return false;
                }
                openCount--;
            }
        }
        return openCount == 0;
    }

    public static void main(String[] args) {
        String expr1 = ""((()))"";
        String expr2 = ""(()"";
        String expr3 = ""))"";

        System.out.println(expr1 + "": "" + isBalanced(expr1));
        System.out.println(expr2 + "": "" + isBalanced(expr2));
        System.out.println(expr3 + "": "" + isBalanced(expr3));
    }
}
```","```python
def isBalanced(expression):
  n = len(expression)
  if n == 0:
    return 1
  if n % 2 != 0:
    return 0
  i = 0
  while i < n:
    if expression[i] == '(' or expression[i] == '{' or expression[i] == '[':
      j = i + 1
      while j < n and expression[j] != ')' and expression[j] != '}' and expression[j] != ']':
        j += 1
      if j == n:
        return 0
      if not (matchClosingBracket(expression[i], expression[j])):
        return 0
      i = j + 1
    else:
      j = i - 1
      while j >= 0 and expression[j] != '(' and expression[j] != '{' and expression[j] != '[':
        j -= 1
      if j < 0:
        return 0
      if not (matchOpeningBracket(expression[i], expression[j])):
        return 0
      i = j - 1
  return 1

def matchClosingBracket(opening, closing):
  if opening == '(' and closing == ')':
    return 1
  if opening == '{' and closing == '}':
    return 1
  if opening == '[' and closing == ']':
    return 1
  return 0

def matchOpeningBracket(closing, opening):
  if closing == ')' and opening == '(':
    return 1
  if closing == '}' and opening == '{':
    return 1
  if closing == ']' and opening == '[':
    return 1
  return 0
```"
510,"Sorting array with conditional swapping | Java program to Check if it is possible to sort the array in ascending order . ; Function to check if it is possible to sort the array ; Calculating max_element at each iteration . ; if we can not swap the i - th element . ; if it is impossible to swap the max_element then we can not sort the array . ; Otherwise , we can sort the array . ; Driven Program","```java
public static boolean canSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int max_element = arr[i];
        int max_index = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] > max_element) {
                max_element = arr[j];
                max_index = j;
            }
        }
        if (max_index != i) {
            if (arr[i] > max_element) {
                return false;
            }
        } else {
            return false;
        }
    }
    return true;
}
```","```python
def can_sort_array(arr):
  n = len(arr)
  for i in range(n):
    max_element = arr[i]
    max_index = i
    for j in range(i + 1, n):
      if arr[j] > max_element:
        max_element = arr[j]
        max_index = j
    if max_index != i:
      arr[i], arr[max_index] = arr[max_index], arr[i]
    else:
      return False
  return True
```"
511,"Find sub | Java program to find substring with given power ; Function to print indexes of substring with power as given power . ; Create an empty map ; Maintains sum of powers of characters so far . ; Add current character power to curr_power . ; If curr_power is equal to target power we found a substring starting from index 0 and ending at index i . ; If curr_power - power already exists in map then we have found a subarray with target power . ; If we reach here , then no substring exists . ; Driver Code","```java
public static void findSub(String s, int power) {
    Map<Integer, Integer> map = new HashMap<>();
    int curr_power = 0;
    for (int i = 0; i < s.length(); i++) {
      curr_power += Math.pow(s.charAt(i), power);
      if (curr_power == power) {
        System.out.println(""Substring found from index 0 to "" + i);
        return;
      }
      if (map.containsKey(curr_power - power)) {
        System.out.println(""Substring found from index "" + (map.get(curr_power - power) + 1) + "" to "" + i);
        return;
      }
      map.put(curr_power, i);
    }
    System.out.println(""No substring exists with given power"");
  }
```","```python
def find_sub(s, power):
  mp = {}
  curr_power = 0
  for i in range(len(s)):
    curr_power += ord(s[i]) ** power
    if curr_power == power:
      print(f""Substring found from index 0 to {i}"")
      return
    if curr_power - power in mp:
      print(f""Substring found from index {mp[curr_power - power] + 1} to {i}"")
      return
    mp[curr_power] = i
  print(""No substring found"")
```"
512,Prime String | Java program to find if string is a Prime or not . ; Function that checks if sum is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Driver code,"```java
public static boolean isPrimeString(String str) {
    int sum = 0;
    for (int i = 0; i < str.length(); i++) {
        sum += str.charAt(i) - 'a' + 1;
    }
    if (sum <= 1) {
        return false;
    }
    if (sum <= 3) {
        return true;
    }
    if (sum % 2 == 0 || sum % 3 == 0) {
        return false;
    }
    for (int i = 5; i * i <= sum; i += 6) {
        if (sum % i == 0 || sum % (i + 2) == 0) {
            return false;
        }
    }
    return true;
}
```","```python
def is_prime_string(s):
  n = 0
  for i in s:
    n += ord(i)
  if n <= 1:
    return False
  if n <= 3:
    return True
  if n % 2 == 0 or n % 3 == 0:
    return False
  i = 5
  while i * i <= n:
    if n % i == 0 or n % (i + 2) == 0:
      return False
    i += 6
  return True
```"
513,Ways to split string such that each partition starts with distinct character | Java Program to find number of way to split string such that each partition starts with distinct character with maximum number of partitions . ; Returns the number of we can split the string ; Finding the frequency of each character . ; making frequency of first character of string equal to 1. ; Finding the product of frequency of occurrence of each character . ; Driver Code,"```java
public static int countSplits(String s) {
    if (s.isEmpty()) {
        return 0;
    }
    int[] freq = new int[26];
    for (char c : s.toCharArray()) {
      freq[c - 'a']++;
    }
    freq[s.charAt(0) - 'a'] = 1;
    int product = 1;
    for (int i = 0; i < 26; i++) {
      if (freq[i] > 0) {
        product *= freq[i];
      }
    }
    return product;
  }
```","```python
def count_splits(s):
  freq = {}
  for char in s:
    if char in freq:
      freq[char] += 1
    else:
      freq[char] = 1
  freq[s[0]] = 1
  product = 1
  for count in freq.values():
    product *= count
  return product
```"
514,Lexicographically next greater string using same character set | Java implementation of above algorithm . ; function to print output ; to store unique characters of the string ; to check uniqueness ; if mp [ s [ i ] ] = 0 then it is first time ; sort the unique characters ; simply add n - k smallest characters ; return ; end the program ; searching the first character left of index k and not equal to greatest character of the string ; finding the just next greater character than s [ i ] ; suffix with smallest character ; if we reach here then all indices to the left of k had the greatest character ; Driver code ; Function call,"```java
public static void nextGreaterPermutation(String s) {
    int n = s.length();
    Map<Character, Integer> mp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        if (mp.get(s.charAt(i)) == null) {
            mp.put(s.charAt(i), 0);
        }
    }
    List<Character> uniqueChars = new ArrayList<>(mp.keySet());
    Collections.sort(uniqueChars);
    if (mp.size() == 1) {
        System.out.println(s);
        return;
    }
    int k = n - 1;
    while (k > 0 && s.charAt(k - 1) >= s.charAt(k)) {
        k--;
    }
    if (k == 0) {
        System.out.println(""Not possible"");
        return;
    }
    int i = k - 1;
    int j = n - 1;
    while (s.charAt(j) <= s.charAt(i)) {
        j--;
    }
    char[] arr = s.toCharArray();
    char temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
    Arrays.sort(arr, k, n);
    System.out.println(String.valueOf(arr));
}
```","```python
def next_greater_string(s):
  n = len(s)
  mp = {}
  for i in range(n):
    if s[i] not in mp:
      mp[s[i]] = 0
    mp[s[i]] += 1
  unique_chars = sorted(mp.keys())
  k = n - 1
  while k > 0 and s[k - 1] >= s[k]:
    k -= 1
  if k == 0:
    return ''.join(unique_chars)
  i = k - 1
  j = n - 1
  while s[j] <= s[i]:
    j -= 1
  s = list(s)
  s[i], s[j] = s[j], s[i]
  s[k:] = sorted(s[k:])
  return ''.join(s)
```"
515,"Number of palindromic permutations | Set 1 | Java program to find number of palindromic permutations of a given string ; Returns factorial of n ; Returns count of palindromic permutations of str . ; Count frequencies of all characters ; Since half of the characters decide count of palindromic permutations , we take ( n \/ 2 ) ! ; To make sure that there is at most one odd occurring char ; Traverse through all counts ; To make sure that the string can permute to form a palindrome ; If there are more than one odd occurring chars ; Divide all permutations with repeated characters ; Driver code","```java
public static int fact(int n) {
    if (n == 0) {
      return 1;
    }
    return n * fact(n - 1);
  }
  public static int countPalindromicPermutations(String str) {
    int[] charCount = new int[26];
    for (int i = 0; i < str.length(); i++) {
      charCount[str.charAt(i) - 'a']++;
    }
    int oddCount = 0;
    for (int i = 0; i < 26; i++) {
      if (charCount[i] % 2 != 0) {
        oddCount++;
      }
    }
    if (oddCount > 1) {
      return 0;
    }
    int halfLen = str.length() / 2;
    int res = fact(halfLen);
    for (int i = 0; i < 26; i++) {
      res /= fact(charCount[i] / 2);
    }
    return res;
  }
  public static void main(String[] args) {
    String str = ""aabbccddeeff"";
    System.out.println(countPalindromicPermutations(str));
  }
```","```python
def factorial(n):
  if n == 0:
    return 1
  else:
    return n * factorial(n-1)

def count_palindromic_permutations(str):
  char_counts = {}
  for char in str:
    if char in char_counts:
      char_counts[char] += 1
    else:
      char_counts[char] = 1

  odd_count = 0
  for count in char_counts.values():
    if count % 2 != 0:
      odd_count += 1

  if odd_count > 1:
    return 0

  half_len = len(str) // 2
  result = factorial(half_len)

  for count in char_counts.values():
    result //= factorial(count // 2)

  return result
```"
516,Rearrange characters to form palindrome if possible | Java program to rearrange a string to make palindrome ; Store counts of characters ; Find the number of odd elements . Takes O ( n ) ; odd_cnt = 1 only if the length of str is odd ; Generate first halh of palindrome ; Build a string of floor ( count \/ 2 ) occurrences of current character ; Attach the built string to end of and begin of second half ; Insert odd character if there is any ; Driver code,"```java
public static String rearrangeString(String str) {
    if (str.length() == 0) {
      return """";
    }
    Map<Character, Integer> charCount = new HashMap<>();
    for (char c : str.toCharArray()) {
      charCount.put(c, charCount.getOrDefault(c, 0) + 1);
    }
    int oddCnt = 0;
    for (int count : charCount.values()) {
      if (count % 2 != 0) {
        oddCnt++;
      }
    }
    if (oddCnt > 1 || (oddCnt == 1 && str.length() % 2 == 0)) {
      return """";
    }
    StringBuilder firstHalf = new StringBuilder();
    StringBuilder secondHalf = new StringBuilder();
    char oddChar = ' ';
    for (Map.Entry<Character, Integer> entry : charCount.entrySet()) {
      char c = entry.getKey();
      int count = entry.getValue();
      if (count % 2 != 0) {
        oddChar = c;
      } else {
        for (int i = 0; i < count / 2; i++) {
          firstHalf.append(c);
          secondHalf.insert(0, c);
        }
      }
    }
    return firstHalf.toString() + (oddChar != ' ' ? oddChar : """") + secondHalf.toString();
  }
```","```python
def can_form_palindrome(str):
  char_counts = {}
  for char in str:
    if char in char_counts:
      char_counts[char] += 1
    else:
      char_counts[char] = 1
  odd_cnt = 0
  for count in char_counts.values():
    if count % 2 != 0:
      odd_cnt += 1
  if len(str) % 2 == 0 and odd_cnt > 0:
    return False
  elif len(str) % 2 != 0 and odd_cnt != 1:
    return False
  first_half = ''
  for char, count in char_counts.items():
    first_half += char * (count // 2)
  second_half = first_half[::-1]
  palindrome = first_half
  odd_char = None
  for char, count in char_counts.items():
    if count % 2 != 0:
      odd_char = char
      break
  if odd_char:
    palindrome += odd_char
  palindrome += second_half
  return palindrome
```"
517,"Substrings starting with vowel and ending with consonants and vice versa | Java program to count special strings ; Returns true if ch is vowel ; function to check consonant ; in case of empty string , we can 't fullfill the  required condition, hence we return ans as 0. ; co [ i ] is going to store counts of consonants from str [ len - 1 ] to str [ i ] . vo [ i ] is going to store counts of vowels from str [ len - 1 ] to str [ i ] . ; Counting consonants and vowels from end of string . ; Now we traverse string from beginning ; If vowel , then count of substrings starting with str [ i ] is equal to count of consonants after it . ; If consonant , then count of substrings starting with str [ i ] is equal to count of vowels after it . ; Driver program","```java
public static int countSpecialStrings(String str) {
    if (str.isEmpty()) {
      return 0;
    }
    int len = str.length();
    int[] co = new int[len];
    int[] vo = new int[len];
    for (int i = len - 1; i >= 0; i--) {
      if (isConsonant(str.charAt(i))) {
        co[i]++;
      }
      if (i != len - 1) {
        co[i] += co[i + 1];
      }
      if (isVowel(str.charAt(i))) {
        vo[i]++;
      }
      if (i != len - 1) {
        vo[i] += vo[i + 1];
      }
    }
    int ans = 0;
    for (int i = 0; i < len; i++) {
      if (isVowel(str.charAt(i))) {
        ans += co[i];
      }
      if (isConsonant(str.charAt(i))) {
        ans += vo[i];
      }
    }
    return ans;
  }
  public static boolean isVowel(char ch) {
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
  }
  public static boolean isConsonant(char ch) {
    return !isVowel(ch) && Character.isLetter(ch);
  }
```","```python
def countSpecialStrings(str):
  n = len(str)
  if n == 0:
    return 0
  vo = [0] * (n + 1)
  co = [0] * (n + 1)
  for i in range(n - 1, -1, -1):
    if isVowel(str[i]):
      vo[i] = vo[i + 1] + 1
    else:
      vo[i] = vo[i + 1]
    if isConsonant(str[i]):
      co[i] = co[i + 1] + 1
    else:
      co[i] = co[i + 1]
  ans = 0
  for i in range(n):
    if isVowel(str[i]):
      ans += co[i + 1]
    else:
      ans += vo[i + 1]
  return ans
def isVowel(ch):
  return ch in 'aeiouAEIOU'
def isConsonant(ch):
  return not isVowel(ch)
```"
518,Convert the string into palindrome string by changing only one character | Java program to Check if it is possible to convert the string into palindrome string by changing only one character . ; Function to check if it is possible to convert the string into palindrome ; Counting number of characters that should be changed . ; If count of changes is less than or equal to 1 ; Driver Function,"```java
public static boolean isOneChangePalindrome(String str) {
    int n = str.length();
    int changes = 0;
    for (int i = 0, j = n - 1; i < j; i++, j--) {
        if (str.charAt(i) != str.charAt(j)) {
            changes++;
        }
        if (changes > 1) {
            return false;
        }
    }
    return changes <= 1;
}
```","```python
def is_almost_palindrome(s):
  n = len(s)
  count = 0
  for i in range(n // 2):
    if s[i] != s[n - i - 1]:
      count += 1
  return count <= 1
```"
519,Counting even decimal value substrings in a binary string | Java Program to count all even decimal value substring . ; function return count of even decimal value substring ; store the count of even decimal value substring ; substring started with '0' ; increment result by ( n - i ) because all substring which are generate by this character produce even decimal value . ; Driver code,"```java
public static int countEvenDecimalSubstrings(String str) {
    int result = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) == '0') {
            result += str.length() - i;
        }
    }
    return result;
}
```","```python
def count_even_decimal_substrings(s):
  n = len(s)
  result = 0
  for i in range(n):
    if s[i] == '0':
      result += (n - i)
  return result
```"
520,Number of substrings with odd decimal value in a binary string | Java program to count substrings with odd decimal value ; function to count number of substrings with odd decimal representation ; auxiliary array to store count of 1 's before ith index ; store count of 1 's before  i-th index ; variable to store answer ; traverse the string reversely to calculate number of odd substrings before i - th index ; Driver code,"```java
public static int countOddSubstrings(String s) {
    int[] countOnes = new int[s.length() + 1];
    for (int i = 1; i <= s.length(); i++) {
      countOnes[i] = countOnes[i - 1] + (s.charAt(i - 1) == '1' ? 1 : 0);
    }
    int answer = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
      answer += countOnes[i + 1] - countOnes[i];
    }
    return answer;
  }
```","```python
def count_odd_substrings(s):
  n = len(s)
  ones = [0] * (n + 1)
  for i in range(n):
    ones[i + 1] = ones[i] + int(s[i])
  ans = 0
  for i in range(n - 1, -1, -1):
    for j in range(i + 1):
      if (ones[i + 1] - ones[j]) % 2:
        ans += 1
  return ans
```"
521,Find the starting indices of the substrings in string ( S ) which is made by concatenating all words from a list ( L ) | Java program to calculate the starting indices of substrings inside S which contains all the words present in List L . ; Returns an integer vector consisting of starting indices of substrings present inside the string S ; Number of a characters of a word in list L . ; Number of words present inside list L . ; Total characters present in list L . ; Resultant vector which stores indices . ; If the total number of characters in list L is more than length of string S itself . ; Map stores the words present in list L against it 's occurrences inside list L  ; Traverse the substring ; Extract the word ; If word not found or if frequency of current word is more than required simply break . ; Else decrement the count of word from hash_map ; Store the starting index of that substring when all the words in the list are in substring ; Driver code,"```java
import java.util.*;
import java.lang.*;

class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> result = new ArrayList<>();
        if (s.length() < words.length * words[0].length()) {
            return result;
        }
        Map<String, Integer> wordCount = new HashMap<>();
        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }
        int wordLen = words[0].length();
        for (int i = 0; i <= s.length() - words.length * wordLen; i++) {
            Map<String, Integer> seenWords = new HashMap<>();
            int j;
            for (j = 0; j < words.length; j++) {
                String currentWord = s.substring(i + j * wordLen, i + (j + 1) * wordLen);
                if (!wordCount.containsKey(currentWord)) {
                    break;
                }
                seenWords.put(currentWord, seenWords.getOrDefault(currentWord, 0) + 1);
                if (seenWords.get(currentWord) > wordCount.get(currentWord)) {
                    break;
                }
            }
            if (j == words.length) {
                result.add(i);
            }
        }
        return result;
    }
}
```","```python
def findSubstring(S, L):
  n = len(S)
  m = len(L)
  word_length = len(L[0])
  total_chars = word_length * m
  result = []
  if total_chars > n:
    return result
  hash_map = {}
  for word in L:
    if word in hash_map:
      hash_map[word] += 1
    else:
      hash_map[word] = 1
  for i in range(n - total_chars + 1):
    temp_map = hash_map.copy()
    for j in range(i, i + total_chars, word_length):
      word = S[j:j + word_length]
      if word not in temp_map or temp_map[word] == 0:
        break
      else:
        temp_map[word] -= 1
    if all(value == 0 for value in temp_map.values()):
      result.append(i)
  return result
```"
522,Check whether second string can be formed from characters of first string | Java program to check whether second string can be formed from first string ; Create a count array and count frequencies characters in str1 . ; Now traverse through str2 to check if every character has enough counts ; Driver Code,"```java
public static boolean canFormString(String str1, String str2) {
    int[] count = new int[256];
    for (char ch : str1.toCharArray()) {
      count[ch]++;
    }
    for (char ch : str2.toCharArray()) {
      if (--count[ch] < 0) {
        return false;
      }
    }
    return true;
  }
```","```python
def can_form_string(str1, str2):
  count = [0] * 256
  for char in str1:
    count[ord(char)] += 1
  for char in str2:
    if count[ord(char)] == 0:
      return False
    count[ord(char)] -= 1
  return True
```"
523,Position of robot after given movements | Java implementation to find final position of robot after the complete movement ; function to find final position of robot after the complete movement ; traverse the instruction string ' move ' ; for each movement increment its respective counter ; required final position of robot ; Driver code,"```java
public static int[] finalPosition(String moves) {
    int x = 0;
    int y = 0;
    for (char move : moves.toCharArray()) {
        if (move == 'U') {
            y++;
        } else if (move == 'D') {
            y--;
        } else if (move == 'R') {
            x++;
        } else if (move == 'L') {
            x--;
        }
    }
    return new int[]{x, y};
}
```","```python
def final_position(movements):
  x = 0
  y = 0
  for move in movements:
    if move == 'U':
      y += 1
    elif move == 'D':
      y -= 1
    elif move == 'R':
      x += 1
    elif move == 'L':
      x -= 1
  return (x, y)
```"
524,"Length of longest balanced parentheses prefix | Java Program to find length of longest balanced parentheses prefix . ; Return the length of longest balanced parentheses prefix . ; Traversing the string . ; If open bracket add 1 to sum . ; If closed bracket subtract 1 from sum ; if first bracket is closing bracket then this condition would help ; If sum is 0 , store the index value . ; Driven Program","```java
public static int longestBalancedParenthesesPrefix(String s) {
    int sum = 0;
    int maxLen = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            sum++;
        } else {
            sum--;
        }
        if (sum == 0 && i > 0) {
            maxLen = i + 1;
        }
    }
    return maxLen;
}
```","```python
def longest_balanced_prefix(s):
  sum = 0
  max_len = 0
  for i in range(len(s)):
    if s[i] == '(':
      sum += 1
    elif s[i] == ')':
      sum -= 1
    if sum == 0:
      max_len = i + 1
  return max_len
```"
525,"Minimum cost to convert string into palindrome | Java program to find minimum cost to make a palindrome . ; Function to return cost ; length of string ; Iterate from both sides of string . If not equal , a cost will be there ; Driver code","```java
public static int minCostPalindrome(String str) {
    int n = str.length();
    int[][] dp = new int[n][n];
    for (int i = 0; i < n; i++) {
      dp[i][i] = 0;
    }
    for (int i = n - 2; i >= 0; i--) {
      for (int j = i + 1; j < n; j++) {
        if (str.charAt(i) == str.charAt(j)) {
          dp[i][j] = dp[i + 1][j - 1];
        } else {
          dp[i][j] = 1 + Math.min(dp[i + 1][j], dp[i][j - 1]);
        }
      }
    }
    return dp[0][n - 1];
  }
```","```python
def minCostPalindrome(s):
  n = len(s)
  cost = 0
  i = 0
  j = n - 1
  while i < j:
    if s[i] != s[j]:
      cost += 1
    i += 1
    j -= 1
  return cost
```"
526,"Encoding a word into Pig Latin | Java program to encode a word to a Pig Latin . ; the index of the first vowel is stored . ; Pig Latin is possible only if vowels is present ; Take all characters after index ( including index ) . Append all characters which are before index . Finally append "" ay "" ; Driver code","```java
public static String pigLatin(String word) {
    if (word == null || word.isEmpty()) {
        return word;
    }
    int index = -1;
    for (int i = 0; i < word.length(); i++) {
        if (""aeiouAEIOU"".indexOf(word.charAt(i)) != -1) {
            index = i;
            break;
        }
    }
    if (index == -1) {
        return word;
    }
    return word.substring(index) + word.substring(0, index) + ""ay"";
}
```","```python
def pig_latin(word):
  vowels = ""aeiouAEIOU""
  for i in range(len(word)):
    if word[i] in vowels:
      return word[i:] + word[:i] + ""ay""
  return word
```"
527,Possibility of a word from a given set of characters | java program to check if a query string is present is given set . ; Count occurrences of all characters in s . ; Check if number of occurrences of every character in q is less than or equal to that in s . ; driver program,"```java
public static boolean isPossible(String s, String q) {
    int[] charCountS = new int[26];
    int[] charCountQ = new int[26];
    for (int i = 0; i < s.length(); i++) {
      charCountS[s.charAt(i) - 'a']++;
    }
    for (int i = 0; i < q.length(); i++) {
      charCountQ[q.charAt(i) - 'a']++;
    }
    for (int i = 0; i < 26; i++) {
      if (charCountQ[i] > charCountS[i]) {
        return false;
      }
    }
    return true;
  }
```","```python
def check_word_possibility(s, q):
  s_counts = {}
  for char in s:
    if char in s_counts:
      s_counts[char] += 1
    else:
      s_counts[char] = 1
  for char in q:
    if char not in s_counts or s_counts[char] == 0:
      return False
    s_counts[char] -= 1
  return True
```"
528,Minimum reduce operations to convert a given string into a palindrome | Java program to count minimum reduce operations to make a palindrome ; Returns count of minimum character reduce operations to make palindrome . ; Compare every character of first half with the corresponding character of second half and add difference to result . ; Driver code,"```java
public static int countMinOperations(String str) {
    int n = str.length();
    int result = 0;
    for (int i = 0; i < n / 2; i++) {
        result += Math.abs(str.charAt(i) - str.charAt(n - i - 1));
    }
    return result;
}
```","```python
def min_reduce_operations(s):
  n = len(s)
  result = 0
  for i in range(n // 2):
    result += abs(ord(s[i]) - ord(s[n - i - 1]))
  return result
```"
529,Minimal operations to make a number magical | java program to make a number magical ; function to calculate the minimal changes ; maximum digits that can be changed ; nested loops to generate all 6 digit numbers ; counter to count the number of change required ; if first digit is equal ; if 2 nd digit is equal ; if 3 rd digit is equal ; if 4 th digit is equal ; if 5 th digit is equal ; if 6 th digit is equal ; checks if less then the previous calculate changes ; returns the answer ; Driver code ; number stored in string ; prints the minimum operations,"```java
public static int minOperations(String number) {
    int minChanges = Integer.MAX_VALUE;
    for (int i = 111111; i <= 999999; i++) {
        int changes = 0;
        String target = String.valueOf(i);
        if (number.charAt(0) != target.charAt(0)) changes++;
        if (number.charAt(1) != target.charAt(1)) changes++;
        if (number.charAt(2) != target.charAt(2)) changes++;
        if (number.charAt(3) != target.charAt(3)) changes++;
        if (number.charAt(4) != target.charAt(4)) changes++;
        if (number.charAt(5) != target.charAt(5)) changes++;
        if (changes < minChanges) minChanges = changes;
    }
    return minChanges;
}
```","```python
def min_operations(number):
  min_changes = 7
  for i in range(100000, 1000000):
    count = 0
    if str(i)[0] != str(number)[0]:
      count += 1
    if str(i)[1] != str(number)[1]:
      count += 1
    if str(i)[2] != str(number)[2]:
      count += 1
    if str(i)[3] != str(number)[3]:
      count += 1
    if str(i)[4] != str(number)[4]:
      count += 1
    if str(i)[5] != str(number)[5]:
      count += 1
    if count < min_changes:
      min_changes = count
  return min_changes

number = input()
print(min_operations(number))
```"
530,Check if a two character string can be made using given words | Java code to check if a two character string can be made using given strings ; Function to check if str can be made using given words ; If str itself is present ; Match first character of str with second of word and vice versa ; If both characters found . ; Driver Code,"```java
public static boolean canBeMade(String str, String[] words) {
    if (str.length() != 2) {
        return false;
    }
    for (String word : words) {
        if (word.equals(str)) {
            return true;
        }
        if (word.length() >= 2 && (word.charAt(0) == str.charAt(1) && word.charAt(1) == str.charAt(0))) {
            return true;
        }
    }
    return false;
}
```","```python
def can_be_made(str, words):
  if str in words:
    return True
  for word in words:
    if len(word) >= 2 and (str[0] == word[1] and str[1] == word[0]):
      return True
  return False
```"
531,Print N | Java program to print all N - bit binary ; Function to get the binary representation of the number N ; loop for each bit ; generate numbers in the range of ( 2 ^ N ) - 1 to 2 ^ ( N - 1 ) inclusive ; longest prefix check ; if counts of 1 is greater than counts of zero ; do sub - prefixes check ; Driver code ; Function call,"```java
public static void printNBitBinary(int N) {
    for (int i = (int) Math.pow(2, N) - 1; i >= Math.pow(2, N - 1); i--) {
        String binary = Integer.toBinaryString(i);
        if (binary.length() < N) {
            binary = String.format(""%"" + N + ""s"", binary).replace(' ', '0');
        }
        int count1 = 0;
        int count0 = 0;
        for (char c : binary.toCharArray()) {
            if (c == '1') {
                count1++;
            } else {
                count0++;
            }
        }
        if (count1 > count0) {
            boolean valid = true;
            for (int j = 1; j <= binary.length() / 2; j++) {
                String prefix1 = binary.substring(0, j);
                String prefix2 = binary.substring(binary.length() - j);
                if (!prefix1.equals(prefix2)) {
                    valid = false;
                    break;
                }
            }
            if (valid) {
                System.out.println(binary);
            }
        }
    }
}
```","```python
def print_n_bit_binary(n):
  for i in range(2**(n-1), 2**n):
    binary = bin(i)[2:].zfill(n)
    ones = binary.count('1')
    zeros = binary.count('0')
    if ones > zeros:
      for j in range(1, n):
        prefix = binary[:j]
        prefix_ones = prefix.count('1')
        prefix_zeros = prefix.count('0')
        if prefix_ones > prefix_zeros:
          print(binary)
          break
```"
532,"Find winner of an election where votes are represented as candidate names | Java program to find winner in an election . ; We have four Candidates with name as ' John ' , ' Johnny ' , ' jamie ' , ' jackie ' . The votes in String array are as per the votes casted . Print the name of candidates received Max vote . ; Insert all votes in a hashmap ; Traverse through map to find the candidate with maximum votes . ; If there is a tie , pick lexicographically smaller . ; Driver code","```java
public static String findWinner(String[] votes) {
    Map<String, Integer> voteCount = new HashMap<>();
    for (String vote : votes) {
        voteCount.put(vote, voteCount.getOrDefault(vote, 0) + 1);
    }
    String winner = """";
    int maxVotes = 0;
    for (Map.Entry<String, Integer> entry : voteCount.entrySet()) {
        if (entry.getValue() > maxVotes) {
            winner = entry.getKey();
            maxVotes = entry.getValue();
        } else if (entry.getValue() == maxVotes && entry.getKey().compareTo(winner) < 0) {
            winner = entry.getKey();
        }
    }
    return winner;
}
```","```python
def find_winner(votes):
  vote_counts = {}
  for vote in votes:
    if vote in vote_counts:
      vote_counts[vote] += 1
    else:
      vote_counts[vote] = 1
  max_votes = 0
  winner = """"
  for candidate, count in vote_counts.items():
    if count > max_votes:
      max_votes = count
      winner = candidate
    elif count == max_votes and candidate < winner:
      winner = candidate
  return winner
```"
533,Luhn algorithm | Java program to implement Luhn algorithm ; Returns true if given card number is valid ; We add two digits to handle cases that make two digits after doubling ; Driver code,"```java
public static boolean checkLuhn(String cardNumber) {
    int sum = 0;
    boolean alternate = false;
    for (int i = cardNumber.length() - 1; i >= 0; i--) {
        int n = Integer.parseInt(cardNumber.substring(i, i + 1));
        if (alternate) {
            n *= 2;
            if (n > 9) {
                n = (n % 10) + 1;
            }
        }
        sum += n;
        alternate = !alternate;
    }
    return (sum % 10 == 0);
}
```","```python
def luhn_check(card_number):
  sum = 0
  nDigits = len(card_number)
  isSecond = False
  for i in range(nDigits - 1, -1, -1):
    d = int(card_number[i])
    if isSecond == True:
      d *= 2
    sum += d // 10
    sum += d % 10
    isSecond = not isSecond
  return sum % 10 == 0
```"
534,Distributing all balls without repetition | Java program to find if its possible to distribute balls without repitiio ; function to find if its possible to distribute balls or not ; count array to count how many times each color has occurred ; increasing count of each color every time it appears ; to check if any color appears more than K times if it does we will print NO ; Driver code,"```java
public static boolean canDistribute(int[] balls, int k) {
    int[] count = new int[100];
    for (int ball : balls) {
      count[ball]++;
      if (count[ball] > k) {
        return false;
      }
    }
    return true;
  }
```","```python
def distribute_balls(balls, k):
  count = [0] * (len(balls) + 1)
  for ball in balls:
    count[ball] += 1
  for i in range(1, len(count)):
    if count[i] > k:
      return ""NO""
  return ""YES""
```"
535,"Find substrings that contain all vowels | Java program to find all substring that contain all vowels ; Returns true if x is vowel . ; Function to check whether a character is vowel or not ; Outer loop picks starting character and inner loop picks ending character . ; If current character is not vowel , then no more result substrings possible starting from str [ i ] . ; If vowel , then we insert it in hash ; If all vowels are present in current substring ; Driver code","```java
public static boolean isVowel(char x) {
    return (x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u');
}

public static void findSubstrings(String str) {
    int n = str.length();
    for (int i = 0; i < n; i++) {
        if (!isVowel(str.charAt(i))) {
            continue;
        }
        Set<Character> vowels = new HashSet<>();
        vowels.add(str.charAt(i));
        for (int j = i + 1; j < n; j++) {
            if (!isVowel(str.charAt(j))) {
                continue;
            }
            vowels.add(str.charAt(j));
            if (vowels.size() == 5) {
                System.out.println(str.substring(i, j + 1));
            }
        }
    }
}
```","```python
def find_substrings_with_all_vowels(str):
  vowels = set('aeiouAEIOU')
  result = []
  for i in range(len(str)):
    hash = set()
    for j in range(i, len(str)):
      if str[j] not in vowels:
        break
      hash.add(str[j].lower())
      if len(hash) == len(vowels):
        result.append(str[i:j+1])
  return result
```"
536,Find if an array contains a string with one mismatch | Java program to find if given string is present with one mismatch . ; If the array is empty ; If sizes are same ; If first mismatch ; Second mismatch ; Driver code,"```java
public static boolean findStringWithOneMismatch(String[] arr, String str) {
    if (arr.length == 0) {
      return false;
    }
    for (String s : arr) {
      if (s.length() != str.length()) {
        continue;
      }
      int mismatchCount = 0;
      for (int i = 0; i < str.length(); i++) {
        if (s.charAt(i) != str.charAt(i)) {
          mismatchCount++;
          if (mismatchCount > 1) {
            break;
          }
        }
      }
      if (mismatchCount == 1) {
        return true;
      }
    }
    return false;
  }
```","```python
def find_string_with_one_mismatch(arr, str1):
  if len(arr) == 0:
    return False
  if len(arr[0]) != len(str1):
    return False
  for i in range(len(arr)):
    mismatch_count = 0
    for j in range(len(str1)):
      if arr[i][j] != str1[j]:
        mismatch_count += 1
        if mismatch_count > 1:
          break
    if mismatch_count == 1:
      return True
  return False
```"
537,"Sentence Palindrome ( Palindrome after removing spaces , dots , . . etc ) | Java program to find if a sentence is palindrome ; To check sentence is palindrome or not ; Lowercase string ; Compares character until they are equal ; If there is another symbol in left of sentence ; If there is another symbol in right of sentence ; If characters are equal ; If characters are not equal then sentence is not palindrome ; Returns true if sentence is palindrome ; Driver program to test sentencePallindrome ( )","```java
public static boolean sentencePalindrome(String sentence) {
    sentence = sentence.toLowerCase().replaceAll(""[^a-z]"", """");
    int left = 0;
    int right = sentence.length() - 1;
    while (left < right) {
      if (sentence.charAt(left) != sentence.charAt(right)) {
        return false;
      }
      left++;
      right--;
    }
    return true;
  }
```","```python
def sentencePallindrome(sentence):
  sentence = sentence.lower()
  sentence = sentence.replace("" "", """")
  sentence = sentence.replace(""."", """")
  sentence = sentence.replace("","", """")
  left = 0
  right = len(sentence) - 1
  while left < right:
    if not sentence[left].isalnum():
      left += 1
    elif not sentence[right].isalnum():
      right -= 1
    elif sentence[left] == sentence[right]:
      left += 1
      right -= 1
    else:
      return False
  return True
```"
538,Ways to remove one element from a binary string so that XOR becomes zero | Java program to count number of ways to remove an element so that XOR of remaining string becomes 0. ; Returns number of ways in which XOR become ZERO by remove 1 element ; Counting number of 0 and 1 ; If count of ones is even then return count of zero else count of one ; Driver Code to test above function,"```java
public static int countWays(String str) {
    int count0 = 0;
    int count1 = 0;
    for (int i = 0; i < str.length(); i++) {
      if (str.charAt(i) == '0') {
        count0++;
      } else {
        count1++;
      }
    }
    if (count1 % 2 == 0) {
      return count0;
    } else {
      return count1;
    }
  }
```","```python
def count_ways(s):
  count_zero = s.count('0')
  count_one = s.count('1')
  if count_one % 2 == 0:
    return count_zero
  else:
    return count_one
```"
539,"Keyword Cipher | Java program for encoding the string using classical cipher ; Function generates the encoded text ; This array represents the 26 letters of alphabets ; This loop inserts the keyword at the start of the encoded string ; To check whether the character is inserted earlier in the encoded string or not ; This loop inserts the remaining characters in the encoded string . ; Function that generates encodes ( cipher ) the message ; This loop ciphered the message . Spaces , special characters and numbers remain same . ; Driver code ; Hold the Keyword ; Function call to generate encoded text ; Message that need to encode ; Function call to print ciphered text","```java
public static String encode(String message, String keyword) {
    char[] alphabet = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    String encoded = """";
    for (int i = 0; i < keyword.length(); i++) {
        if (!encoded.contains(String.valueOf(keyword.charAt(i)))) {
            encoded += keyword.charAt(i);
        }
    }
    for (int i = 0; i < alphabet.length; i++) {
        if (!encoded.contains(String.valueOf(alphabet[i]))) {
            encoded += alphabet[i];
        }
    }
    String ciphered = """";
    for (int i = 0; i < message.length(); i++) {
        if (Character.isLetter(message.charAt(i))) {
            int index = encoded.indexOf(Character.toLowerCase(message.charAt(i)));
            if (Character.isUpperCase(message.charAt(i))) {
                ciphered += Character.toUpperCase(encoded.charAt(index));
            } else {
                ciphered += encoded.charAt(index);
            }
        } else {
            ciphered += message.charAt(i);
        }
    }
    return ciphered;
}
```","```python
def encode(message, keyword):
  alphabet = ""abcdefghijklmnopqrstuvwxyz""
  encoded = """"
  for char in keyword:
    if char not in encoded:
      encoded += char
  for char in alphabet:
    if char not in encoded:
      encoded += char
  cipher = """"
  for char in message:
    if char.isalpha():
      cipher += encoded[ord(char.lower()) - ord('a')]
    else:
      cipher += char
  return cipher

keyword = ""python""
message = ""Hello world!""
cipher = encode(message, keyword)
print(cipher)
```"
540,Check if both halves of the string have same set of characters | Java program to check if it two half of string contain same Character set or not ; function to check both halves for equality ; Counter array initialized with 0 ; Length of the string ; traverse till the middle element is reached ; First half ; Second half ; Checking if values are different set flag to 1 ; Driver program to test above function ; String to be checked,"```java
public static boolean checkHalfStrings(String str) {
    int[] count = new int[26];
    int len = str.length();
    for (int i = 0; i < len / 2; i++) {
      count[str.charAt(i) - 'a']++;
      count[str.charAt(i + len / 2) - 'a']--;
    }
    for (int i = 0; i < 26; i++) {
      if (count[i] != 0) {
        return false;
      }
    }
    return true;
  }
```","```python
def check_halves(s):
  n = len(s)
  arr = [0] * 26
  for i in range(n // 2):
    arr[ord(s[i]) - ord('a')] += 1
  for i in range(n // 2, n):
    arr[ord(s[i]) - ord('a')] -= 1
  for i in range(26):
    if arr[i] != 0:
      return False
  return True
```"
541,"Check if a string is Isogram or not | Java code to check string is isogram or not ; function to check isogram ; loop to store count of chars and check if it is greater than 1 ; if count > 1 , return false ; Driver code ; checking str as isogram ; checking str2 as isogram","```java
public static boolean isIsogram(String str) {
    if (str.length() == 0) {
      return true;
    }
    str = str.toLowerCase();
    for (int i = 0; i < str.length(); i++) {
      char c = str.charAt(i);
      int count = 0;
      for (int j = 0; j < str.length(); j++) {
        if (str.charAt(j) == c) {
          count++;
        }
      }
      if (count > 1) {
        return false;
      }
    }
    return true;
  }
```","```python
def is_isogram(str1):
  for char in str1:
    if str1.count(char) > 1:
      return False
  return True
```"
542,Check if a binary string has a 0 between 1 s or not | Set 1 ( General approach ) | Java program to check if a string is valid or not . ; Method returns 1 when string is valid else returns 0 ; Find first occurrence of 1 in s [ ] ; Find last occurrence of 1 in s [ ] ; Check if there is any 0 in range ; Driver method,"```java
public static int isValid(String s) {
  int firstOne = s.indexOf('1');
  int lastOne = s.lastIndexOf('1');
  for (int i = firstOne + 1; i < lastOne; i++) {
    if (s.charAt(i) == '0') {
      return 1;
    }
  }
  return 0;
}
```","```python
def is_valid(s):
  first_one = s.find('1')
  last_one = s.rfind('1')
  for i in range(first_one + 1, last_one):
    if s[i] == '0':
      return 1
  return 0
```"
543,Program to print all substrings of a given string | Java program to print all possible subStrings of a given String without checking for duplication . ; Function to print all ( n * ( n + 1 ) ) \/ 2 subStrings of a given String s of length n . ; Fix start index in outer loop . Reveal new character in inner loop till end of String . Print till - now - formed String . ; Driver code,"```java
public static void printSubstrings(String s) {
    int n = s.length();
    for (int i = 0; i < n; i++) {
      for (int j = i; j < n; j++) {
        System.out.println(s.substring(i, j + 1));
      }
    }
  }
```","```python
def print_all_substrings(s):
  n = len(s)
  for i in range(n):
    for j in range(i, n):
      print(s[i:j+1])
```"
544,"Reverse a string preserving space positions | Java program to implement the above approach ; Initialize two pointers as two corners ; Move both pointers toward each other ; If character at start or end is space , ignore it ; If both are not spaces , do swap ; Driver Code","```java
public static void reverseString(char[] str) {
    int start = 0;
    int end = str.length - 1;
    while (start < end) {
        if (str[start] == ' ') {
            start++;
        } else if (str[end] == ' ') {
            end--;
        } else {
            char temp = str[start];
            str[start] = str[end];
            str[end] = temp;
            start++;
            end--;
        }
    }
}
```","```python
def reverse_string_preserve_space(s):
  start = 0
  end = len(s) - 1
  while start < end:
    if s[start] == ' ':
      start += 1
    elif s[end] == ' ':
      end -= 1
    else:
      s = s[:start] + s[end] + s[start+1:end] + s[start] + s[end+1:]
      start += 1
      end -= 1
  return s
```"
545,Put spaces between words starting with capital letters | Java program to put spaces between words starting with capital letters . ; Function to amend the sentence ; Traverse the string ; Convert to lowercase if its an uppercase character ; Print space before it if its an uppercase character ; Print the character ; if lowercase character then just print ; Driver Code,"```java
public static void amendSentence(String sentence) {
  for (int i = 0; i < sentence.length(); i++) {
    char ch = sentence.charAt(i);
    if (Character.isUpperCase(ch)) {
      System.out.print("" "");
      System.out.print(Character.toLowerCase(ch));
    } else {
      System.out.print(ch);
    }
  }
}
```","```python
def amend_sentence(sentence):
  for i in range(len(sentence)):
    if sentence[i].isupper():
      print("" "", end="""")
      print(sentence[i].lower(), end="""")
    else:
      print(sentence[i], end="""")
```"
546,C ++ program to concatenate a string given number of times | Java program to concatenate given string n number of times ; Function which return string by concatenating it . ; Copying given string to temporary string . ; Concatenating strings ; Driver code,"```java
public static String concatenateString(String str, int n) {
    String temp = str;
    for (int i = 1; i < n; i++) {
      temp += str;
    }
    return temp;
  }
```","```python
def concatenate_string(string, n):
  temp_string = """"
  for i in range(n):
    temp_string += string
  return temp_string
```"
547,Number of distinct permutation a String can have | Java program to find number of distinct permutations of a string . ; Utility function to find factorial of n . ; Returns count of distinct permutations of str . ; finding frequency of all the lower case alphabet and storing them in array of integer ; finding factorial of number of appearances and multiplying them since they are repeating alphabets ; finding factorial of size of string and dividing it by factorial found after multiplying ; Driver code,"```java
public static long countDistinctPermutations(String str) {
    int[] charFreq = new int[26];
    for (char c : str.toCharArray()) {
        charFreq[c - 'a']++;
    }
    long fact = factorial(str.length());
    long repeatFact = 1;
    for (int freq : charFreq) {
        repeatFact *= factorial(freq);
    }
    return fact / repeatFact;
}

private static long factorial(int n) {
    if (n == 0) {
        return 1;
    }
    return n * factorial(n - 1);
}
```","```python
from math import factorial

def countDistinctPermutations(str):
  freq = [0] * 26
  for i in range(len(str)):
    freq[ord(str[i]) - ord('a')] += 1
  fact_freq = 1
  for i in range(26):
    fact_freq *= factorial(freq[i])
  return factorial(len(str)) // fact_freq
```"
548,"Determine if a string has all Unique Characters | Java program to illustrate String with unique characters without using any data structure ; Assuming string can have characters a - z this has 32 bits set to 0 ; if that bit is already set in checker , return false ; otherwise update and continue by setting that bit in the checker ; no duplicates encountered , return true ; Driver Code","```java
public static boolean isUniqueChars(String str) {
    int checker = 0;
    for (int i = 0; i < str.length(); i++) {
      int bitIndex = str.charAt(i) - 'a';
      if ((checker & (1 << bitIndex)) > 0) {
        return false;
      }
      checker |= (1 << bitIndex);
    }
    return true;
  }
```","```python
def has_unique_chars(string):
  checker = 0
  for char in string:
    val = ord(char) - ord('a')
    if (checker & (1 << val)) > 0:
      return False
    checker |= (1 << val)
  return True
```"
549,Alternate vowel and consonant string | Java implementation of alternate vowel and consonant string ; ' ch ' is vowel or not ; create alternate vowel and consonant string str1 [ 0. . . l1 - 1 ] and str2 [ start ... l2 - 1 ] ; first adding character of vowel \/ consonant then adding character of consonant \/ vowel ; function to find the required alternate vowel and consonant string ; count vowels and update vowel string ; count consonants and update consonant string ; no such string can be formed ; remove first character of vowel string then create alternate string with cstr [ 0. . . nc - 1 ] and vstr [ 1. . . nv - 1 ] ; remove first character of consonant string then create alternate string with vstr [ 0. . . nv - 1 ] and cstr [ 1. . . nc - 1 ] ; if both vowel and consonant strings are of equal length start creating string with consonant ; start creating string with vowel ; Driver code,"```java
public static String alternateVowelConsonant(String str) {
    int l1 = str.length();
    int nv = 0, nc = 0;
    String vstr = """";
    String cstr = """";
    for (int i = 0; i < l1; i++) {
      char ch = str.charAt(i);
      if (isVowel(ch)) {
        nv++;
        vstr += ch;
      } else {
        nc++;
        cstr += ch;
      }
    }
    if (Math.abs(nv - nc) > 1) {
      return ""No such string can be formed"";
    }
    if (nv == nc) {
      return createAlternateString(cstr, vstr);
    } else if (nv > nc) {
      return createAlternateString(vstr.substring(1), cstr);
    } else {
      return createAlternateString(cstr.substring(1), vstr);
    }
  }
  private static String createAlternateString(String str1, String str2) {
    int l1 = str1.length();
    int l2 = str2.length();
    String result = """";
    for (int i = 0, j = 0; i < l1 || j < l2; ) {
      if (i < l1) {
        result += str1.charAt(i++);
      }
      if (j < l2) {
        result += str2.charAt(j++);
      }
    }
    return result;
  }
  private static boolean isVowel(char ch) {
    return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||
           ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
  }
```","```python
def alternate_vowel_consonant(str1):
  l1 = len(str1)
  vowels = ""aeiouAEIOU""
  vstr = """"
  cstr = """"
  nv = 0
  nc = 0
  for i in range(l1):
    if str1[i] in vowels:
      nv += 1
      vstr += str1[i]
    else:
      nc += 1
      cstr += str1[i]
  if abs(nv - nc) > 1:
    return ""No such string can be formed""
  if nv == nc:
    res = """"
    for i in range(nv):
      res += cstr[i] + vstr[i]
    return res
  elif nv > nc:
    res = """"
    for i in range(nc):
      res += vstr[i] + cstr[i]
    res += vstr[nc]
    return res
  else:
    res = """"
    for i in range(nv):
      res += cstr[i] + vstr[i]
    res += cstr[nv]
    return res
```"
550,Check whether K | Java program to check if k - th bit of a given number is set or not ; driver code,"```java
public static boolean isKthBitSet(int n, int k) {
    return ((n >> (k - 1)) & 1) == 1;
}
```","```python
def is_kth_bit_set(n, k):
  return (n >> k) & 1
```"
551,Reverse string without using any temporary variable | Reversing a string using reverse ( ) ; Reverse str [ beign . . end ],"```java
public static String reverseString(String str) {
    return new StringBuilder(str).reverse().toString();
}
```","```python
def reverse_string(s):
  return s[::-1]
```"
552,"Recursive function to check if a string is palindrome | A recursive JAVA program to check whether a given String is palindrome or not ; A recursive function that check a str ( s . . e ) is palindrome or not . ; If there is only one character ; If first and last characters do not match ; If there are more than two characters , check if middle substring is also palindrome or not . ; An empty string is considered as palindrome ; Driver Code","```java
public static boolean isPalindrome(String str, int s, int e) {
    if (s == e) {
        return true;
    }
    if (str.charAt(s) != str.charAt(e)) {
        return false;
    }
    if (s < e + 1) {
        return isPalindrome(str, s + 1, e - 1);
    }
    return true;
}
```","```python
def is_palindrome(s, start, end):
  if start >= end:
    return True
  if s[start] != s[end]:
    return False
  return is_palindrome(s, start + 1, end - 1)
```"
553,Count substrings with same first and last characters | Most efficient Java program to count all substrings with same first and last characters . ; assuming lower case only ; Calculating frequency of each character in the string . ; Computing result using counts ; Driver function,"```java
public static int countSubstrings(String str) {
    int[] charCount = new int[26];
    for (int i = 0; i < str.length(); i++) {
        charCount[str.charAt(i) - 'a']++;
    }
    int result = 0;
    for (int i = 0; i < 26; i++) {
        result += charCount[i] * (charCount[i] + 1) / 2;
    }
    return result;
}
```","```python
def count_substrings(s):
  n = len(s)
  freq = [0] * 26
  for i in range(n):
    freq[ord(s[i]) - ord('a')] += 1
  result = 0
  for i in range(26):
    result += freq[i] * (freq[i] + 1) // 2
  return result - n
```"
554,"Maximum consecutive repeating character in string | Java program to find the maximum consecutive repeating character in given string ; function to find out the maximum repeating character in given string ; Traverse string except last character ; If current character matches with next ; If doesn 't match, update result  (if required) and reset count ; Driver code","```java
public static char maxRepeating(String str) {
    if (str.length() == 0) {
        return ' ';
    }
    char result = str.charAt(0);
    int count = 1;
    int maxCount = 1;
    for (int i = 0; i < str.length() - 1; i++) {
        if (str.charAt(i) == str.charAt(i + 1)) {
            count++;
        } else {
            if (count > maxCount) {
                maxCount = count;
                result = str.charAt(i);
            }
            count = 1;
        }
    }
    if (count > maxCount) {
        maxCount = count;
        result = str.charAt(str.length() - 1);
    }
    return result;
}
```","```python
def max_repeating_char(s):
  if len(s) == 0:
    return ''
  max_char = s[0]
  max_count = 1
  current_char = s[0]
  current_count = 1
  for i in range(1, len(s)):
    if s[i] == current_char:
      current_count += 1
    else:
      if current_count > max_count:
        max_count = current_count
        max_char = current_char
      current_char = s[i]
      current_count = 1
  if current_count > max_count:
    max_count = current_count
    max_char = current_char
  return max_char
```"
555,"Queries on subsequence of string | Java program to answer subsequence queries for a given string . ; Precompute the position of each character from each position of String S ; Computing position of each character from each position of String S ; Print "" Yes "" if T is subsequence of S , else "" No "" ; Traversing the string T ; If next position is greater than length of S set flag to false . ; Setting position of next character ; Driven Program","```java
public static void subsequenceQueries(String s, String t) {
    int[][] pos = new int[s.length()][26];
    for (int i = 0; i < s.length(); i++) {
        pos[i][s.charAt(i) - 'a'] = i + 1;
        for (int j = 0; j < 26; j++) {
            if (j != s.charAt(i) - 'a') {
                pos[i][j] = pos[i - 1][j];
            }
        }
    }
    int next = 0;
    boolean flag = true;
    for (int i = 0; i < t.length(); i++) {
        if (next >= s.length()) {
            flag = false;
            break;
        }
        next = pos[next][t.charAt(i) - 'a'];
    }
    if (flag) {
        System.out.print("" Yes "");
    } else {
        System.out.print("" No "");
    }
}
```","```python
def subsequence_queries(S, queries):
  n = len(S)
  pos = [[-1] * 26 for _ in range(n + 1)]
  for i in range(n):
    for j in range(26):
      pos[i + 1][j] = pos[i][j]
    pos[i + 1][ord(S[i]) - ord('a')] = i + 1
  result = []
  for T in queries:
    m = len(T)
    j = 0
    flag = True
    for i in range(m):
      j = pos[j][ord(T[i]) - ord('a')]
      if j == -1:
        flag = False
        break
    if flag:
      result.append(""Yes"")
    else:
      result.append(""No"")
  return result
```"
556,"Queries for characters in a repeated string | Java Program to Queries for same characters in a repeated string ; Print whether index i and j have same element or not ; Finding relative position of index i , j ; Checking is element are same at index i , j ; Driver Code","```java
public static void queryCharacters(String str, int[][] queries) {
    for (int[] query : queries) {
        int i = query[0];
        int j = query[1];
        int length = str.length();
        int relativePosition = (j - i + length) % length;
        if (str.charAt(i) == str.charAt(relativePosition)) {
            System.out.println(""Same"");
        } else {
            System.out.println(""Different"");
        }
    }
}
```","```python
def query_repeated_string(s, q):
  n = len(s)
  for i in range(q):
    l, r = map(int, input().split())
    if s[l % n] == s[r % n]:
      print(""Yes"")
    else:
      print(""No"")
```"
557,Count of character pairs at same distance as in English alphabets | A Simple Java program to find pairs with distance equal to English alphabet distance ; Method to count pairs ; Increment count if characters are at same distance ; Driver method,"```java
public static int countPairs(String str) {
    int count = 0;
    for (int i = 0; i < str.length() - 1; i++) {
      for (int j = i + 1; j < str.length(); j++) {
        if (Math.abs(str.charAt(i) - str.charAt(j)) == Math.abs(i - j)) {
          count++;
        }
      }
    }
    return count;
  }
```","```python
def count_pairs(str1):
  count = 0
  for i in range(len(str1) - 1):
    for j in range(i + 1, len(str1)):
      if abs(ord(str1[i]) - ord(str1[j])) == abs(ord(str1[i]) - ord(str1[i + 1])):
        count += 1
  return count
```"
558,"Longest common subsequence with permutations allowed | Java program to find LCS with permutations allowed ; Function to calculate longest String str1 -- > first String str2 -- > second String count1 [ ] -- > hash array to calculate frequency of characters in str1 count [ 2 ] -- > hash array to calculate frequency of characters in str2 result -- > resultant longest String whose permutations are sub - sequence of given two strings ; calculate frequency of characters ; Now traverse hash array ; for ( int i = 0 ; i < 26 ; i ++ ) append character ( ' a ' + i ) in resultant String ' result ' by min ( count1 [ i ] , count2i ] ) times ; Driver program to run the case","```java
public static String longestCommonSubsequenceWithPermutation(String str1, String str2) {
    int[] count1 = new int[26];
    int[] count2 = new int[26];
    for (char c : str1.toCharArray()) {
      count1[c - 'a']++;
    }
    for (char c : str2.toCharArray()) {
      count2[c - 'a']++;
    }
    StringBuilder result = new StringBuilder();
    for (int i = 0; i < 26; i++) {
      for (int j = 0; j < Math.min(count1[i], count2[i]); j++) {
        result.append((char)('a' + i));
      }
    }
    return result.toString();
  }
```","```python
def longest_common_subsequence_with_permutations(str1, str2):
  count1 = [0] * 26
  count2 = [0] * 26
  for i in range(len(str1)):
    count1[ord(str1[i]) - ord('a')] += 1
  for i in range(len(str2)):
    count2[ord(str2[i]) - ord('a')] += 1
  result = ''
  for i in range(26):
    result += chr(ord('a') + i) * min(count1[i], count2[i])
  return result
```"
559,"Check if string follows order of characters defined by a pattern or not | Set 1 | Java program check if characters in the input string follows the same order as determined by characters present in the given pattern ; Function to check if characters in the input string follows the same order as determined by characters present in the given pattern ; len stores length of the given pattern ; if length of pattern is more than length of input string , return false ; ; x , y are two adjacent characters in pattern ; find index of last occurrence of character x in the input string ; find index of first occurrence of character y in the input string ; return false if x or y are not present in the input string OR last occurrence of x is after the first occurrence of y in the input string ; return true if string matches the pattern ; Driver code","```java
public static boolean checkStringOrder(String str, String pattern) {
    if (pattern.length() > str.length()) {
        return false;
    }
    for (int i = 0; i < pattern.length() - 1; i++) {
        char x = pattern.charAt(i);
        char y = pattern.charAt(i + 1);
        int lastX = str.lastIndexOf(x);
        int firstY = str.indexOf(y);
        if (lastX == -1 || firstY == -1 || lastX > firstY) {
            return false;
        }
    }
    return true;
}
```","```python
def check_pattern(pattern, input_string):
  len_pattern = len(pattern)
  if len_pattern > len(input_string):
    return False
  for i in range(len_pattern - 1):
    x = pattern[i]
    y = pattern[i + 1]
    last_x = input_string.rfind(x)
    first_y = input_string.find(y)
    if last_x == -1 or first_y == -1 or last_x > first_y:
      return False
  return True
```"
560,Calculate sum of all numbers present in a string | Java program to calculate sum of all numbers present in a string containing alphanumeric characters ; Function to calculate sum of all numbers present in a string containing alphanumeric characters ; A temporary string ; holds sum of all numbers present in the string ; read each character in input string ; if current character is a digit ; if current character is an alphabet ; increment sum by number found earlier ( if any ) ; reset temporary string to empty ; atoi ( temp . c_str ( ) ) takes care of trailing numbers ; Driver code ; input alphanumeric string ; Function call,"```java
public static int sumOfNumbersInString(String str) {
    String temp = """";
    int sum = 0;
    for (int i = 0; i < str.length(); i++) {
      if (Character.isDigit(str.charAt(i))) {
        temp += str.charAt(i);
      } else {
        if (!temp.isEmpty()) {
          sum += Integer.parseInt(temp);
          temp = """";
        }
      }
    }
    if (!temp.isEmpty()) {
      sum += Integer.parseInt(temp);
    }
    return sum;
  }
```","```python
def sum_of_numbers_in_string(s):
  temp = """"
  sum = 0
  for char in s:
    if char.isdigit():
      temp += char
    else:
      if temp:
        sum += int(temp)
        temp = """"
  if temp:
    sum += int(temp)
  return sum
```"
561,"Count number of substrings with exactly k distinct characters | Java program to CountKSubStr number of substrings with exactly distinct characters in a given string ; Function to count number of substrings with exactly k unique characters ; Initialize result ; To store count of characters from ' a ' to ' z ' ; Consider all substrings beginning with str [ i ] ; Initializing count array with 0 ; Consider all substrings between str [ i . . j ] ; If this is a new character for this substring , increment dist_count . ; Increment count of current character ; If distinct character count becomes k , then increment result . ; Driver Program","```java
public static int CountKSubStr(String str, int k) {
    int result = 0;
    int[] count = new int[26];
    for (int i = 0; i < str.length(); i++) {
        Arrays.fill(count, 0);
        int dist_count = 0;
        for (int j = i; j < str.length(); j++) {
            if (count[str.charAt(j) - 'a'] == 0) {
                dist_count++;
            }
            count[str.charAt(j) - 'a']++;
            if (dist_count == k) {
                result++;
            }
        }
    }
    return result;
}
```","```python
def countKSubStr(str, k):
  result = 0
  n = len(str)
  for i in range(n):
    count = [0] * 26
    dist_count = 0
    for j in range(i, n):
      if count[ord(str[j]) - ord('a')] == 0:
        dist_count += 1
      count[ord(str[j]) - ord('a')] += 1
      if dist_count == k:
        result += 1
  return result
```"
562,Lower case to upper case | Java program to convert a string to uppercase ; Converts a string to uppercase ; Driver code,"```java
public static String toUpperCase(String str) {
    return str.toUpperCase();
}
```","```python
def to_uppercase(string):
  return string.upper()
```"
563,Longest Common Prefix using Character by Character Matching | A Java Program to find the longest common prefix ; A Function to find the string having the minimum length and returns that length ; A Function that returns the longest common prefix from the array of strings ; Our resultant string char current ; The current character ; Current character ( must be same in all strings to be a part of result ) ; Append to result ; Driver program to test above function,"```java
public static String longestCommonPrefix(String[] strs) {
    if (strs.length == 0) {
        return """";
    }
    String prefix = strs[0];
    for (int i = 1; i < strs.length; i++) {
        while (!strs[i].startsWith(prefix)) {
            prefix = prefix.substring(0, prefix.length() - 1);
            if (prefix.isEmpty()) {
                return """";
            }
        }
    }
    return prefix;
}
```","```python
def longestCommonPrefix(strs):
  if not strs:
    return """"
  minLength = min([len(s) for s in strs])
  result = """"
  for i in range(minLength):
    current = strs[0][i]
    for j in range(1, len(strs)):
      if strs[j][i] != current:
        return result
    result += current
  return result
```"
564,"Print Concatenation of Zig | Java program to print string obtained by concatenation of different rows of Zig - Zag fashion ; Prints concatenation of all rows of str 's  Zig-Zag fashion ; Corner Case ( Only one row ) ; Find length of string ; Create an array of strings for all n rows ; Initialize index for array of strings arr [ ] ; True if we are moving down in rows , else false ; Traverse through given string ; append current character to current row ; If last row is reached , change direction to ' up ' ; If 1 st row is reached , change direction to ' down ' ; If direction is down , increment , else decrement ; Print concatenation of all rows ; Driver Code","```java
public static String printZigZagConcat(String str) {
    int n = str.length();
    if (n == 1) {
      return str;
    }
    String[] arr = new String[n];
    for (int i = 0; i < n; i++) {
      arr[i] = """";
    }
    int index = 0;
    boolean down = true;
    for (int i = 0; i < n; i++) {
      arr[index] += str.charAt(i);
      if (index == n - 1) {
        down = false;
      }
      if (index == 0) {
        down = true;
      }
      if (down) {
        index++;
      } else {
        index--;
      }
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < n; i++) {
      sb.append(arr[i]);
    }
    return sb.toString();
  }
```","```python
def printZigZagConcat(str):
  n = len(str)
  if n == 1:
    print(str)
    return

  arr = ["""" for _ in range(n)]
  row = 0
  down = True
  for i in range(n):
    arr[row] += str[i]
    if row == n - 1:
      down = False
    if row == 0:
      down = True
    if down:
      row += 1
    else:
      row -= 1
  print("""".join(arr))
```"
565,"Check if two given strings are isomorphic to each other | Java program to check if two strings are isomorphic ; Function returns true if str1 and str2 are isomorphic ; Length of both strings must be same for one to one corresponance ; To mark visited characters in str2 ; To store mapping of every character from str1 to that of str2 . Initialize all entries of map as - 1. ; Process all characters one by on ; If current character of str1 is seen first time in it . ; If current character of str2 is already seen , one to one mapping not possible ; Mark current character of str2 as visited ; Store mapping of current characters ; If this is not first appearance of current character in str1 , then check if previous appearance mapped to same character of str2 ; driver program","```java
public boolean areIsomorphic(String str1, String str2) {
    if (str1.length() != str2.length()) {
      return false;
    }
    boolean[] visited = new boolean[256];
    int[] map = new int[256];
    for (int i = 0; i < 256; i++) {
      map[i] = -1;
    }
    for (int i = 0; i < str1.length(); i++) {
      char ch1 = str1.charAt(i);
      char ch2 = str2.charAt(i);
      if (map[ch1] == -1) {
        if (visited[ch2]) {
          return false;
        }
        visited[ch2] = true;
        map[ch1] = ch2;
      } else {
        if (map[ch1] != ch2) {
          return false;
        }
      }
    }
    return true;
  }
```","```python
def areIsomorphic(str1, str2):
  if len(str1) != len(str2):
    return False
  visited = [False] * 256
  map = [-1] * 256
  for i in range(len(str1)):
    if map[ord(str1[i])] == -1:
      if visited[ord(str2[i])]:
        return False
      visited[ord(str2[i])] = True
      map[ord(str1[i])] = ord(str2[i])
    else:
      if map[ord(str1[i])] != ord(str2[i]):
        return False
  return True
```"
566,Check if two given strings are isomorphic to each other | Java program for the above approach ; This function returns true if str1 and str2 are isomorphic ; Length of both strings must be same for one to one correspondence ; For counting the previous appearances of character in both the strings ; Process all characters one by one ; For string to be isomorphic the previous counts of appearances of current character in both string must be same if it is not same we return false . ; Driver Code,"```java
public static boolean areIsomorphic(String str1, String str2) {
    if (str1.length() != str2.length()) {
      return false;
    }
    int[] charCount1 = new int[256];
    int[] charCount2 = new int[256];
    for (int i = 0; i < str1.length(); i++) {
      charCount1[str1.charAt(i)]++;
      charCount2[str2.charAt(i)]++;
      if (charCount1[str1.charAt(i)] != charCount2[str2.charAt(i)]) {
        return false;
      }
    }
    return true;
  }
```","```python
def areIsomorphic(str1, str2):
  if len(str1) != len(str2):
    return False
  charCount1 = {}
  charCount2 = {}
  for i in range(len(str1)):
    if str1[i] not in charCount1:
      charCount1[str1[i]] = 0
    charCount1[str1[i]] += 1
    if str2[i] not in charCount2:
      charCount2[str2[i]] = 0
    charCount2[str2[i]] += 1
    if charCount1[str1[i]] != charCount2[str2[i]]:
      return False
  return True
```"
567,Minimum insertions to form shortest palindrome | Java program to find minimum number of insertions on left side to form a palindrome . ; Returns true if a string str [ st . . end ] is palindrome ; Returns count of insertions on left side to make str [ ] a palindrome ; Find the largest prefix of given string that is palindrome . ; Characters after the palindromic prefix must be added at the beginning also to make the complete string palindrome ; Driver Code,"```java
public static int minInsertions(String str) {
    int n = str.length();
    if (n == 0) {
        return 0;
    }
    int[][] dp = new int[n][n];
    for (int i = 0; i < n; i++) {
        dp[i][i] = 1;
    }
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            if (str.charAt(i) == str.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return n - dp[0][n - 1];
}
```","```python
def minInsertions(str):
    n = len(str)
    if n < 2:
        return 0
    
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            if str[i] == str[j]:
                dp[i][j] = dp[i + 1][j - 1]
            else:
                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1
    return dp[0][n - 1]
```"
568,"Remove repeated digits in a given number | Java program to remove repeated digits ; Store first digits as previous digit ; Initialize power ; Iterate through all digits of n , note that the digits are processed from least significant digit to most significant digit . ; Store current digit ; Add the current digit to the beginning of result ; Update previous result and power ; Remove last digit from n ; Driver program","```java
public static int removeRepeatedDigits(int n) {
    int previousDigit = -1;
    int power = 1;
    int result = 0;
    while (n > 0) {
        int currentDigit = n % 10;
        if (currentDigit != previousDigit) {
            result = currentDigit * power + result;
            previousDigit = currentDigit;
            power *= 10;
        }
        n /= 10;
    }
    return result;
}
```","```python
def remove_repeated_digits(n):
  previous_digit = -1
  power = 1
  result = 0
  while n > 0:
    current_digit = n % 10
    if current_digit != previous_digit:
      result = current_digit * power + result
      previous_digit = current_digit
      power *= 10
    n //= 10
  return result
```"
569,"Remove "" b "" and "" ac "" from a given string | A Java program to remove "" b "" and ' ac ' from input string ; The main function that removes occurrences of "" a "" and "" bc "" in input string ; previous character ; current character ; check if current and next character forms ac ; if current character is b ; if current char is ' c ▁ & & ▁ last ▁ char ▁ in ▁ output ▁ ▁ ▁ is ▁ ' a ' so delete both  ; else copy curr char to output string ; Driver program to check above functions","```java
public static String removeChars(String str) {
    StringBuilder output = new StringBuilder();
    char lastChar = ' ';
    for (int i = 0; i < str.length(); i++) {
      char currChar = str.charAt(i);
      if (i < str.length() - 1 && currChar == 'a' && str.charAt(i + 1) == 'c') {
        i++;
      } else if (currChar == 'b') {
      } else if (currChar == 'c' && lastChar == 'a') {
        output.deleteCharAt(output.length() - 1);
      } else {
        output.append(currChar);
      }
      lastChar = currChar;
    }
    return output.toString();
  }
```","```python
def remove_characters(input_string):
  output_string = ''
  last_char = ''
  for i in range(len(input_string)):
    curr_char = input_string[i]
    if i < len(input_string) - 1 and curr_char == 'a' and input_string[i + 1] == 'c':
      i += 1
    elif curr_char == 'b':
      pass
    elif curr_char == 'c' and last_char == 'a':
      last_char = ''
    else:
      output_string += curr_char
      last_char = curr_char
  return output_string
```"
570,Write your own atoi ( ) | A simple Java program for implementation of atoi ; if whitespaces then ignore . ; sign of number ; checking for valid input ; handling overflow test case ; Driver code ; Function call,"```java
public static int atoi(String str) {
    if (str == null || str.isEmpty()) {
        return 0;
    }
    int sign = 1;
    int index = 0;
    while (index < str.length() && Character.isWhitespace(str.charAt(index))) {
        index++;
    }
    if (index < str.length() && (str.charAt(index) == '+' || str.charAt(index) == '-')) {
        sign = str.charAt(index) == '-' ? -1 : 1;
        index++;
    }
    long result = 0;
    while (index < str.length() && Character.isDigit(str.charAt(index))) {
        result = result * 10 + (str.charAt(index) - '0');
        if (result * sign > Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        }
        if (result * sign < Integer.MIN_VALUE) {
            return Integer.MIN_VALUE;
        }
        index++;
    }
    return (int) (result * sign);
}
```","```python
def my_atoi(str):
  if not str:
    return 0
  str = str.strip()
  sign = 1
  if str[0] == '-':
    sign = -1
    str = str[1:]
  elif str[0] == '+':
    str = str[1:]
  result = 0
  for char in str:
    if not char.isdigit():
      return 0
    result = result * 10 + int(char)
    if result > 2**31 - 1 and sign == 1:
      return 2**31 - 1
    if result > 2**31 and sign == -1:
      return -2**31
  return result * sign
```"
571,"Check whether two strings are anagram of each other | Java program to check if two strings are anagrams of each other ; function to check if two strings are anagrams of each other ; Create a count array and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; If both strings are of different length . Removing this condition will make the program fail for strings like "" aaca "" and "" aca "" ; See if there is any non - zero value in count array ; Driver code ; Function call","```java
public static boolean areAnagrams(String str1, String str2) {
    if (str1.length() != str2.length()) {
        return false;
    }
    int[] count = new int[256];
    for (int i = 0; i < str1.length(); i++) {
      count[str1.charAt(i)]++;
      count[str2.charAt(i)]--;
    }
    for (int i = 0; i < 256; i++) {
      if (count[i] != 0) {
        return false;
      }
    }
    return true;
  }
```","```python
def areAnagrams(str1, str2):
  if len(str1) != len(str2):
    return False
  count = [0] * 256
  for i in range(len(str1)):
    count[ord(str1[i])] += 1
    count[ord(str2[i])] -= 1
  for i in range(256):
    if count[i] != 0:
      return False
  return True
```"
572,"Length of the longest substring without repeating characters | Java program to find the length of the longest substring without repeating characters ; This function returns true if all characters in str [ i . . j ] are distinct , otherwise returns false ; Note : Default values in visited are false ; Returns length of the longest substring with all distinct characters . ; Result ; Driver code","```java
public static int lengthOfLongestSubstring(String s) {
    int n = s.length();
    int maxLength = 0;
    for (int i = 0; i < n; i++) {
        boolean[] visited = new boolean[256];
        for (int j = i; j < n; j++) {
            if (visited[s.charAt(j)]) {
                break;
            } else {
                visited[s.charAt(j)] = true;
                maxLength = Math.max(maxLength, j - i + 1);
            }
        }
    }
    return maxLength;
}
```","```python
def longestSubstringWithoutRepeatingCharacters(str):
  n = len(str)
  visited = [False] * 256
  max_len = 0
  start = 0
  end = 0
  for i in range(n):
    if visited[ord(str[i])]:
      while start < i and str[start] != str[i]:
        visited[ord(str[start])] = False
        start += 1
      start += 1
    else:
      visited[ord(str[i])] = True
      end += 1
      max_len = max(max_len, end - start)
  return max_len
```"
573,"Given a string , find its first non | JAVA program to find first non - repeating character ; this function return the index of first non - repeating character if found , or else it returns - 1 ; initializing all elements to - 1 ; sets all repeating characters to - 2 and non - repeating characters contain the index where they occur ; If this character is not - 1 or - 2 then it means that this character occurred only once so find the min index of all characters that occur only once , that 's our first index ; if res remains Integer . MAX_VALUE , it means there are no characters that repeat only once or the string is empty","```java
public int firstNonRepeatingCharacter(String str) {
    if (str == null || str.isEmpty()) {
      return -1;
    }
    int[] charCount = new int[256];
    for (int i = 0; i < charCount.length; i++) {
      charCount[i] = -1;
    }
    for (int i = 0; i < str.length(); i++) {
      char c = str.charAt(i);
      if (charCount[c] == -1) {
        charCount[c] = i;
      } else {
        charCount[c] = -2;
      }
    }
    int res = Integer.MAX_VALUE;
    for (int i = 0; i < charCount.length; i++) {
      if (charCount[i] >= 0) {
        res = Math.min(res, charCount[i]);
      }
    }
    return res == Integer.MAX_VALUE ? -1 : res;
  }
```","```python
def firstNonRepeatingCharacter(s):
  if len(s) == 0:
    return -1
  charCount = [-1] * 256
  for i in range(len(s)):
    charCount[ord(s[i])] = charCount[ord(s[i])] + 1 if charCount[ord(s[i])] != -1 else 0
  for i in range(len(s)):
    if charCount[ord(s[i])] == 0:
      charCount[ord(s[i])] = i
    elif charCount[ord(s[i])] > 0:
      charCount[ord(s[i])] = -2
  res = float('inf')
  for i in range(len(s)):
    if charCount[ord(s[i])] != -1 and charCount[ord(s[i])] != -2:
      res = min(res, charCount[ord(s[i])])
  if res == float('inf'):
    return -1
  return res
```"
574,"Remove duplicates from a given string | Java program to create a unique string ; Function to make the string unique ; loop to traverse the string and check for repeating chars using IndexOf ( ) method in Java ; character at i 'th index of s ; if c is present in str , it returns the index of c , else it returns - 1 ; adding c to str if - 1 is returned ; Driver code ; Input string with repeating chars","```java
public static String uniqueString(String s) {
    String str = """";
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      if (str.indexOf(c) == -1) {
        str += c;
      }
    }
    return str;
  }
```","```python
def unique_string(s):
  str = """"
  for i in range(len(s)):
    c = s[i]
    if str.find(c) == -1:
      str += c
  return str
```"
575,"Sum of all subsets whose sum is a Perfect Number from a given array | Java program for the above approach ; Function to check is a given number is a perfect number or not ; Stores the sum of its divisors ; Add all divisors of x to sum_div ; If the sum of divisors is equal to the given number , return true ; Otherwise , return false ; Function to find sum of all subsets from an array whose sum is a perfect number ; Print the current subset sum if it is a perfect number ; Check if sum is a perfect number or not ; Calculate sum of the subset including arr [ l ] ; Calculate sum of the subset excluding arr [ l ] ; Driver code","```java
public static boolean isPerfectNumber(int x) {
    int sum_div = 1;
    for (int i = 2; i * i <= x; i++) {
      if (x % i == 0) {
        sum_div += i;
        if (i * i != x) {
          sum_div += x / i;
        }
      }
    }
    return sum_div == x;
  }
  public static void findSubsetSumPerfectNumbers(int[] arr, int l, int r, int sum) {
    if (l == r) {
      if (isPerfectNumber(sum)) {
        System.out.println(sum);
      }
      return;
    }
    findSubsetSumPerfectNumbers(arr, l + 1, r, sum + arr[l]);
    findSubsetSumPerfectNumbers(arr, l + 1, r, sum);
  }
  public static void main(String[] args) {
    int[] arr = {2, 6, 8, 10, 12};
    findSubsetSumPerfectNumbers(arr, 0, arr.length, 0);
  }
```","```python
def isPerfectNumber(x):
  sum_div = 1
  for i in range(2, int(x**0.5) + 1):
    if x % i == 0:
      sum_div += i + x // i
  return sum_div == x

def sumOfPerfectSubsets(arr, l, r, sum=0):
  if l > r:
    if isPerfectNumber(sum):
      print(sum)
    return
  sumOfPerfectSubsets(arr, l + 1, r, sum + arr[l])
  sumOfPerfectSubsets(arr, l + 1, r, sum)

# Driver Code
arr = [2, 4, 6, 8, 10]
n = len(arr)
sumOfPerfectSubsets(arr, 0, n - 1)
```"
576,"Print all possible ways to split an array into K subsets | Java program for above approach ; Utility function to find all possible ways to split array into K subsets ; If count of elements in K subsets are greater than or equal to N ; If count of subsets formed is equal to K ; Print K subsets by splitting array into K subsets ; Print current subset ; If current element is the last element of the subset ; Otherwise ; If any subset is occupied , then push the element in that first ; Recursively do the same for remaining elements ; Backtrack ; Otherwise , push it in an empty subset and increase the subset count by 1 ; Break to avoid the case of going in other empty subsets , if available , and forming the same combination ; Function to to find all possible ways to split array into K subsets ; Stores K subset by splitting array into K subsets ; Size of each subset must be less than the number of elements ; Driver function ; Given array ; Given K ; Size of the array ; Prints all possible splits into subsets","```java
public static void printAllPossibleSplits(int[] arr, int k) {
    int n = arr.length;
    List<List<Integer>> subsets = new ArrayList<>();
    for (int i = 0; i < k; i++) {
        subsets.add(new ArrayList<>());
    }
    printAllPossibleSplitsUtil(arr, subsets, 0, 0, n, k);
}

private static void printAllPossibleSplitsUtil(int[] arr, List<List<Integer>> subsets, int index, int subsetCount, int n, int k) {
    if (subsetCount >= k && index == n) {
        for (List<Integer> subset : subsets) {
            System.out.print(subset + "" "");
        }
        System.out.println();
        return;
    }
    if (index == n) {
        return;
    }
    for (int i = 0; i < k; i++) {
        if (subsets.get(i).size() < n / k) {
            subsets.get(i).add(arr[index]);
            if (index == n - 1 || i == k - 1) {
                printAllPossibleSplitsUtil(arr, subsets, index + 1, subsetCount + 1, n, k);
            } else {
                printAllPossibleSplitsUtil(arr, subsets, index + 1, subsetCount, n, k);
            }
            subsets.get(i).remove(subsets.get(i).size() - 1);
        } else {
            break;
        }
    }
}

public static void main(String[] args) {
    int[] arr = {1, 2, 3, 4, 5, 6};
    int k = 3;
    printAllPossibleSplits(arr, k);
}
```","```python
def split_array_into_subsets(arr, k):
  n = len(arr)
  subsets = [[] for _ in range(k)]
  subset_count = 0
  
  def backtrack(index, subset_count):
    if subset_count == k:
      if all(len(subset) >= n // k for subset in subsets):
        print(subsets)
      return
    
    if index == n:
      return
    
    for i in range(k):
      if subsets[i]:
        subsets[i].append(arr[index])
        backtrack(index + 1, subset_count)
        subsets[i].pop()
      else:
        subsets[i].append(arr[index])
        subset_count += 1
        backtrack(index + 1, subset_count)
        subsets[i].pop()
        subset_count -= 1
        break
    
  backtrack(0, 0)

arr = [1, 2, 3, 4, 5, 6, 7]
k = 3
split_array_into_subsets(arr, k)
```"
577,"Count the number of Prime Cliques in an undirected graph | Java implementation to Count the number of Prime Cliques in an undirected graph ; Stores the vertices ; Graph ; Degree of the vertices ; To store the count of prime cliques ; Function to create Sieve to check primes ; False here indicates that it is not prime ; Condition if prime [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function to check if the given set of vertices in store array is a clique or not ; Run a loop for all set of edges ; If any edge is missing ; Function to find the count of all the cliques having prime size ; Check if any vertices from i + 1 can be inserted ; Add the vertex to store ; If the graph is not a clique of size k then it cannot be a clique by adding another edge ; Increase the count of prime cliques if the size of current clique is prime ; Check if another edge can be added ; Driver code","```java
import java.util.*;
public class PrimeCliques {
    static int V;
    static ArrayList<ArrayList<Integer>> graph = new ArrayList<>();
    static int[] degree;
    static int count = 0;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        V = sc.nextInt();
        degree = new int[V];
        for (int i = 0; i < V; i++) {
            graph.add(new ArrayList<>());
        }
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                int x = sc.nextInt();
                if (x == 1) {
                    graph.get(i).add(j);
                    degree[i]++;
                    graph.get(j).add(i);
                    degree[j]++;
                }
            }
        }
        System.out.println(countPrimeCliques());
    }
    static boolean[] sieve(int n) {
        boolean[] prime = new boolean[n + 1];
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * p; i <= n; i += p) {
                    prime[i] = false;
                }
            }
        }
        return prime;
    }
    static boolean isClique(int[] store, int k) {
        for (int i = 0; i < k; i++) {
            for (int j = i + 1; j < k; j++) {
                if (!graph.get(store[i]).contains(store[j])) {
                    return false;
                }
            }
        }
        return true;
    }
    static int countPrimeCliques() {
        boolean[] prime = sieve(V);
        for (int i = 0; i < V; i++) {
            int[] store = new int[V];
            int k = 0;
            store[k++] = i;
            for (int j = i + 1; j < V; j++) {
                if (degree[j] >= k && isClique(store, k)) {
                    store[k++] = j;
                    if (isClique(store, k)) {
                        if (prime[k] && k != 1) {
                            count++;
                        }
                    }
                    for (int l = k + 1; l < V; l++) {
                        if (degree[l] >= k && isClique(store, k)) {
                            store[k++] = l;
                            if (isClique(store, k) && prime[k] && k != 1) {
                                count++;
                            }
                        }
                    }
                }
            }
        }
        return count;
    }
}
```","```python
def countPrimeCliques(graph):
  n = len(graph)
  prime = [True] * (n + 1)
  prime[0] = prime[1] = False
  for p in range(2, int(n ** 0.5) + 1):
    if prime[p]:
      for i in range(p * p, n + 1, p):
        prime[i] = False
  store = []
  count = 0
  def isClique(store):
    for i in range(len(store)):
      for j in range(i + 1, len(store)):
        if graph[store[i]][store[j]] == 0:
          return False
    return True
  def findCliques(k, i):
    nonlocal count
    if i == n:
      if isClique(store) and prime[len(store)]:
        count += 1
      return
    findCliques(k, i + 1)
    if k < n:
      store.append(i)
      if isClique(store):
        findCliques(k + 1, i + 1)
      store.pop()
  for i in range(n):
    findCliques(1, i + 1)
  return count
```"
578,"Construct a Doubly linked linked list from 2D Matrix | Java program to construct a Doubly linked linked list from 2D Matrix ; define dimension of matrix ; struct node of doubly linked list with four pointer next , prev , up , down ; function to create a new node ; function to construct the doubly linked list ; Create Node with value contain in matrix at index ( i , j ) ; Assign address of curr into the prev pointer of temp ; Assign address of curr into the up pointer of temp ; Recursive call for next pointer ; Recursive call for down pointer ; Return newly constructed node whose all four node connected at it 's appropriate position ; Function to construct the doubly linked list ; function call for construct the doubly linked list ; function for displaying doubly linked list data ; pointer to move right ; pointer to move down ; loop till node . down is not null ; loop till node . right is not null ; driver code ; initialise matrix","```java
class Node {
  int data;
  Node next;
  Node prev;
  Node up;
  Node down;

  Node(int data) {
    this.data = data;
    this.next = null;
    this.prev = null;
    this.up = null;
    this.down = null;
  }
}

class DoublyLinkedList {
  Node head;

  Node createNode(int data) {
    return new Node(data);
  }

  Node constructDoublyLinkedList(int[][] matrix, int i, int j, Node curr) {
    if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[0].length) {
      return curr;
    }
    Node temp = createNode(matrix[i][j]);
    if (curr != null) {
      temp.prev = curr;
      curr.up = temp;
    }
    temp.next = constructDoublyLinkedList(matrix, i, j + 1, temp);
    temp.down = constructDoublyLinkedList(matrix, i + 1, j, temp);
    return temp;
  }

  void constructList(int[][] matrix) {
    head = constructDoublyLinkedList(matrix, 0, 0, null);
  }

  void displayList() {
    Node node = head;
    while (node != null) {
      Node right = node;
      while (right != null) {
        System.out.print(right.data + "" "");
        right = right.next;
      }
      System.out.println();
      node = node.down;
    }
  }

  public static void main(String[] args) {
    int[][] matrix = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
    DoublyLinkedList list = new DoublyLinkedList();
    list.constructList(matrix);
    list.displayList();
  }
}
```","```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
        self.up = None
        self.down = None

def createNode(data):
    return Node(data)

def constructDoublyLinkedList(matrix, i, j, curr):
    if i < 0 or j < 0 or i >= len(matrix) or j >= len(matrix[0]):
        return None

    temp = createNode(matrix[i][j])
    temp.prev = curr

    if curr:
        curr.down = temp

    temp.up = curr

    temp.next = constructDoublyLinkedList(matrix, i, j + 1, temp)
    temp.down = constructDoublyLinkedList(matrix, i + 1, j, temp)

    return temp

def constructDoublyLinkedListFromMatrix(matrix):
    head = constructDoublyLinkedList(matrix, 0, 0, None)
    return head

def displayDoublyLinkedList(head):
    node = head
    while node:
        print(node.data, end="" "")
        node = node.next

    print()
    node = head
    while node:
        right = node
        while right.next:
            print(right.next.data, end="" "")
            right = right.next
        print()
        node = node.down

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
head = constructDoublyLinkedListFromMatrix(matrix)
displayDoublyLinkedList(head)
```"
579,"Count of exponential paths in a Binary Tree | Java program to find the count exponential paths in Binary Tree ; Structure of a Tree node ; Function to create a new node ; Function to find x ; Take log10 of n ; Log ( n ) with base i ; Raising i to the power p ; Function to check whether the given node equals to x ^ y for some y > 0 ; Take logx ( n ) with base x ; Utility function to count the exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; Function to count exponential paths ; Driver code ; Create Tree ; Retrieve the value of x ; Function call","```java
class Node {
    int data;
    Node left, right;

    Node(int data) {
        this.data = data;
        left = right = null;
    }
}

class BinaryTree {
    Node root;

    Node newNode(int data) {
        return new Node(data);
    }

    double log10(int n) {
        return Math.log10(n);
    }

    double log(int n, int i) {
        return Math.log(n) / Math.log(i);
    }

    int pow(int i, int p) {
        return (int) Math.pow(i, p);
    }

    boolean isExp(int n, int x) {
        if (n <= 0) {
            return false;
        }
        double logx = log(n, x);
        return (logx - Math.floor(logx)) == 0;
    }

    int countExpPathsUtil(Node node, int x, int count) {
        if (node == null || !isExp(node.data, x)) {
            return count;
        }
        if (node.left == null && node.right == null) {
            count++;
        }
        count = countExpPathsUtil(node.left, x, count);
        count = countExpPathsUtil(node.right, x, count);
        return count;
    }

    int countExpPaths(Node root, int x) {
        return countExpPathsUtil(root, x, 0);
    }

    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.root = tree.newNode(16);
        tree.root.left = tree.newNode(8);
        tree.root.right = tree.newNode(4);
        tree.root.left.left = tree.newNode(4);
        tree.root.left.right = tree.newNode(2);
        tree.root.right.left = tree.newNode(2);
        tree.root.right.right = tree.newNode(1);
        int x = 2;
        int count = tree.countExpPaths(tree.root, x);
        System.out.println(""Count of exponential paths: "" + count);
    }
}
```","```python
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def newNode(data):
    return Node(data)

def find_x(node):
    return node.data

def log10(n):
    return  math.log10(n)

def log(n, i):
    return math.log(n, i)

def pow(i, p):
    return i ** p

def is_power_of_x(node, x):
    if node.data == 1:
        return True
    n = node.data
    logx = log(n, x)
    return logx.is_integer()

def count_exponent_paths(root, x, count=0):
    if root is None or not is_power_of_x(root, x):
        return count
    if root.left is None and root.right is None:
        count += 1
    count = count_exponent_paths(root.left, x, count)
    count = count_exponent_paths(root.right, x, count)
    return count

def count_exponential_paths_in_tree(root, x):
    return count_exponent_paths(root, x)

if __name__ == '__main__':
    root = newNode(16)
    root.left = newNode(8)
    root.right = newNode(4)
    root.left.left = newNode(4)
    root.left.right = newNode(2)
    root.right.left = newNode(2)
    root.right.right = newNode(1)
    x = find_x(root)
    count = count_exponential_paths_in_tree(root, x)
    print(count) 
```"
580,"Number of pairs such that path between pairs has the two vertices A and B | Java program to find the number of pairs such that the path between every pair contains two given vertices ; Function to perform DFS on the given graph by fixing the a vertex ; To mark a particular vertex as visited ; Variable to store the count of the vertices which can be reached from a ; Performing the DFS by iterating over the visited array ; If the vertex is not visited and removing the vertex b ; Function to return the number of pairs such that path between any two pairs consists of the given two vertices A and B ; Initializing the visited array and assigning it with 0 's ; Initially , the count of vertices is 0 ; Performing DFS by removing the vertex B ; Count the vertices which cannot be reached after removing the vertex B ; Again reinitializing the visited array ; Setting the count of vertices to 0 to perform the DFS again ; Performing the DFS by removing the vertex A ; Count the vertices which cannot be reached after removing the vertex A ; Multiplying both the vertices set ; Driver code ; Loop to store the graph","```java
public static int countPairs(int[][] graph, int A, int B) {
    int n = graph.length;
    int[] visited = new int[n];
    int countA = 0;
    int countB = 0;

    dfs(graph, A, visited, B);
    for (int i = 0; i < n; i++) {
        if (visited[i] == 0) {
            countB++;
        }
    }

    Arrays.fill(visited, 0);

    dfs(graph, B, visited, A);
    for (int i = 0; i < n; i++) {
        if (visited[i] == 0) {
            countA++;
        }
    }

    return countA * countB;
}

private static void dfs(int[][] graph, int a, int[] visited, int b) {
    visited[a] = 1;
    for (int i = 0; i < graph[a].length; i++) {
        if (graph[a][i] == 1 && visited[i] == 0 && i != b) {
            dfs(graph, i, visited, b);
        }
    }
}
```","```python
def countPairs(graph, a, b, n):
    visited = [0] * n
    count1 = 0
    def dfs(vertex, visited, b):
        nonlocal count1
        visited[vertex] = 1
        for neighbor in graph[vertex]:
            if visited[neighbor] == 0 and neighbor != b:
                dfs(neighbor, visited, b)
        count1 += 1
    
    visited = [0] * n
    count1 = 0
    dfs(b, visited, b)
    count_not_reachable_b = n - count1

    visited = [0] * n
    count1 = 0
    dfs(a, visited, a)
    count_not_reachable_a = n - count1
    return count_not_reachable_a * count_not_reachable_b
```"
581,"Travelling Salesman Problem implementation using BackTracking | Java implementation of the approach ; Function to find the minimum weight Hamiltonian Cycle ; If last node is reached and it has a link to the starting node i . e the source then keep the minimum value out of the total cost of traversal and "" ans "" Finally return to check for more possible values ; BACKTRACKING STEP Loop to traverse the adjacency list of currPos node and increasing the count by 1 and cost by graph [ currPos , i ] value ; Mark as visited ; Mark ith node as unvisited ; Driver code ; n is the number of nodes i . e . V ; Boolean array to check if a node has been visited or not ; Mark 0 th node as visited ; Find the minimum weight Hamiltonian Cycle ; ans is the minimum weight Hamiltonian Cycle","```java
public static int tsp(int[][] graph, int currPos, int n, int count, int cost, boolean[] visited, int ans) {
    if (count == n && graph[currPos][0] > 0) {
        ans = Math.min(ans, cost + graph[currPos][0]);
        return ans;
    }
    for (int i = 0; i < n; i++) {
        if (graph[currPos][i] > 0 && !visited[i]) {
            count++;
            cost += graph[currPos][i];
            visited[i] = true;
            ans = tsp(graph, i, n, count, cost, visited, ans);
            cost -= graph[currPos][i];
            count--;
            visited[i] = false;
        }
    }
    return ans;
}
```","```python
def tsp(graph, n):
  visited = [False] * n
  visited[0] = True
  ans = float('inf')
  def backtrack(currPos, count, cost):
    nonlocal ans
    if count == n and graph[currPos][0] != 0:
      ans = min(ans, cost + graph[currPos][0])
      return
    for i in range(n):
      if not visited[i] and graph[currPos][i] != 0:
        count += 1
        cost += graph[currPos][i]
        visited[i] = True
        backtrack(i, count, cost)
        visited[i] = False
        count -= 1
        cost -= graph[currPos][i]
  backtrack(0, 1, 0)
  return ans
```"
582,"Generate all the binary strings of N bits | Java implementation of the above approach : ; Function to print the output ; Function to generate all binary strings ; First assign ""0"" at ith position and try for all other permutations for remaining positions ; And then assign ""1"" at ith position and try for all other permutations for remaining positions ; Driver Code ; Print all binary strings","```java
public static void generateAllBinaryStrings(int n) {
    generateAllBinaryStringsUtil(n, """");
}

private static void generateAllBinaryStringsUtil(int n, String current) {
    if (n == 0) {
        System.out.println(current);
        return;
    }
    generateAllBinaryStringsUtil(n - 1, current + ""0"");
    generateAllBinaryStringsUtil(n - 1, current + ""1"");
}
```","```python
def generate_binary_strings(n):
  if n == 0:
    print("""")
    return
  generate_binary_strings(n - 1)
  print(""0"" * (n - 1) + ""1"")
  generate_binary_strings(n - 1)

def print_binary_strings(n):
  print(""All binary strings of"", n, ""bits:"")
  generate_binary_strings(n)

n = int(input(""Enter the number of bits: ""))
print_binary_strings(n)
```"
583,Print all the combinations of a string in lexicographical order | Java program to find all combinations of a string in lexicographical order ; function to print string ; Method to found all combination of string it is based in tree ; return if level is equal size of string ; if occurrence of char is 0 then skip the iteration of loop ; decrease the char occurrence by 1 ; store the char in result ; print the string till level ; call the function from level + 1 ; backtracking ; declare the map for store each char with occurrence ; initialize the input array with all unique char ; initialize the count array with occurrence the unique char ; temporary char array for store the result ; store the element of input array ; store the element of count array ; size of map ( no of unique char ) ; size of original string ; call function for print string combination ; Driver code,"```java
public static void printCombinations(String str) {
    Map<Character, Integer> charCount = new HashMap<>();
    for (char c : str.toCharArray()) {
        charCount.put(c, charCount.getOrDefault(c, 0) + 1);
    }
    char[] input = charCount.keySet().toArray(new Character[0]);
    int[] count = new int[charCount.size()];
    for (int i = 0; i < input.length; i++) {
        count[i] = charCount.get(input[i]);
    }
    char[] result = new char[str.length()];
    printCombinationsUtil(input, count, result, 0, str.length());
}

private static void printCombinationsUtil(char[] input, int[] count, char[] result, int level, int size) {
    if (level == size) {
        System.out.println(String.valueOf(result));
        return;
    }
    for (int i = 0; i < input.length; i++) {
        if (count[i] == 0) {
            continue;
        }
        count[i]--;
        result[level] = input[i];
        printCombinationsUtil(input, count, result, level + 1, size);
        count[i]++;
    }
}
```","```python
def printCombinations(input_str):
  char_count = {}
  for char in input_str:
    if char in char_count:
      char_count[char] += 1
    else:
      char_count[char] = 1
  unique_chars = list(char_count.keys())
  count = list(char_count.values())
  result = [""""] * len(input_str)
  n = len(unique_chars)
  k = len(input_str)
  def _printCombinations(level):
    if level == k:
      print("""".join(result))
      return
    for i in range(n):
      if count[i] == 0:
        continue
      count[i] -= 1
      result[level] = unique_chars[i]
      _printCombinations(level + 1)
      count[i] += 1
  _printCombinations(0)

# Driver Code
input_str = ""AAB""
printCombinations(input_str)
```"
584,"Combinations where every element appears twice and distance between appearances is equal to the value | Java program to find all combinations where every element appears twice and distance between appearances is equal to the value ; Find all combinations that satisfies given constraints ; if all elements are filled , print the solution ; try all possible combinations for element elem ; if position i and ( i + elem + 1 ) are not occupied in the vector ; place elem at position i and ( i + elem + 1 ) ; recurse for next element ; backtrack ( remove elem from position i and ( i + elem + 1 ) ) ; create a vector of double the size of given number with ; all its elements initialized by 1 ; start from element 1 ; Driver method ; given number","```java
public static void findCombinations(int n, int[] vec, int elem) {
    if (elem == n + 1) {
        for (int i = 0; i < 2 * n; i++) {
            System.out.print(vec[i] + "" "");
        }
        System.out.println();
        return;
    }
    for (int i = 1; i <= 2 * n; i++) {
        if (vec[i - 1] == 1 && vec[i + elem] == 1) {
            vec[i - 1] = elem;
            vec[i + elem] = elem;
            findCombinations(n, vec, elem + 1);
            vec[i - 1] = 1;
            vec[i + elem] = 1;
        }
    }
}

public static void main(String[] args) {
    int n = 3;
    int[] vec = new int[2 * n];
    for (int i = 0; i < 2 * n; i++) {
        vec[i] = 1;
    }
    findCombinations(n, vec, 1);
}
```","```python
def find_combinations(n):
  arr = [1] * (2 * n)
  def helper(elem, i):
    if i == 2 * n:
      print(arr)
      return
    for j in range(elem, n + 1):
      if arr[i] == 1 and arr[i + j + 1] == 1:
        arr[i] = j
        arr[i + j + 1] = j
        helper(j + 1, i + 1)
        arr[i] = 1
        arr[i + j + 1] = 1
  helper(1, 0)
```"
585,"Warnsdorff 's algorithm for Knight’s tour problem | Java program to for Kinight ' s ▁ tour ▁ problem ▁ using ▁ Warnsdorff ' s algorithm ; Move pattern on basis of the change of x coordinates and y coordinates respectively ; function restricts the knight to remain within the 8 x8 chessboard ; Checks whether a square is valid and empty or not ; Returns the number of empty squares adjacent to ( x , y ) ; Picks next point using Warnsdorff 's heuristic.  Returns false if it is not possible to pick  next point. ; Try all N adjacent of ( * x , * y ) starting from a random adjacent . Find the adjacent with minimum degree . ; IF we could not find a next cell ; Store coordinates of next point ; Mark next move ; Update next point ; displays the chessboard with all the legal knight 's moves  ; If the knight ends on a square that is one knight 's move from the beginning square,  then tour is closed  ; Generates the legal moves using warnsdorff 's  heuristics. Returns false if not possible  ; Filling up the chessboard matrix with - 1 's ; initial position ; Current points are same as initial points ; Keep picking next points using Warnsdorff 's heuristic ; Check if tour is closed ( Can end at starting point ) ; Driver Code ; While we don 't get a solution ;","```java
public class KnightsTour {

    static int N = 8;
    static int[][] board = new int[N][N];

    public static boolean solveKT() {
        int xMove[] = {2, 1, -1, -2, -2, -1, 1, 2};
        int yMove[] = {1, 2, 2, 1, -1, -2, -2, -1};

        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                board[i][j] = -1;

        int x = 0, y = 0;
        board[x][y] = 0;

        int moveCount = 1;

        while (moveCount < N * N) {
            int nextX = -1, nextY = -1;
            int minDegree = Integer.MAX_VALUE;

            for (int i = 0; i < 8; i++) {
                int newX = x + xMove[i];
                int newY = y + yMove[i];

                if (isSafe(newX, newY) && countEmptyAdjacent(newX, newY) < minDegree) {
                    nextX = newX;
                    nextY = newY;
                    minDegree = countEmptyAdjacent(newX, newY);
                }
            }

            if (nextX == -1 && nextY == -1)
                return false;

            x = nextX;
            y = nextY;
            board[x][y] = moveCount;
            moveCount++;
        }

        if (isClose(x, y))
            return true;
        return false;
    }

    public static int countEmptyAdjacent(int x, int y) {
        int count = 0;
        int xMove[] = {2, 1, -1, -2, -2, -1, 1, 2};
        int yMove[] = {1, 2, 2, 1, -1, -2, -2, -1};

        for (int i = 0; i < 8; i++) {
            int newX = x + xMove[i];
            int newY = y + yMove[i];
            if (isSafe(newX, newY) && board[newX][newY] == -1)
                count++;
        }

        return count;
    }

    public static boolean isSafe(int x, int y) {
        return (x >= 0 && x < N && y >= 0 && y < N && board[x][y] == -1);
    }

    public static boolean isClose(int x, int y) {
        int xMove[] = {2, 1, -1, -2, -2, -1, 1, 2};
        int yMove[] = {1, 2, 2, 1, -1, -2, -2, -1};

        for (int i = 0; i < 8; i++) {
            int newX = x + xMove[i];
            int newY = y + yMove[i];
            if (isSafe(newX, newY) && board[newX][newY] == 0)
                return true;
        }
        return false;
    }

    public static void printBoard() {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++)
                System.out.print(board[i][j] + "" "");
            System.out.println();
        }
    }

    public static void main(String[] args) {
        while (!solveKT()) {
        }
        printBoard();
    }
}
```","```python
def knight_tour(x, y):
  def is_safe(x, y):
    return 0 <= x < 8 and 0 <= y < 8 and board[x][y] == -1

  def count_empty_adjacent(x, y):
    count = 0
    for dx in [-2, -1, 1, 2]:
      for dy in [-1, 2]:
        if abs(dx) == 2 and abs(dy) == 1 or abs(dx) == 1 and abs(dy) == 2:
          new_x, new_y = x + dx, y + dy
          if is_safe(new_x, new_y):
            count += 1
    return count

  def find_next_move(x, y):
    min_degree = 9
    next_x, next_y = -1, -1
    for dx in [-2, -1, 1, 2]:
      for dy in [-1, 2]:
        if abs(dx) == 2 and abs(dy) == 1 or abs(dx) == 1 and abs(dy) == 2:
          new_x, new_y = x + dx, y + dy
          if is_safe(new_x, new_y):
            degree = count_empty_adjacent(new_x, new_y)
            if degree < min_degree:
              min_degree = degree
              next_x, next_y = new_x, new_y
    return next_x, next_y

  board = [[-1 for _ in range(8)] for _ in range(8)]
  x_start, y_start = x, y
  x, y = x_start, y_start
  move_count = 1
  board[x][y] = move_count
  while True:
    next_x, next_y = find_next_move(x, y)
    if next_x == -1:
      return False
    x, y = next_x, next_y
    move_count += 1
    board[x][y] = move_count
    if move_count == 64 and abs(x_start - x) <= 2 and abs(y_start - y) <= 2:
      return True
```"
586,"Printing all solutions in N | Java Program for above approach ; Program to solve N - Queens Problem ; All_rows_filled is a bit mask having all N bits set ; If rowmask will have all bits set , means queen has been placed successfully in all rows and board is displayed ; We extract a bit mask ( safe ) by rowmask , ldmask and rdmask . all set bits of ' safe ' indicates the safe column index for queen placement of this iteration for row index ( row ) . ; Extracts the right - most set bit ( safe column index ) where queen can be placed for this row ; these bit masks will keep updated in each iteration for next row ; Reset right - most set bit to 0 so , next iteration will continue by placing the queen at another safe column index of this row ; Backtracking , replace ' Q ' by ' ▁ ' ; Program to print board ; Driver Code ; Board size ; Function Call","```java
public static void solveNQueens(int n) {
    int[] board = new int[n];
    int rowmask = 0;
    int ldmask = 0;
    int rdmask = 0;
    solveNQueensUtil(board, 0, rowmask, ldmask, rdmask, n);
}

private static void solveNQueensUtil(int[] board, int row, int rowmask, int ldmask, int rdmask, int n) {
    if (rowmask == (1 << n) - 1) {
        printBoard(board, n);
        return;
    }
    int safe = ((1 << n) - 1) & (~(rowmask | ldmask | rdmask));
    while (safe != 0) {
        int p = safe & -safe;
        board[row] = Integer.numberOfTrailingZeros(p) + 1;
        solveNQueensUtil(board, row + 1, rowmask | p, (ldmask | p) << 1, (rdmask | p) >> 1, n);
        safe &= (safe - 1);
    }
}

private static void printBoard(int[] board, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i] == j + 1) {
                System.out.print(""Q "");
            } else {
                System.out.print("". "");
            }
        }
        System.out.println();
    }
    System.out.println();
}
```","```python
def solveNQueens(n):
  def isSafe(row, col, ldmask, rdmask, colmask):
    return (colmask & (1 << col)) == 0 and (ldmask & (1 << (row + col))) == 0 and (rdmask & (1 << (row - col + n - 1))) == 0

  def solve(row, ldmask, rdmask, colmask, board):
    if row == n:
      for i in range(n):
        print("""".join(board[i]))
      print()
      return

    safe = ((1 << n) - 1) & (~(ldmask | rdmask | colmask))
    while safe:
      p = safe & -safe
      col = (p).bit_length() - 1
      board[row][col] = 'Q'
      solve(row + 1, (ldmask | p), (rdmask | p), (colmask | p), board)
      board[row][col] = '.'
      safe &= (safe - 1)

  board = [['.' for _ in range(n)] for _ in range(n)]
  solve(0, 0, 0, 0, board)
```"
587,"Fill two instances of all numbers from 1 to n in a specific way | A backtracking based C ++ Program to fill two instances of all numbers from 1 to n in a specific way ; A recursive utility function to fill two instances of numbers from 1 to n in res [ 0. .2 n - 1 ] . ' curr ' is current value of n . ; If current number becomes 0 , then all numbers are filled ; Try placing two instances of ' curr ' at all possible locations till solution is found ; Two ' curr ' should be placed at ' curr + 1' distance ; Plave two instances of ' curr ' ; Recur to check if the above placement leads to a solution ; If solution is not possible , then backtrack ; This function prints the result for input number ' n ' using fillUtil ( ) ; Create an array of size 2 n and initialize all elements in it as 0 ; If solution is possible , then print it . ; Driver Code","```java
public static void fillTwoInstances(int n) {
    int[] res = new int[2 * n];
    fillUtil(res, n, 0);
}

private static boolean fillUtil(int[] res, int curr, int pos) {
    if (curr == 0) {
        for (int i = 0; i < res.length; i++) {
            System.out.print(res[i] + "" "");
        }
        System.out.println();
        return true;
    }
    for (int i = pos; i <= 2 * curr - 1; i++) {
        if (i + curr <= 2 * curr - 1 && res[i] == 0 && res[i + curr] == 0) {
            res[i] = curr;
            res[i + curr] = curr;
            if (fillUtil(res, curr - 1, i + 1)) {
                return true;
            }
            res[i] = 0;
            res[i + curr] = 0;
        }
    }
    return false;
}
```","```python
def fillUtil(n, res, curr):
    if curr == 0:
        return True
    for i in range(2 * n - 1):
        if res[i] == 0 and res[i + curr + 1] == 0:
            res[i] = curr
            res[i + curr + 1] = curr
            if fillUtil(n, res, curr - 1):
                return True
            res[i] = 0
            res[i + curr + 1] = 0
    return False

def fillTwoInstances(n):
    res = [0] * (2 * n)
    if fillUtil(n, res, n):
        print(res)
```"
588,"m Coloring Problem | Backtracking | Java program for the above approach ; A node class which stores the color and the edges connected to the node ; Create a visited array of n nodes , initialized to zero ; maxColors used till now are 1 as all nodes are painted color 1 ; Do a full BFS traversal from all unvisited starting points ; If the starting point is unvisited , mark it visited and push it in queue ; BFS Travel starts here ; Checking all adjacent nodes to "" top "" edge in our queue ; IMPORTANT : If the color of the adjacent node is same , increase it by 1 ; If number of colors used shoots m , return 0 ; If the adjacent node is not visited , mark it visited and push it in queue ; Driver code ; Create a vector of n + 1 nodes of type "" node "" The zeroth position is just dummy ( 1 to n to be used ) ; Add edges to each node as per given input ; Connect the undirected graph ; Display final answer","```java
import java.util.*;

class Node {
    int color;
    List<Integer> edges;

    Node() {
        color = 1;
        edges = new ArrayList<>();
    }
}

public class ColoringProblem {

    public static int solve(int n, List<Node> graph, int m) {
        boolean[] visited = new boolean[n + 1];
        int maxColors = 1;
        for (int i = 1; i <= n; i++) {
            if (!visited[i]) {
                visited[i] = true;
                Queue<Integer> q = new LinkedList<>();
                q.offer(i);
                while (!q.isEmpty()) {
                    int top = q.poll();
                    for (int adj : graph.get(top).edges) {
                        if (graph.get(adj).color == graph.get(top).color) {
                            graph.get(adj).color++;
                            maxColors = Math.max(maxColors, graph.get(adj).color);
                            if (maxColors > m) {
                                return 0;
                            }
                        }
                        if (!visited[adj]) {
                            visited[adj] = true;
                            q.offer(adj);
                        }
                    }
                }
            }
        }
        return maxColors;
    }

    public static void main(String[] args) {
        int n = 4;
        int m = 3;
        List<Node> graph = new ArrayList<>(n + 1);
        for (int i = 0; i <= n; i++) {
            graph.add(new Node());
        }
        // Add edges based on your input
        graph.get(1).edges.add(2);
        graph.get(2).edges.add(1);
        graph.get(1).edges.add(3);
        graph.get(3).edges.add(1);
        graph.get(2).edges.add(4);
        graph.get(4).edges.add(2);

        int result = solve(n, graph, m);
        System.out.println(result); // Output: 2
    }
}
```","```python
from collections import defaultdict, deque

class Node:
    def __init__(self):
        self.color = 1
        self.edges = []

def solve_coloring_problem(n, edges, m):
    nodes = [Node() for _ in range(n + 1)]
    for u, v in edges:
        nodes[u].edges.append(v)
        nodes[v].edges.append(u)
    visited = [0] * (n + 1)
    max_colors = 1
    for i in range(1, n + 1):
        if not visited[i]:
            visited[i] = 1
            queue = deque([i])
            while queue:
                top = queue.popleft()
                for neighbor in nodes[top].edges:
                    if nodes[neighbor].color == nodes[top].color:
                        nodes[neighbor].color += 1
                        max_colors = max(max_colors, nodes[neighbor].color)
                        if max_colors > m:
                            return 0
                    if not visited[neighbor]:
                        visited[neighbor] = 1
                        queue.append(neighbor)
    return 1
```"
589,Fast Doubling method to find the Nth Fibonacci number | Java program to find the Nth Fibonacci number using Fast Doubling Method ; Function calculate the N - th fibanacci number using fast doubling method ; Base Condition ; Here a = F ( n ) ; Here b = F ( n + 1 ) ; As F ( 2 n ) = F ( n ) [ 2F ( n + 1 ) F ( n ) ] Here c = F ( 2 n ) ; As F ( 2 n + 1 ) = F ( n ) ^ 2 + F ( n + 1 ) ^ 2 Here d = F ( 2 n + 1 ) ; Check if N is odd or even ; Driver code,"```java
public static long fibonacciFastDoubling(long n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        long a = 0;
        long b = 1;
        long c;
        long d;
        while (n > 1) {
            if (n % 2 == 0) {
                c = b * (2 * a + b);
                d = a * a + b * b;
                n /= 2;
            } else {
                c = a * a + b * b;
                d = b * (2 * a + b);
                n = (n - 1) / 2;
            }
            a = c;
            b = d;
        }
        return b;
    }
}
```","```python
def fibonacci_fast_doubling(n):
  if n <= 1:
    return n
  a = 0
  b = 1
  while n > 1:
    if n % 2 == 0:
      c = b * (2 * a + b)
      d = a**2 + b**2
      n //= 2
    else:
      c = a**2 + b**2
      d = b * (2 * a + b)
      n -= 1
    a = c
    b = d
  return a
```"
590,Frequency of an integer in the given array using Divide and Conquer | Java implrmrntation of the approach ; Function to return the frequency of x in the subarray arr [ low ... high ] ; If the subarray is invalid or the element is not found ; If there 's only a single element  which is equal to x ; Divide the array into two parts and then find the count of occurrences of x in both the parts ; Driver code,"```java
public static int countOccurrences(int[] arr, int low, int high, int x) {
    if (low > high) {
        return 0;
    }
    if (low == high) {
        return arr[low] == x ? 1 : 0;
    }
    int mid = low + (high - low) / 2;
    return countOccurrences(arr, low, mid, x) + countOccurrences(arr, mid + 1, high, x);
}
```","```python
def frequency_of_x(arr, low, high, x):
  if low > high:
    return 0
  if low == high:
    if arr[low] == x:
      return 1
    else:
      return 0
  mid = (low + high) // 2
  return frequency_of_x(arr, low, mid, x) + frequency_of_x(arr, mid + 1, high, x)
```"
591,"Median of an unsorted array using Quick Select Algorithm | JAVA program to find median of an array ; Utility function to swapping of element ; Returns the correct position of pivot element ; Picks a random pivot element between l and r and partitions arr [ l . . r ] around the randomly picked element using partition ( ) ; Utility function to find median ; if l < r ; Find the partition index ; If partition index = k , then we found the median of odd number element in arr [ ] ; If index = k - 1 , then we get a & b as middle element of arr [ ] ; If partitionIndex >= k then find the index in first half of the arr [ ] ; If partitionIndex <= k then find the index in second half of the arr [ ] ; Function to find Median ; If n is odd ; If n is even ; Print the Median of arr [ ] ; Driver code","```java
public static int partition(int[] arr, int l, int r) {
    int pivot = arr[r];
    int i = l - 1;
    for (int j = l; j <= r - 1; j++) {
      if (arr[j] <= pivot) {
        i++;
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[r];
    arr[r] = temp;
    return i + 1;
  }
  
  public static int findMedianUtil(int[] arr, int l, int r, int k) {
    if (l == r) {
      return arr[l];
    }
    int partitionIndex = partition(arr, l, r);
    if (partitionIndex == k) {
      return arr[partitionIndex];
    }
    if (partitionIndex > k) {
      return findMedianUtil(arr, l, partitionIndex - 1, k);
    }
    return findMedianUtil(arr, partitionIndex + 1, r, k - partitionIndex - 1);
  }
  
  public static double findMedian(int[] arr, int n) {
    if (n % 2 != 0) {
      return findMedianUtil(arr, 0, n - 1, n / 2);
    } else {
      return (findMedianUtil(arr, 0, n - 1, n / 2 - 1) + findMedianUtil(arr, 0, n - 1, n / 2)) / 2.0;
    }
  }
  
  public static void main(String[] args) {
    int[] arr = {12, 3, 5, 7, 4, 19, 26};
    int n = arr.length;
    System.out.println(""Median of the array is: "" + findMedian(arr, n));
  }
```","```python
import random

def swap(arr, i, j):
  arr[i], arr[j] = arr[j], arr[i]

def partition(arr, l, r):
  pivot = random.randint(l, r)
  swap(arr, pivot, r)
  pivot = r
  i = l - 1
  for j in range(l, r):
    if arr[j] <= arr[pivot]:
      i += 1
      swap(arr, i, j)
  swap(arr, i + 1, pivot)
  return i + 1

def findMedian(arr, n, k):
  l = 0
  r = n - 1
  while l < r:
    partitionIndex = partition(arr, l, r)
    if partitionIndex == k:
      return arr[k]
    elif partitionIndex == k - 1:
      return (arr[k - 1] + arr[k]) / 2
    elif partitionIndex >= k:
      r = partitionIndex - 1
    else:
      l = partitionIndex + 1
  return arr[k]

def findMedianOfArray(arr):
  n = len(arr)
  if n % 2 == 1:
    return findMedian(arr, n, n // 2)
  else:
    return findMedian(arr, n, n // 2 - 1)

arr = [1, 3, 5, 7, 9]
median = findMedianOfArray(arr)
print(""Median of the array is:"", median)
```"
592,Largest number N which can be reduced to 0 in K steps | Java program to implement above approach ; Utility function to return the first digit of a number . ; Remove last digit from number till only one digit is left ; return the first digit ; Utility function that returns the count of numbers written down when starting from n ; Function to find the largest number N which can be reduced to 0 in K steps ; Get the sequence length of the mid point ; Until k sequence length is reached ; Update mid point ; Get count of the new mid point ; Update right to mid ; Update left to mid ; Increment mid point by one while count is equal to k to get the maximum value of mid point ; Driver Code,"```java
static int firstDigit(int n) {
    while (n >= 10) {
      n /= 10;
    }
    return n;
  }
  
  static int countNumbers(int n) {
    int count = 1;
    while (n > 9) {
      n = firstDigit(n);
      count++;
    }
    return count;
  }
  
  static int largestNumber(int k) {
    int left = 1, right = 1000000000;
    int mid = (left + right) / 2;
    int count = countNumbers(mid);
  
    while (count != k) {
      if (count < k) {
        left = mid;
      } else {
        right = mid;
      }
      mid = (left + right) / 2;
      count = countNumbers(mid);
    }
    while (countNumbers(mid + 1) == k) {
      mid++;
    }
    return mid;
  }
  
  public static void main(String[] args) {
    int k = 5;
    System.out.println(largestNumber(k));
  }
```","```python
def firstDigit(n):
  while n >= 10:
    n //= 10
  return n

def countNumbers(n):
  count = 0
  while n != 0:
    count += 1
    n = firstDigit(n)
  return count

def findLargestNumber(k):
  left = 1
  right = 10**9
  while left <= right:
    mid = (left + right) // 2
    sequenceLength = countNumbers(mid)
    while sequenceLength == k:
      mid += 1
      sequenceLength = countNumbers(mid)
    if sequenceLength < k:
      left = mid + 1
    else:
      right = mid - 1
  return right

# Driver Code
k = 5
print(findLargestNumber(k))
```"
593,"Check if point ( X , Y ) can be reached from origin ( 0 , 0 ) with jump of 1 and N perpendicularly simultaneously | Java code for the above approach ; Function to check if ( X , Y ) is reachable from ( 0 , 0 ) using the jumps of given type ; Case where source & destination are the same ; Check for even N ( X , Y ) is reachable or not ; If N is odd and parity of X and Y is different return , no valid sequence of jumps exist ; Driver Code","```java
public static boolean isReachable(int X, int Y, int N) {
    if (X == 0 && Y == 0) {
        return true;
    }
    if (N % 2 == 0) {
        return true;
    }
    if ((X + Y) % 2 != 0) {
        return false;
    }
    return true;
}
```","```python
def isReachable(X, Y, N):
  if X == 0 and Y == 0:
    return True
  if N % 2 == 0:
    return True
  if (X + Y) % 2 != 0:
    return False
  return True
```"
594,"Find three vertices in an N | Java program for the above approach ; Function to find three vertices that subtends an angle closest to A ; Stores the closest angle to A ; Stores the count of edge which subtend an angle of A ; Iterate in the range [ 1 , N - 2 ] ; Stores the angle subtended ; If absolute ( angle - A ) is less than absolute ( mi - A ) ; Update angle to mi , and also update i to ans ; Print the vertices ; Driver Code","```java
public static void findThreeVertices(int[][] graph, int N, double A) {
    double mi = Double.MAX_VALUE;
    int ans = 0;
    int count = 0;
    for (int i = 1; i <= N - 2; i++) {
      double angle = Math.toDegrees(Math.acos((graph[i - 1][i] * graph[i][i + 1] + graph[i - 1][i + 1] * graph[i][i + 1] - graph[i - 1][i + 1] * graph[i - 1][i + 1]) / (2 * graph[i - 1][i] * graph[i][i + 1])));
      if (Math.abs(angle - A) < Math.abs(mi - A)) {
        mi = angle;
        ans = i;
      }
      if (Math.abs(angle - A) < 1e-6) {
        count++;
      }
    }
    System.out.println(""Vertices: "" + (ans - 1) + "" "" + ans + "" "" + (ans + 1));
    System.out.println(""Closest angle to "" + A + "": "" + mi);
    System.out.println(""Count of angles equal to "" + A + "": "" + count);
  }
```","```python
def find_closest_angle(N, A, edges):
  mi = float('inf')
  ans = -1
  count = 0
  for i in range(1, N - 2):
    angle = edges[i - 1][1] + edges[i][1] + edges[i + 1][1]
    if abs(angle - A) < abs(mi - A):
      mi = angle
      ans = i
    if abs(angle - A) == 0:
      count += 1
  print(ans - 1, ans, ans + 1)
  print(mi)
  print(count)
```"
595,Area of a triangle with two vertices at midpoints of opposite sides of a square and the other vertex lying on vertex of a square | Java program for the above approach ; Function to find the area of the triangle that inscribed in square ; Stores the length of the first side of triangle ; Stores the length of the second side of triangle ; Stores the length of the third side of triangle ; Stores the area of the triangle ; Return the resultant area ; Driver code,"```java
public static double triangleArea(double side) {
    double side1 = side / 2;
    double side2 = side / 2;
    double side3 = Math.sqrt(side1 * side1 + side2 * side2);
    double area = 0.5 * side1 * side2;
    return area;
}
```","```python
def triangle_area(side1, side2, side3):
  s = (side1 + side2 + side3) / 2
  area = (s * (s - side1) * (s - side2) * (s - side3)) ** 0.5
  return area
```"
596,Equation of a straight line with perpendicular distance D from origin and an angle A between the perpendicular from origin and x | Java program for the approach ; Function to find equation of a line whose distance from origin and angle made by the perpendicular from origin with x - axis is given ; Convert angle from degree to radian ; Handle the special case ; Calculate the sin and cos of angle ; Print the equation of the line ; Driver Code ; Given Input ; Function Call,"```java
public static void findEquation(double D, double A) {
    double rad = Math.toRadians(A);
    if (A == 0) {
      System.out.println(""x = "" + D);
      return;
    }
    if (A == 90) {
      System.out.println(""y = "" + D);
      return;
    }
    double sinA = Math.sin(rad);
    double cosA = Math.cos(rad);
    System.out.println(""y = "" + (sinA / cosA) + ""x + "" + D * sinA);
  }
```","```python
import math

def find_line_equation(D, A):
  A = math.radians(A)
  if A == 0 or A == math.pi:
    return f""x = {D}""
  elif A == math.pi / 2 or A == 3 * math.pi / 2:
    return f""y = {D}""
  else:
    m = math.tan(A)
    c = D / math.sin(A)
    return f""y = {m:.2f}x + {c:.2f}""
```"
597,"Count number of coordinates from an array satisfying the given conditions | Java program for the above approach ; Function to count the number of coordinates from a given set that satisfies the given conditions ; Stores the count of central points ; Store the count of each x and y coordinates ; Find all possible pairs ; Initialize variables c1 , c2 , c3 , c4 to define the status of conditions ; Stores value of each point ; Check the conditions for each point by generating all possible pairs ; If arr [ j ] [ 0 ] > x and arr [ j ] [ 1 ] == y ; If arr [ j ] [ 0 ] < x and arr [ j ] [ 1 ] = = y ; If arr [ j ] [ 1 ] > y and arr [ j ] [ 0 ] == x ; If arr [ j ] [ 1 ] < y and arr [ j ] [ 0 ] = = x ; If all conditions satisfy then point is central point ; Increment the count by 1 ; Return the count ; Driver Code","```java
public static int countCentralPoints(int[][] arr, int x, int y) {
    int c1 = 0, c2 = 0, c3 = 0, c4 = 0;
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < arr.length; j++) {
        if (arr[j][0] > x && arr[j][1] == y) {
          c1++;
        }
        if (arr[j][0] < x && arr[j][1] == y) {
          c2++;
        }
        if (arr[j][1] > y && arr[j][0] == x) {
          c3++;
        }
        if (arr[j][1] < y && arr[j][0] == x) {
          c4++;
        }
        if (c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0) {
          count++;
        }
      }
    }
    return count;
  }
```","```python
def count_central_points(arr, x, y):
  c1 = 0
  c2 = 0
  c3 = 0
  c4 = 0
  count = 0
  for j in range(len(arr)):
    if arr[j][0] > x and arr[j][1] == y:
      c1 = 1
    if arr[j][0] < x and arr[j][1] == y:
      c2 = 1
    if arr[j][1] > y and arr[j][0] == x:
      c3 = 1
    if arr[j][1] < y and arr[j][0] == x:
      c4 = 1
    if c1 == 1 and c2 == 1 and c3 == 1 and c4 == 1:
      count += 1
  return count
```"
598,"Displacement from origin after N moves of given distances in specified directions | Java program for the above approach ; Function to find the displacement from the origin and direction after performing the given set of moves ; Stores the distances travelled in the directions North , South , East , and West respectively ; Store the initial position of robot ; Traverse the array B [ ] ; If the current direction is North ; If the current direction is South ; If the current direction is East ; If the current direction is West ; Stores the total vertical displacement ; Stores the total horizontal displacement ; Find the displacement ; Print the displacement and direction after N moves ; Driver Code","```java
public static void displacement(int[] B, int N) {
    int north = 0, south = 0, east = 0, west = 0;
    int x = 0, y = 0;
    for (int i = 0; i < N; i++) {
      if (B[i] == 1) {
        north += B[i + 1];
      } else if (B[i] == 2) {
        south += B[i + 1];
      } else if (B[i] == 3) {
        east += B[i + 1];
      } else if (B[i] == 4) {
        west += B[i + 1];
      }
      i++;
    }
    y = north - south;
    x = east - west;
    double displacement = Math.sqrt(x * x + y * y);
    if (x == 0 && y > 0) {
      System.out.println(""Displacement: "" + displacement + "" Direction: North"");
    } else if (x == 0 && y < 0) {
      System.out.println(""Displacement: "" + displacement + "" Direction: South"");
    } else if (y == 0 && x > 0) {
      System.out.println(""Displacement: "" + displacement + "" Direction: East"");
    } else if (y == 0 && x < 0) {
      System.out.println(""Displacement: "" + displacement + "" Direction: West"");
    } else if (x > 0 && y > 0) {
      System.out.println(""Displacement: "" + displacement + "" Direction: North-East"");
    } else if (x > 0 && y < 0) {
      System.out.println(""Displacement: "" + displacement + "" Direction: South-East"");
    } else if (x < 0 && y > 0) {
      System.out.println(""Displacement: "" + displacement + "" Direction: North-West"");
    } else if (x < 0 && y < 0) {
      System.out.println(""Displacement: "" + displacement + "" Direction: South-West"");
    }
  }
```","```python
def find_displacement(B, N):
  north = 0
  south = 0
  east = 0
  west = 0
  x = 0
  y = 0
  for i in range(N):
    if B[i] == 'N':
      north += 1
    elif B[i] == 'S':
      south += 1
    elif B[i] == 'E':
      east += 1
    elif B[i] == 'W':
      west += 1
  y = north - south
  x = east - west
  displacement = (x**2 + y**2)**0.5
  if x == 0 and y > 0:
    direction = 'North'
  elif x == 0 and y < 0:
    direction = 'South'
  elif x > 0 and y == 0:
    direction = 'East'
  elif x < 0 and y == 0:
    direction = 'West'
  elif x > 0 and y > 0:
    direction = 'North-East'
  elif x > 0 and y < 0:
    direction = 'South-East'
  elif x < 0 and y > 0:
    direction = 'North-West'
  elif x < 0 and y < 0:
    direction = 'South-West'
  print(displacement, direction)
```"
599,Program to find Length of Latus Rectum of an Ellipse | Java program for the above approach ; Function to calculate the length of the latus rectum of an ellipse ; Length of major axis ; Length of minor axis ; Length of the latus rectum ; Driver code ; Given lengths of semi - major and semi - minor axis ; Function call to calculate length of the latus rectum of a ellipse,"```java
public static double latusRectum(double a, double b) {
    return 2 * b * b / a;
}
```","```python
def latus_rectum(a, b):
  return 2 * (b**2) / a
```"
600,Program to find slant height of cone and pyramid | Java program for the above approach ; Function to calculate slant height of a cone ; Store the slant height of cone ; Print the result ; Function to find the slant height of a pyramid ; Store the slant height of pyramid ; Print the result ; Driver Code ; Dimensions of Cone ; Function Call for slant height of Cone ; Dimensions of Pyramid ; Function to calculate slant height of a pyramid,"```java
import java.lang.Math;

public class SlantHeight {

    public static double coneSlantHeight(double radius, double height) {
        return Math.sqrt(radius * radius + height * height);
    }

    public static double pyramidSlantHeight(double baseLength, double height) {
        return Math.sqrt((baseLength / 2) * (baseLength / 2) + height * height);
    }

    public static void main(String[] args) {
        double coneRadius = 5;
        double coneHeight = 12;
        double coneSlant = coneSlantHeight(coneRadius, coneHeight);
        System.out.println(""Slant height of cone: "" + coneSlant);

        double pyramidBaseLength = 4;
        double pyramidHeight = 6;
        double pyramidSlant = pyramidSlantHeight(pyramidBaseLength, pyramidHeight);
        System.out.println(""Slant height of pyramid: "" + pyramidSlant);
    }
}
```","```python
import math

def slant_height_cone(radius, height):
  return math.sqrt(radius**2 + height**2)

def slant_height_pyramid(base_length, height):
  return math.sqrt((base_length/2)**2 + height**2)

# Dimensions of Cone
cone_radius = 5
cone_height = 12

# Function Call for slant height of Cone
cone_slant_height = slant_height_cone(cone_radius, cone_height)
print(""Slant height of cone:"", cone_slant_height)

# Dimensions of Pyramid
pyramid_base_length = 8
pyramid_height = 6

# Function Call for slant height of Pyramid
pyramid_slant_height = slant_height_pyramid(pyramid_base_length, pyramid_height)
print(""Slant height of pyramid:"", pyramid_slant_height)
```"
601,"Program to find the length of Latus Rectum of a Parabola | Java program for the above approach ; Function to calculate distance between two points ; Calculating distance ; Function to calculate length of the latus rectum of a parabola ; Stores the co - ordinates of the vertex of the parabola ; Stores the co - ordinates of the focus of parabola ; Print the distance between focus and vertex ; Driver Code ; Given a , b & c ; Function call","```java
public static double calculateDistance(double x1, double y1, double x2, double y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }
  
  public static double latusRectumLength(double a, double b, double c) {
    double vertexX = -b / (2 * a);
    double vertexY = (4 * a * c - b * b) / (4 * a);
    double focusX = vertexX;
    double focusY = vertexY + 1 / (4 * a);
    return 2 * calculateDistance(focusX, focusY, vertexX, vertexY);
  }
  
  public static void main(String[] args) {
    double a = 2, b = 4, c = 3;
    System.out.println(latusRectumLength(a, b, c));
  }
```","```python
import math

def distance(x1, y1, x2, y2):
  return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

def latus_rectum_length(a, b, c):
  vertex_x = -b / (2 * a)
  vertex_y = (a * vertex_x**2) + (b * vertex_x) + c
  focus_x = vertex_x
  focus_y = vertex_y + 1 / (4 * a)
  return 2 * distance(focus_x, focus_y, vertex_x, vertex_y)

a =  # Given a
b =  # Given b
c =  # Given c
print(latus_rectum_length(a, b, c))
```"
602,"Program to convert polar co | Java code of above approach ; Function to convert degree to radian ; Function to convert the polar coordinate to cartesian ; Convert degerees to radian ; Applying the formula : x = rcos ( theata ) , y = rsin ( theta ) ; Print cartesian coordinates ; Driver code ; Given polar coordinates ; Function to convert polar coordinates to equivalent cartesian coordinates","```java
public static void polarToCartesian(double r, double theta) {
    double x = r * Math.cos(Math.toRadians(theta));
    double y = r * Math.sin(Math.toRadians(theta));
    System.out.println(""Cartesian coordinates: ("" + x + "", "" + y + "")"");
}
```","```python
import math

def polar_to_cartesian(r, theta_deg):
  theta_rad = math.radians(theta_deg)
  x = r * math.cos(theta_rad)
  y = r * math.sin(theta_rad)
  return (x, y)
```"
603,"Distance between orthocenter and circumcenter of a right | Java program for the above approach ; Function to calculate Euclidean distance between the points p1 and p2 ; Stores x coordinates of both points ; Stores y coordinates of both points ; Return the Euclid distance using distance formula ; Function to find orthocenter of the right angled triangle ; Find the length of the three sides ; Orthocenter will be the vertex opposite to the largest side ; Function to find the circumcenter of right angle triangle ; Circumcenter will be located at center of hypotenuse ; If AB is the hypotenuse ; If BC is the hypotenuse ; If AC is the hypotenuse ; Function to find distance between orthocenter and circumcenter ; Find circumcenter ; Find orthocenter ; Find the distance between the orthocenter and circumcenter ; Print distance between orthocenter and circumcenter ; Driver Code ; Given coordinates A , B , and C ; Function Call","```java
import java.lang.Math;

class Solution {
    public static double distance(double x1, double y1, double x2, double y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    public static double[] findOrthocenter(double Ax, double Ay, double Bx, double By, double Cx, double Cy) {
        double AB = distance(Ax, Ay, Bx, By);
        double BC = distance(Bx, By, Cx, Cy);
        double AC = distance(Ax, Ay, Cx, Cy);
        if (AB > BC && AB > AC) {
            return new double[]{Cx, Cy};
        } else if (BC > AB && BC > AC) {
            return new double[]{Ax, Ay};
        } else {
            return new double[]{Bx, By};
        }
    }

    public static double[] findCircumcenter(double Ax, double Ay, double Bx, double By, double Cx, double Cy) {
        double AB = distance(Ax, Ay, Bx, By);
        double BC = distance(Bx, By, Cx, Cy);
        double AC = distance(Ax, Ay, Cx, Cy);
        if (AB > BC && AB > AC) {
            return new double[]{(Bx + Cx) / 2, (By + Cy) / 2};
        } else if (BC > AB && BC > AC) {
            return new double[]{(Ax + Cx) / 2, (Ay + Cy) / 2};
        } else {
            return new double[]{(Ax + Bx) / 2, (Ay + By) / 2};
        }
    }

    public static void main(String[] args) {
        double Ax = 0, Ay = 0, Bx = 3, By = 0, Cx = 0, Cy = 4;
        double[] circumcenter = findCircumcenter(Ax, Ay, Bx, By, Cx, Cy);
        double[] orthocenter = findOrthocenter(Ax, Ay, Bx, By, Cx, Cy);
        System.out.println(distance(circumcenter[0], circumcenter[1], orthocenter[0], orthocenter[1]));
    }
}
```","```python
import math

def euclidean_distance(p1, p2):
  x1, y1 = p1
  x2, y2 = p2
  return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

def find_orthocenter(A, B, C):
  AB = euclidean_distance(A, B)
  BC = euclidean_distance(B, C)
  AC = euclidean_distance(A, C)
  if AB > BC and AB > AC:
    return C
  elif BC > AB and BC > AC:
    return A
  else:
    return B

def find_circumcenter(A, B, C):
  if euclidean_distance(A, B) > euclidean_distance(B, C) and euclidean_distance(A, B) > euclidean_distance(A, C):
    return ((A[0] + B[0]) / 2, (A[1] + B[1]) / 2)
  elif euclidean_distance(B, C) > euclidean_distance(A, B) and euclidean_distance(B, C) > euclidean_distance(A, C):
    return ((B[0] + C[0]) / 2, (B[1] + C[1]) / 2)
  else:
    return ((A[0] + C[0]) / 2, (A[1] + C[1]) / 2)

def distance_between_orthocenter_and_circumcenter(A, B, C):
  circumcenter = find_circumcenter(A, B, C)
  orthocenter = find_orthocenter(A, B, C)
  return euclidean_distance(circumcenter, orthocenter)

A = (0, 0)
B = (3, 0)
C = (0, 4)
distance = distance_between_orthocenter_and_circumcenter(A, B, C)
print(distance)
```"
604,Count triangles required to form a House of Cards of height N | Java implementation of the above approach ; Function to find number of triangles ; Driver Code ; Function call,"```java
public static int countTriangles(int N) {
    return N * (N + 1) / 2;
}

public static void main(String[] args) {
    int N = 5;
    System.out.println(countTriangles(N));
}
```","```python
def count_triangles(N):
  return N * (N + 1) // 2
```"
605,Check if N contains all digits as K in base B | Java implementation of above approach ; Function to print the number of digits ; Calculate log using base change property and then take its floor and then add 1 ; Return the output ; Function that returns true if n contains all one 's in base b ; Calculate the sum ; Driver code ; Given number N ; Given base B ; Given digit K ; Function call,"```java
public static boolean checkAllDigits(int N, int B, int K) {
    int count = countDigits(N, B);
    return count == K;
}

public static int countDigits(int N, int B) {
    return (int) Math.floor(Math.log(N) / Math.log(B)) + 1;
}

public static boolean containsAllDigits(int n, int b, int k) {
    int sum = 0;
    while (n > 0) {
        sum += n % b;
        n /= b;
    }
    return sum == k;
}

public static void main(String[] args) {
    int N = 12345;
    int B = 10;
    int K = 5;
    System.out.println(containsAllDigits(N, B, K));
}
```","```python
def check_digits(N, B, K):
  def count_digits(n, b):
    return int(math.log(n, b)) + 1
  def all_ones(n, b):
    sum = 0
    while n:
      sum += n % b
      n //= b
    return sum == count_digits(n, b) * K
  return all_ones(N, B)
```"
606,Check if a right | Java program for the above approach ; Function to check if right - angled triangle can be formed by the given coordinates ; Calculate the sides ; Check Pythagoras Formula ; Driver Code,"```java
public static boolean isRightAngledTriangle(int[] x, int[] y) {
    double a = Math.sqrt(Math.pow(x[1] - x[0], 2) + Math.pow(y[1] - y[0], 2));
    double b = Math.sqrt(Math.pow(x[2] - x[1], 2) + Math.pow(y[2] - y[1], 2));
    double c = Math.sqrt(Math.pow(x[2] - x[0], 2) + Math.pow(y[2] - y[0], 2));
    return (Math.abs(a * a + b * b - c * c) < 0.0001 || Math.abs(a * a + c * c - b * b) < 0.0001 || Math.abs(b * b + c * c - a * a) < 0.0001);
}
```","```python
def is_right_angled_triangle(x1, y1, x2, y2, x3, y3):
  a = ((x2 - x1)**2 + (y2 - y1)**2)**0.5
  b = ((x3 - x2)**2 + (y3 - y2)**2)**0.5
  c = ((x1 - x3)**2 + (y1 - y3)**2)**0.5
  return abs(a**2 + b**2 - c**2) < 1e-6 or abs(a**2 + c**2 - b**2) < 1e-6 or abs(b**2 + c**2 - a**2) < 1e-6
```"
607,"Count of intersections of M line segments with N vertical lines in XY plane | Java implementation for the above approach . ; Function to create prefix sum array ; Initialize the prefix array to remove garbage values ; Marking the occurences of vertical lines ; x is the value after Index mapping ; Creating the prefix array ; Function returns the count of total intersection ; ans is the number of points of intersection of the line segments with the vertical lines ; Index mapping ; We don 't consider a vertical  line segment because even if  it falls on a verticale line  then it just touches it and  not intersects. ; We have assumed that x1 will be left and x2 right but if not then we just swap them ; Driver code ; N is the number of vertical lines M is the number of line segments ; Format : x1 , y1 , x2 , y1 ; First create the prefix array ; Print the total number of intersections","```java
import java.util.*;
public class LineSegmentIntersection {
    static int[] createPrefixSumArray(int n) {
        int[] prefix = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            prefix[i] = 0;
        }
        return prefix;
    }
    static int countIntersections(int[][] lineSegments, int[] verticalLines, int n, int m) {
        int[] prefix = createPrefixSumArray(n);
        for (int i = 0; i < m; i++) {
            int x1 = lineSegments[i][0];
            int x2 = lineSegments[i][2];
            if (x1 > x2) {
                int temp = x1;
                x1 = x2;
                x2 = temp;
            }
            prefix[x1]++;
            prefix[x2 + 1]--;
        }
        for (int i = 1; i <= n; i++) {
            prefix[i] += prefix[i - 1];
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += prefix[verticalLines[i]];
        }
        return ans;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] lineSegments = new int[m][4];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < 4; j++) {
                lineSegments[i][j] = sc.nextInt();
            }
        }
        int[] verticalLines = new int[n];
        for (int i = 0; i < n; i++) {
            verticalLines[i] = sc.nextInt();
        }
        System.out.println(countIntersections(lineSegments, verticalLines, n, m));
    }
}
```","```python
def count_intersections(n, m, lines):
  prefix = [0] * (n + 1)
  for x1, y1, x2, y2 in lines:
    if x1 > x2:
      x1, x2 = x2, x1
    prefix[x1] += 1
    prefix[x2 + 1] -= 1
  for i in range(1, n + 1):
    prefix[i] += prefix[i - 1]
  ans = 0
  for i in range(n):
    ans += prefix[i]
  return ans
```"
608,Count of rectangles possible from N and M straight lines parallel to X and Y axis respectively | Java Program to count number of rectangles formed by N lines parallel to X axis M lines parallel to Y axis ; Function to calculate number of rectangles ; Total number of ways to select two lines parallel to X axis ; Total number of ways to select two lines parallel to Y axis ; Total number of rectangles ; Driver Program,"```java
public static int countRectangles(int N, int M) {
    return (N - 1) * (N - 2) / 2 * (M - 1) * (M - 2) / 2;
}
```","```python
def countRectangles(n, m):
  return (n * (n - 1) // 2) * (m * (m - 1) // 2)
```"
609,Angle between a Pair of Lines in 3D | Java program for the above approach ; Function to find the angle between the two lines ; Find direction ratio of line AB ; Find direction ratio of line BC ; Find the dotProduct of lines AB & BC ; Find magnitude of line AB and BC ; Find the cosine of the angle formed by line AB and BC ; Find angle in radian ; Print the angle ; Driver code ; Given coordinates Points A ; Points B ; Points C ; Function Call,"```java
public static double angleBetweenLines(double[] A, double[] B, double[] C) {
    double[] AB = {B[0] - A[0], B[1] - A[1], B[2] - A[2]};
    double[] BC = {C[0] - B[0], C[1] - B[1], C[2] - B[2]};
    double dotProduct = AB[0] * BC[0] + AB[1] * BC[1] + AB[2] * BC[2];
    double magAB = Math.sqrt(AB[0] * AB[0] + AB[1] * AB[1] + AB[2] * AB[2]);
    double magBC = Math.sqrt(BC[0] * BC[0] + BC[1] * BC[1] + BC[2] * BC[2]);
    double cosAngle = dotProduct / (magAB * magBC);
    double angleRad = Math.acos(cosAngle);
    return Math.toDegrees(angleRad);
}
```","```python
import math

def angle_between_lines(A, B, C):
  AB = [B[i] - A[i] for i in range(3)]
  BC = [C[i] - B[i] for i in range(3)]
  dot_product = sum([AB[i] * BC[i] for i in range(3)])
  magnitude_AB = math.sqrt(sum([AB[i]**2 for i in range(3)]))
  magnitude_BC = math.sqrt(sum([BC[i]**2 for i in range(3)]))
  cosine_angle = dot_product / (magnitude_AB * magnitude_BC)
  angle_radian = math.acos(cosine_angle)
  return angle_radian
```"
610,Distance between end points of Hour and minute hand at given time | Java implementation to find the distance between the end points of the hour and minute hand ; Function to find the angle between Hour hand and minute hand ; Validate the input ; Calculate the angles moved by hour and minute hands with reference to 12 : 00 ; Find the difference between two angles ; Return the smaller angle of two possible angles ; Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to distance between the endpoints of the hour and minute hand ; Driver code ; Time ; Length of hour hand ; Length of minute hand ; Calling Function for finding angle between hour hand and minute hand ; Function for finding distance between end points of minute hand and hour hand,"```java
import java.lang.Math;

class Solution {
    public static double angleBetweenHourAndMinuteHand(int hour, int minute) {
        if (hour < 0 || hour > 12 || minute < 0 || minute > 59) {
            return -1;
        }
        double hourAngle = (hour * 60 + minute) * 0.5;
        double minuteAngle = minute * 6;
        double angleDifference = Math.abs(hourAngle - minuteAngle);
        return Math.min(angleDifference, 360 - angleDifference);
    }

    public static double cos(double angle) {
        return Math.cos(Math.toRadians(angle));
    }

    public static double distanceBetweenHourAndMinuteHand(int hour, int minute, double hourHandLength, double minuteHandLength) {
        double angle = angleBetweenHourAndMinuteHand(hour, minute);
        return Math.sqrt(hourHandLength * hourHandLength + minuteHandLength * minuteHandLength - 2 * hourHandLength * minuteHandLength * cos(angle));
    }

    public static void main(String[] args) {
        int hour = 9;
        int minute = 30;
        double hourHandLength = 5;
        double minuteHandLength = 7;
        System.out.println(distanceBetweenHourAndMinuteHand(hour, minute, hourHandLength, minuteHandLength));
    }
}
```","```python
import math

def angle_between_hands(hour, minute):
  if hour < 0 or hour > 12 or minute < 0 or minute > 60:
    return -1
  hour_angle = (hour * 60 + minute) / 2
  minute_angle = minute * 6
  angle_diff = abs(hour_angle - minute_angle)
  return min(angle_diff, 360 - angle_diff)

def cos_angle(angle):
  return math.cos(math.radians(angle))

def distance_between_hands(hour, minute, hour_hand_length, minute_hand_length):
  angle = angle_between_hands(hour, minute)
  return math.sqrt(hour_hand_length**2 + minute_hand_length**2 - 2 * hour_hand_length * minute_hand_length * cos_angle(angle))

time = [12, 0]
hour_hand_length = 5
minute_hand_length = 7
distance = distance_between_hands(time[0], time[1], hour_hand_length, minute_hand_length)
print(distance)
```"
611,Pentadecagonal Number | Java program to find Nth pentadecagonal number ; Function to find N - th pentadecagonal number ; Formula to calculate nth Pentadecagonal number ; Driver code,"```java
public static int pentadecagonalNumber(int n) {
    return n * (13 * n - 11) / 2;
  }
```","```python
def pentadecagonal_number(n):
  return n * (13 * n - 11) // 2
```"
612,Octadecagonal Number | Java program to find Nth octadecagonal number ; Function to find N - th octadecagonal number ; Formula to calculate nth octadecagonal number ; Driver code,"```java
public static int octadecagonalNumber(int n) {
    return n * (16 * n - 14);
}
```","```python
def octadecagonal_number(n):
  return n * (17 * n - 15) 
```"
613,Icositrigonal Number | Java program to find nth Icositrigonal number ; Function to find N - th Icositrigonal number ; Formula to calculate nth Icositrigonal number ; Driver code,"```java
public static int icositrigonalNumber(int n) {
    return n * (11 * n * n - 15 * n + 4) / 6;
}
```","```python
def icositrigonal_number(n):
  return n * (19 * n**2 - 15 * n + 2) // 6
```"
614,Find the percentage change in the area of a Rectangle | Java implementation to find the percentage ; Function to calculate percentage change in area of rectangle ; Driver code,"```java
public static double percentageChangeInArea(double width1, double height1, double width2, double height2) {
    double area1 = width1 * height1;
    double area2 = width2 * height2;
    return (area2 - area1) / area1 * 100;
  }
```","```python
def percentage_change_area(l1, w1, l2, w2):
  area1 = l1 * w1
  area2 = l2 * w2
  change = ((area2 - area1) / area1) * 100
  return change
```"
615,Minimum number of Circular obstacles required to obstruct the path in a Grid | Java program to find the minimum number of obstacles required ; Function to find the minimum number of obstacles required ; Find the minimum range required to put obstacles ; Sorting the radius ; If val is less than zero then we have find the number of obstacles required ; Driver code,"```java
import java.util.Arrays;

class Solution {
    public int findMinObstacles(int[][] grid, int[] radius) {
        int n = grid.length;
        int m = grid[0].length;
        Arrays.sort(radius);
        int val = radius[0] - 1;
        if (val < 0) {
            int minObstacles = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (grid[i][j] == 1) {
                        minObstacles++;
                    }
                }
            }
            return minObstacles;
        } else {
            int minObstacles = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (grid[i][j] == 1) {
                        minObstacles++;
                        int x = i + val;
                        int y = j + val;
                        if (x < n && y < m) {
                            grid[x][y] = 1;
                        }
                        x = i - val;
                        y = j - val;
                        if (x >= 0 && y >= 0) {
                            grid[x][y] = 1;
                        }
                        x = i + val;
                        y = j - val;
                        if (x < n && y >= 0) {
                            grid[x][y] = 1;
                        }
                        x = i - val;
                        y = j + val;
                        if (x >= 0 && y < m) {
                            grid[x][y] = 1;
                        }
                    }
                }
            }
            return minObstacles;
        }
    }
}
```","```python
def minObstacles(grid, radius):
  n = len(grid)
  m = len(grid[0])
  obstacles = 0
  radius.sort()
  for i in range(n):
    for j in range(m):
      if grid[i][j] == 1:
        continue
      val = radius[0] - max(abs(i - n // 2), abs(j - m // 2))
      if val < 0:
        obstacles += 1
        radius.pop(0)
  return obstacles
```"
616,Program to calculate area of a rhombus whose one side and diagonal are given | Java program to calculate the area of a rhombus whose one side and one diagonal is given ; function to calculate the area of the rhombus ; Second diagonal ; area of rhombus ; return the area ; Driver code,"```java
public static double rhombusArea(double side, double diagonal) {
    double secondDiagonal = Math.sqrt(4 * side * side - diagonal * diagonal);
    double area = (diagonal * secondDiagonal) / 2;
    return area;
}
```","```python
def rhombus_area(side, diagonal):
  second_diagonal = (4 * (side**2) - diagonal**2) ** 0.5
  area = (diagonal * second_diagonal) / 2
  return area
```"
617,"Check whether two points ( x1 , y1 ) and ( x2 , y2 ) lie on same side of a given line or not | Java program to check if two points lie on the same side or not ; Function to check if two points lie on the same side or not ; int fx1 ; Variable to store a * x1 + b * y1 - c int fx2 ; Variable to store a * x2 + b * y2 - c ; If fx1 and fx2 have same sign ; Driver code","```java
public static boolean onSameSide(int x1, int y1, int x2, int y2, int a, int b, int c) {
    int fx1 = a * x1 + b * y1 - c;
    int fx2 = a * x2 + b * y2 - c;
    return (fx1 * fx2 >= 0);
  }
```","```python
def check_same_side(a, b, c, x1, y1, x2, y2):
  fx1 = a * x1 + b * y1 - c
  fx2 = a * x2 + b * y2 - c
  return (fx1 * fx2) > 0
```"
618,Percentage increase in volume of the cube if a side of cube is increased by a given percentage | Java program to find percentage increase in the volume of the cube if a side of cube is increased by a given percentage ; Driver code,"```java
public static double percentageIncreaseInVolume(double side, double percentageIncrease) {
    double newSide = side * (1 + percentageIncrease / 100);
    double oldVolume = side * side * side;
    double newVolume = newSide * newSide * newSide;
    return ((newVolume - oldVolume) / oldVolume) * 100;
  }
```","```python
def percentage_increase_in_volume(original_side, percentage_increase):
  new_side = original_side * (1 + percentage_increase / 100)
  original_volume = original_side**3
  new_volume = new_side**3
  volume_increase = (new_volume - original_volume) / original_volume * 100
  return volume_increase
```"
619,Number of triangles formed by joining vertices of n | Java program to implement the above problem ; Function to find the number of triangles ; print the number of triangles having two side common ; print the number of triangles having no side common ; Driver code ; initialize the number of sides of a polygon,"```java
public static void countTriangles(int n) {
    int totalTriangles = n * (n - 4) * (n - 5) / 6;
    int trianglesWithTwoSidesCommon = n * (n - 3);
    int trianglesWithNoSidesCommon = totalTriangles - trianglesWithTwoSidesCommon;
    System.out.println(""Number of triangles with two sides common: "" + trianglesWithTwoSidesCommon);
    System.out.println(""Number of triangles with no sides common: "" + trianglesWithNoSidesCommon);
}
```","```python
def count_triangles(n):
  if n < 3:
    return 0
  return n * (n - 1) * (n - 2) // 6
```"
620,"Find the radii of the circles which are lined in a row , and distance between the centers of first and last circle is given | Java program to find radii of the circles which are lined in a row and distance between the centers of first and last circle is given ; Driver code","```java
import java.util.Scanner;

public class CircleRadii {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the number of circles: "");
        int n = scanner.nextInt();
        System.out.print(""Enter the distance between the centers of the first and last circles: "");
        double distance = scanner.nextDouble();

        double[] radii = findRadii(n, distance);

        System.out.println(""Radii of the circles:"");
        for (int i = 0; i < n; i++) {
            System.out.println(""Circle "" + (i + 1) + "": "" + radii[i]);
        }
    }

    public static double[] findRadii(int n, double distance) {
        double[] radii = new double[n];
        for (int i = 0; i < n; i++) {
            radii[i] = distance / (2 * (n - 1));
        }
        return radii;
    }
}
```","```python
def find_radii(n, distance):
  radii = [0] * n
  for i in range(n):
    radii[i] = distance / (2 * n - 1)
  return radii
```"
621,"Find the side of the squares which are lined in a row , and distance between the centers of first and last square is given | Java program to find side of the squares which are lined in a row and distance between the centers of first and last squares is given ; Driver code","```java
public static double findSide(double distance, int numSquares) {
    return (distance - (numSquares - 1) * 2) / (numSquares - 1);
}
```","```python
def find_side(distance, num_squares):
  return distance / (num_squares - 1)
```"
622,Number of triangles formed by joining vertices of n | Java program to implement the above problem ; Function to find the number of triangles ; print the number of triangles ; Driver code ; initialize the number of sides of a polygon,"```java
public static int findNumberOfTriangles(int n) {
    if (n < 3) {
      return 0;
    }
    return n * (n - 1) * (n - 2) / 6;
  }
```","```python
def countTriangles(n):
  return n * (n - 1) * (n - 2) // 6
```"
623,Find the Diameter or Longest chord of a Circle | Java program to find the longest chord or diameter of the circle whose radius is given ; Function to find the longest chord ; Driver code ; Get the radius ; Find the diameter,"```java
public static double findDiameter(double radius) {
    return 2 * radius;
  }
```","```python
def find_diameter(radius):
  return 2 * radius
```"
624,Slope of the line parallel to the line with the given slope | Java implementation of the approach ; Function to return the slope of the line which is parallel to the line with the given slope ; Driver code,"```java
public static double parallelSlope(double slope) {
    return slope;
}
```","```python
def slope_of_parallel_line(slope):
  return slope
```"
625,Total number of triangles formed when there are H horizontal and V vertical lines | Java implementation of the approach ; Function to return total triangles ; Only possible triangle is the given triangle ; If only vertical lines are present ; If only horizontal lines are present ; Return total triangles ; Driver code,"```java
public static int totalTriangles(int H, int V) {
    if (H == 0 || V == 0) {
      return 0;
    }
    return (H - 1) * (V - 1);
  }
```","```python
def total_triangles(H, V):
  if H == 0 or V == 0:
    return 0
  if H == 1 or V == 1:
    return 1
  return H * V
```"
626,Largest sphere that can be inscribed in a right circular cylinder inscribed in a frustum | Java Program to find the biggest sphere that can be inscribed within a right circular cylinder which in turn is inscribed within a frustum ; Function to find the biggest sphere ; the radii and height cannot be negative ; radius of the sphere ; volume of the sphere ; Driver code,"```java
public static double findBiggestSphere(double r1, double r2, double h) {
    if (r1 < 0 || r2 < 0 || h < 0) {
        return -1;
    }
    double r = (r1 * r2 * h) / (r1 * h + r2 * h + 2 * Math.sqrt(r1 * r1 * r2 * r2 + r1 * r1 * h * h + r2 * r2 * h * h));
    return (4.0 / 3.0) * Math.PI * r * r * r;
  }
```","```python
import math

def find_biggest_sphere(r1, r2, h):
  if r1 < 0 or r2 < 0 or h < 0:
    return -1
  radius_of_sphere = min((r1 + r2) / 2, h / 2)
  volume_of_sphere = (4 / 3) * math.pi * radius_of_sphere ** 3
  return volume_of_sphere
```"
627,Check whether two straight lines are orthogonal or not | Java implementation of above approach ; Function to check if two straight lines are orthogonal or not ; Both lines have infinite slope ; Only line 1 has infinite slope ; Only line 2 has infinite slope ; Find slopes of the lines ; Check if their product is - 1 ; Driver code,"```java
public static boolean areOrthogonal(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {
    if ((x1 == x2 && x3 == x4) || (y1 == y2 && y3 == y4)) {
        return true;
    } else if (x1 == x2) {
        return y3 != y4;
    } else if (x3 == x4) {
        return y1 != y2;
    } else {
        double slope1 = (y2 - y1) / (x2 - x1);
        double slope2 = (y4 - y3) / (x4 - x3);
        return slope1 * slope2 == -1;
    }
}
```","```python
def are_lines_orthogonal(x1, y1, x2, y2, x3, y3, x4, y4):
  if (x2 - x1 == 0 and x4 - x3 == 0):
    return True
  if (x2 - x1 == 0):
    return False
  if (x4 - x3 == 0):
    return False
  m1 = (y2 - y1) / (x2 - x1)
  m2 = (y4 - y3) / (x4 - x3)
  return m1 * m2 == -1
```"
628,Diagonal of a Regular Pentagon | Java Program to find the diagonal of a regular pentagon ; Function to find the diagonal of a regular pentagon ; Side cannot be negative ; Length of the diagonal ; Driver code,"```java
public static double diagonalOfPentagon(double side) {
    if (side < 0) {
      return -1;
    }
    return side * Math.sqrt((5 + 2 * Math.sqrt(5)) / 2);
  }
```","```python
import math

def diagonal_of_pentagon(side):
  return side * math.sqrt((5 + 2 * math.sqrt(5)) / 2)
```"
629,Area of hexagon with given diagonal length | Java program to find the area of Hexagon with given diagonal ; Function to calculate area ; Formula to find area ; Main,"```java
public static double areaOfHexagon(double diagonal) {
    return (3 * Math.sqrt(3) * Math.pow(diagonal, 2)) / 8;
  }
```","```python
import math

def hexagon_area(diagonal):
  return (3 * math.sqrt(3) * (diagonal ** 2)) / 8
```"
630,Number of squares of side length required to cover an N * M rectangle | Java program to find number of squares of a * a required to cover n * m rectangle ; function to find a number of squares of a * a required to cover n * m rectangle ; Driver code ; function call,"```java
public static int findSquares(int n, int m, int a) {
    return (int) Math.ceil((double) n / a) * (int) Math.ceil((double) m / a);
}
```","```python
def count_squares(n, m, a):
  return (n // a) * (m // a) + ((n % a != 0) * (m // a) + (m % a != 0) * (n // a) + (n % a != 0 and m % a != 0))
```"
631,Length of the Diagonal of the Octagon | Java Program to find the diagonal of the octagon ; Function to find the diagonal of the octagon ; side cannot be negative ; diagonal of the octagon ; Driver code,"```java
public static double diagonalOfOctagon(double side) {
    if (side < 0) {
      return -1;
    }
    return side * Math.sqrt(2 + 2 * Math.sqrt(2));
  }
```","```python
import math

def diagonal_of_octagon(side):
  if side < 0:
    return -1
  return side * math.sqrt(2 + 2*math.sqrt(2))
```"
632,Program to Calculate the Perimeter of a Decagon | package whatever do not write package name here Java program to Calculate the Perimeter of a Decagon ; Function for finding the perimeter ; Driver code,"```java
public static double decagonPerimeter(double side) {
    return 10 * side;
  }
```","```python
def perimeter_of_decagon(side_length):
  return 10 * side_length
```"
633,Sum of lengths of all 12 edges of any rectangular parallelepiped | Java program to illustrate the above problem ; function to find the sum of all the edges of parallelepiped ; to calculate the length of one edge ; sum of all the edges of one side ; net sum will be equal to the summation of edges of all the sides ; Driver code ; initialize the area of three faces which has a common vertex,"```java
public static double sumOfEdges(double a, double b, double c) {
    return 4 * (a + b + c);
}
```","```python
def sum_of_edges(a, b, c):
  return 4 * (a + b + c)
```"
634,"Maximum number of pieces in N cuts | Java program to find maximum no of pieces by given number of cuts ; Function for finding maximum pieces with n cuts . ; to maximize number of pieces x is the horizontal cuts ; Now ( x ) is the horizontal cuts and ( n - x ) is vertical cuts , then maximum number of pieces = ( x + 1 ) * ( n - x + 1 ) ; Driver code ; Taking the maximum number of cuts allowed as 3 ; Finding and printing the max number of pieces","```java
public static int maxPieces(int n) {
    int maxPieces = 0;
    for (int x = 0; x <= n; x++) {
        int currentPieces = (x + 1) * (n - x + 1);
        maxPieces = Math.max(maxPieces, currentPieces);
    }
    return maxPieces;
}
```","```python
def max_pieces(n):
  max_pieces = 0
  for x in range(n + 1):
    pieces = (x + 1) * (n - x + 1)
    max_pieces = max(max_pieces, pieces)
  return max_pieces
```"
635,Program to check whether 4 points in a 3 | Java program to check if 4 points in a 3 - D plane are Coplanar ; Function to find equation of plane . ; checking if the 4 th point satisfies the above equation ; Driver Code ; function calling,"```java
public class CoplanarPoints {

    public static boolean areCoplanar(double[][] points) {
        if (points.length != 4) {
            return false;
        }
        double[] a = points[0];
        double[] b = points[1];
        double[] c = points[2];
        double[] d = points[3];

        double[] ab = new double[]{b[0] - a[0], b[1] - a[1], b[2] - a[2]};
        double[] ac = new double[]{c[0] - a[0], c[1] - a[1], c[2] - a[2]};

        double[] normal = new double[]{ab[1] * ac[2] - ab[2] * ac[1],
                                       ab[2] * ac[0] - ab[0] * ac[2],
                                       ab[0] * ac[1] - ab[1] * ac[0]};

        double dValue = - (normal[0] * a[0] + normal[1] * a[1] + normal[2] * a[2]);

        return Math.abs(normal[0] * d[0] + normal[1] * d[1] + normal[2] * d[2] + dValue) < 1e-6;
    }

    public static void main(String[] args) {
        double[][] points1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};
        double[][] points2 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 13}};

        System.out.println(areCoplanar(points1)); // true
        System.out.println(areCoplanar(points2)); // false
    }
}
```","```python
import numpy as np

def is_coplanar(p1, p2, p3, p4):
  """"""
  Checks if 4 points in a 3D plane are coplanar.

  Args:
    p1: Coordinates of the first point (x1, y1, z1).
    p2: Coordinates of the second point (x2, y2, z2).
    p3: Coordinates of the third point (x3, y3, z3).
    p4: Coordinates of the fourth point (x4, y4, z4).

  Returns:
    True if the points are coplanar, False otherwise.
  """"""
  # Calculate the normal vector of the plane formed by the first three points.
  v1 = np.array(p2) - np.array(p1)
  v2 = np.array(p3) - np.array(p1)
  normal_vector = np.cross(v1, v2)

  # Calculate the distance of the fourth point from the plane.
  v3 = np.array(p4) - np.array(p1)
  distance = np.dot(normal_vector, v3)

  # If the distance is zero, the fourth point lies on the plane.
  return abs(distance) < 1e-6
```"
636,Angle between two Planes in 3D | Java program to find the Angle between two Planes in 3 D . ; Function to find Angle ; Driver code,"```java
public static double angleBetweenPlanes(double[] n1, double[] n2) {
    double dotProduct = n1[0] * n2[0] + n1[1] * n2[1] + n1[2] * n2[2];
    double magnitudeN1 = Math.sqrt(n1[0] * n1[0] + n1[1] * n1[1] + n1[2] * n1[2]);
    double magnitudeN2 = Math.sqrt(n2[0] * n2[0] + n2[1] * n2[1] + n2[2] * n2[2]);
    return Math.acos(dotProduct / (magnitudeN1 * magnitudeN2));
  }
```","```python
import numpy as np

def angle_between_planes(a1, b1, c1, d1, a2, b2, c2, d2):
  n1 = np.array([a1, b1, c1])
  n2 = np.array([a2, b2, c2])
  return np.degrees(np.arccos(np.dot(n1, n2) / (np.linalg.norm(n1) * np.linalg.norm(n2))))
```"
637,Mirror of a point through a 3 D plane | Java program to find Mirror of a point through a 3 D plane ; Function to mirror image ; Driver Code ; function call,"```java
import java.util.*;
class Solution {
    static void mirrorImage(double[] point, double[] planeNormal, double[] planePoint) {
        double[] normal = new double[3];
        for (int i = 0; i < 3; i++) {
            normal[i] = planeNormal[i];
        }
        double d = -planeNormal[0] * planePoint[0] - planeNormal[1] * planePoint[1] - planeNormal[2] * planePoint[2];
        double t = (d - normal[0] * point[0] - normal[1] * point[1] - normal[2] * point[2]) / (normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
        for (int i = 0; i < 3; i++) {
            point[i] = point[i] + 2 * t * normal[i];
        }
        System.out.println(""Mirror Image : ("" + point[0] + "", "" + point[1] + "", "" + point[2] + "")"");
    }
    public static void main(String[] args) {
        double[] point = {1, 2, 3};
        double[] planeNormal = {1, 1, 1};
        double[] planePoint = {1, 1, 1};
        mirrorImage(point, planeNormal, planePoint);
    }
}
```","```python
def mirror_point(point, plane_normal, plane_point):
  """"""
  Mirrors a point through a 3D plane.

  Args:
    point: The point to mirror.
    plane_normal: The normal vector of the plane.
    plane_point: A point on the plane.

  Returns:
    The mirrored point.
  """"""
  n = plane_normal
  p0 = plane_point
  p = point
  d = n.dot(p - p0)
  return p - 2 * d * n
```"
638,"Number of rectangles in a circle of radius R | Java program to find the number of rectangles that can be cut from a circle of Radius R ; Function to return the total possible rectangles that can be cut from the circle ; Diameter = 2 * Radius ; Square of diameter which is the square of the maximum length diagonal ; generate all combinations of a and b in the range ( 1 , ( 2 * Radius - 1 ) ) ( Both inclusive ) ; Calculate the Diagonal length of this rectangle ; If this rectangle 's Diagonal  Length is less than the Diameter,  it is a valid rectangle, thus  increment counter ; Driver Code ; Radius of the circle","```java
public static int countRectangles(int radius) {
    int count = 0;
    int diameter = 2 * radius;
    for (int a = 1; a <= (2 * radius - 1); a++) {
      for (int b = 1; b <= (2 * radius - 1); b++) {
        double diagonal = Math.sqrt(a * a + b * b);
        if (diagonal <= diameter) {
          count++;
        }
      }
    }
    return count;
  }
```","```python
def count_rectangles(R):
  diameter = 2 * R
  max_diagonal_square = diameter * diameter
  count = 0
  for a in range(1, 2 * R):
    for b in range(1, 2 * R):
      diagonal_square = a * a + b * b
      if diagonal_square <= max_diagonal_square:
        count += 1
  return count
```"
639,Program to check similarity of given two triangles | Java program to check similarity between two triangles . ; Function for AAA similarity ; Check for AAA ; Function for SAS similarity ; angle b \/ w two smallest sides is largest . ; since we take angle b \/ w the sides . ; Function for SSS similarity ; Check for SSS ; Driver Code ; function call for AAA similarity ; function call for SSS similarity ; function call for SAS similarity ; Check if triangles are similar or not,"```java
public class TriangleSimilarity {

    public static boolean checkAAASimilarity(double a1, double a2, double a3, double b1, double b2, double b3) {
        return (a1 == b1 && a2 == b2 && a3 == b3);
    }

    public static boolean checkSASSimilarity(double a1, double a2, double a3, double b1, double b2, double b3) {
        if (a1 == b1 && a2 == b2 && a3 == b3) {
            return true;
        } else if (a1 == b1 && a3 == b3 && a2 == b2) {
            return true;
        } else if (a2 == b2 && a3 == b3 && a1 == b1) {
            return true;
        }
        return false;
    }

    public static boolean checkSSSSimilarity(double a1, double a2, double a3, double b1, double b2, double b3) {
        if (a1 == b1 && a2 == b2 && a3 == b3) {
            return true;
        } else if (a1 == b1 && a2 == b3 && a3 == b2) {
            return true;
        } else if (a1 == b2 && a2 == b1 && a3 == b3) {
            return true;
        } else if (a1 == b2 && a2 == b3 && a3 == b1) {
            return true;
        } else if (a1 == b3 && a2 == b1 && a3 == b2) {
            return true;
        } else if (a1 == b3 && a2 == b2 && a3 == b1) {
            return true;
        }
        return false;
    }

    public static void main(String[] args) {
        double a1 = 3, a2 = 4, a3 = 5, b1 = 6, b2 = 8, b3 = 10;
        System.out.println(""AAA Similarity: "" + checkAAASimilarity(a1, a2, a3, b1, b2, b3));
        System.out.println(""SSS Similarity: "" + checkSSSSimilarity(a1, a2, a3, b1, b2, b3));
        System.out.println(""SAS Similarity: "" + checkSASSimilarity(a1, a2, a3, b1, b2, b3));
    }
}
```","```python
def aaa_similarity(a1, a2, a3, b1, b2, b3):
  return abs(a1 - b1) < 1e-6 and abs(a2 - b2) < 1e-6 and abs(a3 - b3) < 1e-6

def sas_similarity(a1, a2, b1, b2, angle):
  return abs(a1 - b1) < 1e-6 and abs(a2 - b2) < 1e-6 and abs(angle) < 1e-6

def sss_similarity(a1, a2, a3, b1, b2, b3):
  return abs(a1 - b1) < 1e-6 and abs(a2 - b2) < 1e-6 and abs(a3 - b3) < 1e-6

def check_similarity(a1, a2, a3, b1, b2, b3, angle=None):
  if aaa_similarity(a1, a2, a3, b1, b2, b3):
    return ""Triangles are similar (AAA)""
  if sss_similarity(a1, a2, a3, b1, b2, b3):
    return ""Triangles are similar (SSS)""
  if angle is not None and sas_similarity(a1, a2, b1, b2, angle):
    return ""Triangles are similar (SAS)""
  return ""Triangles are not similar""
```"
640,Centered Pentadecagonal Number | Java Program to find nth centered pentadecagonal number ; centered pentadecagonal function ; Formula to calculate nth centered pentadecagonal number ; Driver Code,"```java
public static int centeredPentadecagonalNumber(int n) {
    return (15 * n * n - 15 * n + 1) / 2;
}
```","```python
def centered_pentadecagonal_number(n):
  return (15 * n * (n - 1) // 2) + 1
```"
641,Centered nonadecagonal number | Java Program to find nth centered nonadecagonal number ; centered nonadecagonal function ; Formula to calculate nth centered nonadecagonal number ; Driver code,"```java
public static int centeredNonadecagonalNumber(int n) {
    return 19 * n * n - 18 * n + 1;
  }
```","```python
def centered_nonadecagonal_number(n):
  return 19 * n * (n - 1) + 1
```"
642,Hendecagonal number | Java program to find nth Hendecagonal number ; Function to find Hendecagonal number ; Formula to calculate nth Hendecagonal number ; Driver Code,"```java
public static int hendecagonalNumber(int n) {
    return n * (11 * n - 9) / 2;
}
```","```python
def hendecagonal_number(n):
  return n * (11 * n - 9) // 2
```"
643,Centered Octagonal Number | Java Program to find nth centered octagonal number ; Function to find centered octagonal number ; Formula to calculate nth centered octagonal number and return it into main function ; Driver Code,"```java
public static int centeredOctagonalNumber(int n) {
    return 4 * n * (n - 1) + 1;
  }
```","```python
def centered_octagonal_number(n):
  return 4 * n * (n - 1) + 1
```"
644,"Number of ordered points pair satisfying line equation | Java code to find number of ordered points satisfying line equation ; Checks if ( i , j ) is valid , a point ( i , j ) is valid if point ( arr [ i ] , arr [ j ] ) satisfies the equation y = mx + c And i is not equal to j ; check if i equals to j ; Equation LHS = y , and RHS = mx + c ; Returns the number of ordered pairs ( i , j ) for which point ( arr [ i ] , arr [ j ] ) satisfies the equation of the line y = mx + c ; for every possible ( i , j ) check if ( a [ i ] , a [ j ] ) satisfies the equation y = mx + c ; ( firstIndex , secondIndex ) is same as ( i , j ) ; check if ( firstIndex , secondIndex ) is a valid point ; Driver Code ; equation of line is y = mx + c","```java
public static int countValidPoints(int[] arr, int m, int c) {
    int count = 0;
    for (int firstIndex = 0; firstIndex < arr.length; firstIndex++) {
        for (int secondIndex = 0; secondIndex < arr.length; secondIndex++) {
            if (firstIndex != secondIndex && arr[secondIndex] == m * arr[firstIndex] + c) {
                count++;
            }
        }
    }
    return count;
}
```","```python
def count_valid_points(arr, m, c):
  count = 0
  n = len(arr)
  for firstIndex in range(n):
    for secondIndex in range(n):
      if firstIndex != secondIndex and arr[secondIndex] == m * arr[firstIndex] + c:
        count += 1
  return count
```"
645,"Check if a given circle lies completely inside the ring formed by two concentric circles | Java code to check if a circle lies in the ring ; Function to check if circle lies in the ring ; distance between center of circle center of concentric circles ( origin ) using Pythagoras theorem ; Condition to check if circle is strictly inside the ring ; Driver Code ; Both circle with radius ' r ' and ' R ' have center ( 0 , 0 )","```java
static boolean isCircleInRing(double r, double R, double circleRadius) {
    return circleRadius + r < R && circleRadius < R - r;
}
```","```python
import math

def lies_in_ring(r, R, circle_radius):
  return r + circle_radius < R and circle_radius < R - r
```"
646,Program for Surface Area of Octahedron | Java Program to calculate surface area of Octahedron . ; utility Function ; Driver Function,"```java
public static double octahedronSurfaceArea(double side) {
    return 2 * Math.sqrt(3) * Math.pow(side, 2);
}
```","```python
import math

def octahedron_surface_area(side_length):
  return 2 * math.sqrt(3) * side_length**2
```"
647,"Count of different straight lines with total n points with m collinear | Java program to count number of straight lines with n total points , out of which m are collinear . ; Returns value of binomial coefficient Code taken from https : goo . gl \/ vhy4jp ; C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; function to calculate number of straight lines can be formed ; Driver function","```java
public static long countLines(int n, int m) {
    if (n < 2) {
        return 0;
    }
    if (m == n) {
        return 1;
    }
    long[][] C = new long[n + 1][n + 1];
    for (int i = 0; i <= n; i++) {
        C[i][0] = 1;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
        }
    }
    return C[n][2] - C[m][2] + 1;
}
```","```python
def count_lines(n, m):
    C = [1]
    for i in range(1, n + 1):
        C.append(1)
        for j in range(i - 1, 0, -1):
            C[j] += C[j - 1]
    return C[n] - C[m] + 1
```"
648,Calculate Volume of Dodecahedron | Java program to calculate Volume of dodecahedron ; utility Function ; driver function,"```java
public static double dodecahedronVolume(double side) {
    return (15 + 7 * Math.sqrt(5)) * Math.pow(side, 3) / 4;
}
```","```python
import math

def dodecahedron_volume(side_length):
  return (15 + 7 * math.sqrt(5)) * side_length**3 / 4
```"
649,Program to check if water tank overflows when n solid balls are dipped in the water tank | JAVA Code for Program to check if water tank overflows ; function to find if tak will overflow or not ; cylinder capacity ; volume of water in tank ; volume of n balls ; total volume of water and n dipped balls ; condition to check if tank is in overflow state or not ; Driver program to test above function ; giving dimensions ; calling function,"```java
public static boolean willTankOverflow(double radius, double height, double waterLevel, int n, double ballRadius) {
    double cylinderCapacity = Math.PI * radius * radius * height;
    double waterVolume = Math.PI * radius * radius * waterLevel;
    double ballVolume = (4.0 / 3.0) * Math.PI * ballRadius * ballRadius * ballRadius;
    double totalVolume = waterVolume + n * ballVolume;
    return totalVolume > cylinderCapacity;
  }
```","```python
import math

def will_tank_overflow(radius_tank, height_tank, water_level, radius_ball, n_balls):
  tank_capacity = math.pi * radius_tank**2 * height_tank
  water_volume = math.pi * radius_tank**2 * water_level
  balls_volume = 4/3 * math.pi * radius_ball**3 * n_balls
  total_volume = water_volume + balls_volume
  return total_volume > tank_capacity
```"
650,"Program to check if tank will overflow , underflow or filled in given time | Java program to check if Tank will overflow or not in given time ; function to calculate the volume of tank ; function to print overflow \/ filled \/ underflow accordingly ; driver code ; radius of the tank ; height of the tank ; rate of flow of water ; time given ; calculate the required time ; printing the result","```java
import java.util.Scanner;

public class TankOverflow {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter radius of tank: "");
        double radius = scanner.nextDouble();
        System.out.print(""Enter height of tank: "");
        double height = scanner.nextDouble();
        System.out.print(""Enter rate of flow of water: "");
        double rate = scanner.nextDouble();
        System.out.print(""Enter time: "");
        double time = scanner.nextDouble();

        checkTankState(radius, height, rate, time);
    }

    public static void checkTankState(double radius, double height, double rate, double time) {
        double tankVolume = calculateTankVolume(radius, height);
        double requiredTime = tankVolume / rate;
        if (time > requiredTime) {
            System.out.println(""Overflow"");
        } else if (time == requiredTime) {
            System.out.println(""Filled"");
        } else {
            System.out.println(""Underflow"");
        }
    }

    public static double calculateTankVolume(double radius, double height) {
        return Math.PI * radius * radius * height;
    }
}
```","```python
import math

def check_tank_status(radius, height, flow_rate, time):
  tank_volume = math.pi * radius**2 * height
  required_time = tank_volume / flow_rate
  if time > required_time:
    print(""Overflow"")
  elif time == required_time:
    print(""Filled"")
  else:
    print(""Underflow"")
```"
651,Program to find third side of triangle using law of cosines | Java program to find third side of triangle using law of cosines ; Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to find third side ; Driver code ; function call,"```java
import java.lang.Math;

public class TriangleSide {

    public static double cos(double angle) {
        return Math.cos(Math.toRadians(angle));
    }

    public static double findThirdSide(double a, double b, double angleC) {
        return Math.sqrt(a * a + b * b - 2 * a * b * cos(angleC));
    }

    public static void main(String[] args) {
        double a = 5;
        double b = 7;
        double angleC = 60;
        double c = findThirdSide(a, b, angleC);
        System.out.println(""The third side of the triangle is: "" + c);
    }
}
```","```python
import math

def cos_value(angle_c):
  return math.cos(math.radians(angle_c))

def find_third_side(a, b, angle_c):
  return math.sqrt(a**2 + b**2 - 2 * a * b * cos_value(angle_c))

def main():
  a = float(input(""Enter the length of side a: ""))
  b = float(input(""Enter the length of side b: ""))
  angle_c = float(input(""Enter the angle C in degrees: ""))
  c = find_third_side(a, b, angle_c)
  print(""The length of side c is:"", c)

if __name__ == ""__main__"":
  main()
```"
652,Check whether given circle resides in boundary maintained by two other circles | Java program to check whether circle with given co - ordinates reside within the boundary of outer circle and inner circle ; function to check if given circle fit in boundary or not ; Distance from the center ; Checking the corners of circle ; driver program ; Radius of outer circle and inner circle respectively ; Co - ordinates and radius of the circle to be checked,"```java
public static boolean checkCircleFit(double outerX, double outerY, double outerR, double innerX, double innerY, double innerR, double checkX, double checkY, double checkR) {
    double distanceOuter = Math.sqrt(Math.pow(checkX - outerX, 2) + Math.pow(checkY - outerY, 2));
    double distanceInner = Math.sqrt(Math.pow(checkX - innerX, 2) + Math.pow(checkY - innerY, 2));
    return distanceOuter - checkR <= outerR && distanceInner + checkR >= innerR;
}
```","```python
import math

def check_circle_fit(outer_circle_radius, inner_circle_radius, circle_x, circle_y, circle_radius):
  distance_to_outer_center = math.sqrt((circle_x - 0)**2 + (circle_y - 0)**2)
  distance_to_inner_center = math.sqrt((circle_x - 0)**2 + (circle_y - 0)**2)
  return (distance_to_outer_center - circle_radius) >= 0 and (distance_to_inner_center + circle_radius) <= inner_circle_radius
```"
653,"Number of Triangles that can be formed given a set of lines in Euclidean Plane | Java program to find the number of triangles that can be formed using a set of lines in Euclidean Plane ; Double variables can ' t ▁ be ▁ checked ▁ precisely ▁ using ▁ ' == ' this function returns true if the double variables are equal ; This function returns the number of triangles for a given set of lines ; Slope array stores the slope of lines ; Slope array is sorted so that all lines with same slope come together ; After sorting slopes , count different slopes . k is index in count [ ] . ; Count of current slope ; Calculating sum1 ( Sum of all slopes ) sum1 = m1 + m2 + ... ; Calculating sum2 . sum2 = m1 * m2 + m2 * m3 + ... ; Needed for sum3 ; Calculating sum3 which gives the final answer m1 * m2 * m3 + m2 * m3 * m4 + ... ; Driver code ; Lines are stored as arrays of a , b and c for ' ax + by = c ' ; n is the number of lines","```java
public static int countTriangles(double[][] lines) {
    int n = lines.length;
    double[] slopes = new double[n];
    for (int i = 0; i < n; i++) {
        slopes[i] = -lines[i][0] / lines[i][1];
    }
    Arrays.sort(slopes);
    int k = 0;
    int[] count = new int[n];
    for (int i = 0; i < n; i++) {
        if (i == 0 || !doubleEquals(slopes[i], slopes[i - 1])) {
            count[k]++;
        } else {
            count[k]++;
        }
        if (i == n - 1 || !doubleEquals(slopes[i], slopes[i + 1])) {
            k++;
        }
    }
    double sum1 = 0;
    double sum2 = 0;
    double sum3 = 0;
    for (int i = 0; i <= k; i++) {
        sum1 += count[i];
        sum2 += count[i] * (sum1 - count[i]);
        sum3 += count[i] * (sum2 - count[i] * (sum1 - count[i]));
    }
    return (int) sum3 / 6;
}

private static boolean doubleEquals(double a, double b) {
    return Math.abs(a - b) < 1e-9;
}
```","```python
def countTriangles(lines):
  n = len(lines)
  slopes = []
  for i in range(n):
    a, b, c = lines[i]
    if b != 0:
      slopes.append(-a / b)
    else:
      slopes.append(float('inf'))
  slopes.sort()
  count = []
  k = 0
  count.append(1)
  for i in range(1, n):
    if slopes[i] == slopes[i - 1]:
      count[k] += 1
    else:
      k += 1
      count.append(1)
  sum1 = 0
  for i in range(k + 1):
    sum1 += count[i]
  sum2 = 0
  for i in range(k + 1):
    sum2 += count[i] * (sum1 - count[i])
  sum3 = 0
  for i in range(k + 1):
    sum3 += count[i] * (sum2 - count[i] * (sum1 - count[i]))
  return sum3 // 6
```"
654,Program to find line passing through 2 Points | Java Implementation to find the line passing through two points ; This pair is used to store the X and Y coordinate of a point respectively ; Function to find the line given two points ; Driver code,"```java
class Point {
  double x;
  double y;
  Point(double x, double y) {
    this.x = x;
    this.y = y;
  }
}

class Line {
  double slope;
  double yIntercept;

  Line(double slope, double yIntercept) {
    this.slope = slope;
    this.yIntercept = yIntercept;
  }
}

class Solution {
  public Line findLine(Point p1, Point p2) {
    if (p1.x == p2.x) {
      return new Line(Double.POSITIVE_INFINITY, p1.x);
    } else {
      double slope = (p2.y - p1.y) / (p2.x - p1.x);
      double yIntercept = p1.y - slope * p1.x;
      return new Line(slope, yIntercept);
    }
  }
}
```","```python
def find_line(point1, point2):
  x1, y1 = point1
  x2, y2 = point2
  if x1 == x2:
    return ""Vertical line""
  else:
    slope = (y2 - y1) / (x2 - x1)
    intercept = y1 - slope * x1
    return f""y = {slope}x + {intercept}""
```"
655,"Regular polygon using only 1 s in a binary numbered circle | Java program to find whether a regular polygon is possible in circle with 1 s as vertices ; method returns true if polygon is possible with ' midpoints ' number of midpoints ; loop for getting first vertex of polygon ; loop over array values at ' midpoints ' distance ; and ( & ) all those values , if even one of them is 0 , val will be 0 ; if val is still 1 and ( N \/ midpoints ) or ( number of vertices ) are more than two ( for a polygon minimum ) print result and return true ; method prints sides in the polygon or print not possible in case of no possible polygon ; limit for iterating over divisors ; If i divides N then i and ( N \/ i ) will be divisors ; check polygon for both divisors ; Driver method","```java
public static boolean isPolygonPossible(int N, int midpoints) {
    if (N <= 2 || midpoints <= 1) {
        return false;
    }
    for (int i = 0; i < N; i++) {
        int val = 1;
        for (int j = 0; j < midpoints; j++) {
            val &= (1 << ((i + j * N / midpoints) % N));
        }
        if (val == 1 && (N / midpoints > 1 || midpoints > 1)) {
            System.out.println(""Polygon with "" + midpoints + "" sides is possible"");
            return true;
        }
    }
    System.out.println(""Polygon is not possible"");
    return false;
}
```","```python
def is_polygon_possible(N, midpoints):
  for i in range(1, N + 1):
    if N % i == 0:
      for j in range(i, N + 1, i):
        val = 1
        for k in range(midpoints):
          val &= midpoints[j + k]
        if val and (N // i) > 2:
          print(f""Polygon with {N // i} sides is possible."")
          return True
      for j in range(N - i + 1, 1, -i):
        val = 1
        for k in range(midpoints):
          val &= midpoints[j + k]
        if val and (N // i) > 2:
          print(f""Polygon with {N // i} sides is possible."")
          return True
  print(""Not possible."")
  return False
```"
656,Maximum height when coins are arranged in a triangle | Java program to find maximum height of arranged coin triangle ; Returns the square root of n . Note that the function ; We are using n itself as initial approximation . This can definitely be improved ; e decides the accuracy level ; Method to find maximum height of arrangement of coins ; calculating portion inside the square root ; Driver code,"```java
import java.lang.Math;
public class Solution {
    public static double squareRoot(double n, double e) {
        double x = n;
        while (Math.abs(x * x - n) > e) {
            x = (x + n / x) / 2;
        }
        return x;
    }
    public static int maxHeight(int n) {
        double insideSqrt = (1 + 8 * (double) n);
        double result = (squareRoot(insideSqrt, 0.0001) - 1) / 2;
        return (int) result;
    }
    public static void main(String[] args) {
        int n = 5;
        System.out.println(maxHeight(n));
    }
}
```","```python
import math

def max_height(n):
  return int(math.sqrt(2 * n))
```"
657,"Number of Integral Points between Two Points | Java code to find the number of integral points lying on the line joining the two given points ; Class to represent an Integral point on XY plane . ; Utility function to find GCD of two numbers GCD of a and b ; Finds the no . of Integral points between two given points . ; If line joining p and q is parallel to x axis , then count is difference of y values ; If line joining p and q is parallel to y axis , then count is difference of x values ; Driver program to test above","```java
class Point {
  int x;
  int y;

  Point(int x, int y) {
    this.x = x;
    this.y = y;
  }
}

class Solution {
  public static int gcd(int a, int b) {
    if (b == 0) {
      return a;
    }
    return gcd(b, a % b);
  }

  public static int countIntegralPoints(Point p, Point q) {
    if (p.x == q.x) {
      return Math.abs(p.y - q.y) - 1;
    } else if (p.y == q.y) {
      return Math.abs(p.x - q.x) - 1;
    } else {
      int dx = Math.abs(p.x - q.x);
      int dy = Math.abs(p.y - q.y);
      return gcd(dx, dy) - 1;
    }
  }

  public static void main(String[] args) {
    Point p = new Point(1, 1);
    Point q = new Point(4, 5);
    System.out.println(countIntegralPoints(p, q));
  }
}
```","```python
class IntegralPoint:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def findIntegralPoints(p, q):
    if p.x == q.x:
        return abs(p.y - q.y) - 1
    if p.y == q.y:
        return abs(p.x - q.x) - 1
    dx = abs(p.x - q.x)
    dy = abs(p.y - q.y)
    commonFactor = gcd(dx, dy)
    return commonFactor - 1

# Driver program to test above
p = IntegralPoint(1, 1)
q = IntegralPoint(4, 5)
print(findIntegralPoints(p, q))
```"
658,"How to check if given four points form a square | A Java program to check if four given points form a square or not . ; Structure of a point in 2D space ; A utility function to find square of distance from point ' p ' to point ' q ' ; This function returns true if ( p1 , p2 , p3 , p4 ) form a square , otherwise false ; int d2 = distSq ( p1 , p2 ) ; from p1 to p2 int d3 = distSq ( p1 , p3 ) ; from p1 to p3 int d4 = distSq ( p1 , p4 ) ; from p1 to p4 ; If lengths if ( p1 , p2 ) and ( p1 , p3 ) are same , then following conditions must met to form a square . 1 ) Square of length of ( p1 , p4 ) is same as twice the square of ( p1 , p2 ) 2 ) Square of length of ( p2 , p3 ) is same as twice the square of ( p2 , p4 ) ; The below two cases are similar to above case ; Driver code","```java
class Point {
    int x;
    int y;
    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class Solution {
    int distSq(Point p1, Point p2) {
        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
    }
    boolean isSquare(Point p1, Point p2, Point p3, Point p4) {
        int d2 = distSq(p1, p2);
        int d3 = distSq(p1, p3);
        int d4 = distSq(p1, p4);
        if (d2 == d3 && 2 * d2 == d4 && 2 * distSq(p2, p4) == distSq(p2, p3)) {
            return true;
        }
        if (d2 == d4 && 2 * d2 == d3 && 2 * distSq(p2, p3) == distSq(p2, p4)) {
            return true;
        }
        if (d3 == d4 && 2 * d3 == d2 && 2 * distSq(p3, p2) == distSq(p3, p4)) {
            return true;
        }
        return false;
    }
}
```","```python
import math

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def distSq(p1, p2):
    return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2

def isSquare(p1, p2, p3, p4):
    d2 = distSq(p1, p2)
    d3 = distSq(p1, p3)
    d4 = distSq(p1, p4)
    if d2 == d3:
        return d4 == 2 * d2 and distSq(p2, p3) == 2 * distSq(p2, p4)
    elif d2 == d4:
        return d3 == 2 * d2 and distSq(p2, p4) == 2 * distSq(p3, p4)
    elif d3 == d4:
        return d2 == 2 * d3 and distSq(p3, p4) == 2 * distSq(p2, p3)
    else:
        return False
```"
659,"Count triplets such that product of two numbers added with third number is N | Java program for the above approach ; Function to find the divisors of the number ( N - i ) ; Stores the resultant count of divisors of ( N - i ) ; Iterate over range [ 1 , sqrt ( N ) ] ; Return the total divisors ; Function to find the number of triplets such that A * B - C = N ; Loop to fix the value of C ; Adding the number of divisors in count ; Return count of triplets ; Driver Code","```java
public static int countTriplets(int N) {
    int count = 0;
    for (int c = 1; c <= N; c++) {
        count += countDivisors(N - c);
    }
    return count;
}

public static int countDivisors(int num) {
    int count = 0;
    for (int i = 1; i * i <= num; i++) {
        if (num % i == 0) {
            if (i * i == num) {
                count++;
            } else {
                count += 2;
            }
        }
    }
    return count;
}
```","```python
def count_triplets(N):
  def divisors(n):
    count = 0
    for i in range(1, int(n**0.5) + 1):
      if n % i == 0:
        count += 2 if i * i != n else 1
    return count
  count = 0
  for c in range(1, N + 1):
    count += divisors(N - c)
  return count
```"
660,Maximize count of planes that can be stopped per second with help of given initial position and speed | Java program for the above approach ; Function to find maximum number of planes that can be stopped from landing ; Stores the times needed for landing for each plane ; Iterate over the arrays ; Stores the time needed for landing of current plane ; Update the value of t ; Append the t in set St ; Return the answer ; Driver Code,"```java
public static int maxPlanes(int[] pos, int[] speed) {
    int n = pos.length;
    Set<Integer> St = new HashSet<>();
    for (int i = 0; i < n; i++) {
        int t = (pos[i] / speed[i]);
        St.add(t);
    }
    return St.size();
}
```","```python
def maxPlanes(arr, speed):
  n = len(arr)
  St = set()
  t = 0
  for i in range(n):
    t = arr[i] + speed[i]
    St.add(t)
  return len(St)
```"
661,"Find the player who will win by choosing a number in range [ 1 , K ] with sum total N | Java program for the above approach ; Function to predict the winner ; Driver Code ; Given Input ; Function call","```java
import java.util.*;
class Solution {
    public static int predictTheWinner(int n, int k) {
        if (n <= k) {
            return 1;
        }
        boolean[][] dp = new boolean[n + 1][k + 1];
        for (int i = 1; i <= n; i++) {
            dp[i][1] = true;
        }
        for (int i = 2; i <= n; i++) {
            for (int j = 2; j <= k; j++) {
                if (i <= j) {
                    dp[i][j] = false;
                } else {
                    dp[i][j] = !dp[i - j][j];
                }
            }
        }
        return dp[n][k] ? 1 : 2;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int winner = predictTheWinner(n, k);
        System.out.println(winner);
    }
}
```","```python
def predict_winner(N, K):
  return (N % (K + 1) != 0)
```"
662,Maximize the rightmost element of an array in k operations in Linear Time | Java program for the above approach ; Function to calculate maximum value of Rightmost element ; Initializing ans to store Maximum valued rightmost element ; Calculating maximum value of Rightmost element ; returning rightmost element ; Driver Code ; Given Input ; Function Call,"```java
public static int maximizeRightmost(int[] arr, int k) {
    int ans = arr[arr.length - 1];
    for (int i = 0; i < k; i++) {
      arr[arr.length - 1] = arr[arr.length - 1] + arr[arr.length - 2];
      ans = Math.max(ans, arr[arr.length - 1]);
    }
    return ans;
  }
```","```python
def maximize_rightmost(arr, k):
  n = len(arr)
  ans = arr[n - 1]
  for i in range(n - 2, -1, -1):
    if k > 0:
      if arr[i] > ans:
        ans = arr[i]
        k -= 1
  return ans
```"
663,Minimize the maximum element in constructed Array with sum divisible by K | Java program for the above approach ; Function to find smallest maximum number in an array whose sum is divisible by K . ; Minimum possible sum possible for an array of size N such that its sum is divisible by K ; If sum is not divisible by N ; If sum is divisible by N ; Driver code,"```java
public static int minMaxSumDivisibleByK(int[] arr, int k) {
    int n = arr.length;
    int sum = 0;
    for (int i = 0; i < n; i++) {
      sum += arr[i];
    }
    if (sum % k != 0) {
      return -1;
    }
    Arrays.sort(arr);
    int max = arr[n - 1];
    int min = arr[0];
    int result = max;
    for (int i = 0; i < n; i++) {
      if (arr[i] == max) {
        continue;
      }
      int tempSum = sum - max + arr[i];
      if (tempSum % k == 0 && arr[i] < result) {
        result = arr[i];
      }
    }
    return result;
  }
```","```python
def minMaxDivisible(arr, n, k):
  sum = 0
  for i in range(n):
    sum += arr[i]
  if sum % k != 0:
    return -1
  arr.sort()
  maxElement = arr[n - 1]
  for i in range(n - 1, -1, -1):
    if (sum - arr[i]) % k == 0:
      maxElement = arr[i]
      break
  return maxElement
```"
664,"Check if it is possible to construct an Array of size N having sum as S and XOR value as X | Java program for the above approach ; Function to find if any sequence is possible or not . ; Since , S is greater than equal to X , and either both are odd or even There always exists a sequence ; Only one case possible is S == X or NOT ; ; Considering the above conditions true , check if XOR of S ^ ( S - X ) is X or not ; Driver code","```java
public static boolean isPossible(int N, int S, int X) {
    if (S >= X && ((S % 2 == 0 && X % 2 == 0) || (S % 2 == 1 && X % 2 == 1))) {
        return S == X || (S ^ (S - X)) == X;
    }
    return false;
}
```","```python
def is_possible(N, S, X):
  if S >= X and (S % 2 == X % 2):
    return S ^ (S - X) == X
  return False
```"
665,"Check whether each Array element can be reduced to minimum element by replacing it with remainder with some X | Java program for the above approach ; Function to check if every integer in the array can be reduced to the minimum array element ; Stores the minimum array element ; Find the minimum element ; Traverse the array arr [ ] ; Stores the maximum value in the range ; Check whether mini lies in the range or not ; Otherwise , return Yes ; Driver code","```java
public static boolean canReduceToMinimum(int[] arr) {
    int mini = arr[0];
    for (int i = 1; i < arr.length; i++) {
      if (arr[i] < mini) {
        mini = arr[i];
      }
    }
    for (int i = 0; i < arr.length; i++) {
      int max = Math.max(arr[i], mini);
      if (mini % (max - mini) != 0) {
        return false;
      }
    }
    return true;
  }
```","```python
def check_array_reduction(arr):
  mini = arr[0]
  for i in range(1, len(arr)):
    if arr[i] < mini:
      mini = arr[i]
  max_range = 0
  for i in range(len(arr)):
    max_range = max(max_range, arr[i] - mini)
  if mini <= max_range:
    return ""Yes""
  else:
    return ""No""
```"
666,Maximum number which can divide all array element after one replacement | Java program for the above approach ; Function to return gcd of two numbers ; If one of numbers is 0 then gcd is other number ; If both are equal then that value is gcd ; One is greater ; Function to return minimum sum ; Initialize min_sum with large value ; Initialize variable gcd ; Storing value of arr [ i ] in c ; Update maxGcd if gcd is greater than maxGcd ; returning the maximum divisor of all elements ; Driver code,"```java
public static int maxDivisor(int[] arr) {
    int minSum = Integer.MAX_VALUE;
    int maxGcd = 0;
    for (int i = 0; i < arr.length; i++) {
      int c = arr[i];
      for (int j = 0; j < arr.length; j++) {
        if (i != j) {
          int gcd = findGCD(c, arr[j]);
          if (gcd > maxGcd) {
            maxGcd = gcd;
          }
        }
      }
      int sum = 0;
      for (int j = 0; j < arr.length; j++) {
        sum += arr[j] / maxGcd;
      }
      if (sum < minSum) {
        minSum = sum;
      }
    }
    return maxGcd;
  }
  public static int findGCD(int a, int b) {
    if (a == 0) {
      return b;
    }
    if (b == 0) {
      return a;
    }
    if (a == b) {
      return a;
    }
    if (a > b) {
      return findGCD(a - b, b);
    } else {
      return findGCD(a, b - a);
    }
  }
```","```python
def find_max_divisor(arr):
  n = len(arr)
  min_sum = float('inf')
  maxGcd = 1
  for i in range(n):
    c = arr[i]
    for j in range(n):
      if i != j:
        gcd = find_gcd(c, arr[j])
        min_sum = min(min_sum, c + arr[j] - gcd)
        maxGcd = max(maxGcd, gcd)
  return maxGcd

def find_gcd(a, b):
  if a == 0:
    return b
  if b == 0:
    return a
  if a == b:
    return a
  if a > b:
    return find_gcd(a - b, b)
  return find_gcd(a, b - a)
```"
667,Count of distinct N | Java program of the above approach ; Function to find the count of distinct odd integers with N digits using the given digits in the array arr [ ] ; Stores the factorial of a number ; Calculate the factorial of all numbers from 1 to N ; Stores the frequency of each digit ; Stores the final answer ; Loop to iterate over all values of Nth digit i and 1 st digit j ; If digit i does not exist in the given array move to next i ; Fixing i as Nth digit ; Stores the answer of a specific value of i and j ; If digit j does not exist move to the next j ; Fixing j as 1 st digit ; Calculate number of ways to arrange remaining N - 2 digits ; Including j back into the set of digits ; Including i back into the set of the digits ; Return Answer ; Driver Code ; Function Call,"```java
public static int countDistinctOddIntegers(int[] arr, int N) {
    int[] factorial = new int[N + 1];
    factorial[0] = 1;
    for (int i = 1; i <= N; i++) {
        factorial[i] = factorial[i - 1] * i;
    }
    int[] freq = new int[10];
    for (int i = 0; i < arr.length; i++) {
        freq[arr[i]]++;
    }
    int answer = 0;
    for (int i = 1; i <= 9; i += 2) {
        if (freq[i] == 0) {
            continue;
        }
        for (int j = 1; j <= 9; j += 2) {
            if (freq[j] == 0) {
                continue;
            }
            int temp = 1;
            for (int k = 0; k < 10; k++) {
                if (k != i && k != j) {
                    temp *= factorial[freq[k]];
                }
            }
            answer += (factorial[N - 2] * temp) / (factorial[freq[i] - 1] * factorial[freq[j] - 1]);
        }
    }
    return answer;
}
```","```python
def countDistinctOdd(arr, N):
    fact = [1] * (N + 1)
    for i in range(2, N + 1):
        fact[i] = fact[i - 1] * i
    freq = [0] * 10
    for i in arr:
        freq[i] += 1
    ans = 0
    for i in range(1, 10, 2):
        if freq[i] == 0:
            continue
        for j in range(1, 10, 2):
            if freq[j] == 0:
                continue
            temp = 1
            temp *= freq[i]
            temp *= freq[j]
            freq[i] -= 1
            freq[j] -= 1
            for k in range(1, 10):
                temp *= fact[freq[k]]
            temp *= fact[N - 2]
            freq[i] += 1
            freq[j] += 1
            ans += temp
    return ans
```"
668,Count pairs in an array having sum of elements with their respective sum of digits equal | package whatever do not write package name here ; Function to find the sum of digits of the number N ; Stores the sum of digits ; If the number N is greater than 0 ; Return the sum ; Function to find the count of pairs such that arr [ i ] + sumOfDigits ( arr [ i ] ) is equal to ( arr [ j ] + sumOfDigits ( arr [ j ] ) ; Stores the frequency of value of arr [ i ] + sumOfDigits ( arr [ i ] ) ; Traverse the given array ; Find the value ; Increment the frequency ; Stores the total count of pairs ; Traverse the map mp ; Update the count of pairs ; Return the total count of pairs ; Driver Code,"```java
public static int countPairs(int[] arr) {
    Map<Integer, Integer> mp = new HashMap<>();
    for (int i = 0; i < arr.length; i++) {
        int value = arr[i] + sumOfDigits(arr[i]);
        mp.put(value, mp.getOrDefault(value, 0) + 1);
    }
    int count = 0;
    for (int value : mp.keySet()) {
        int freq = mp.get(value);
        count += (freq * (freq - 1)) / 2;
    }
    return count;
}

public static int sumOfDigits(int N) {
    int sum = 0;
    while (N > 0) {
        sum += N % 10;
        N /= 10;
    }
    return sum;
}
```","```python
def sumOfDigits(N):
  sum = 0
  while N > 0:
    sum += N % 10
    N //= 10
  return sum

def countPairs(arr):
  mp = {}
  for i in range(len(arr)):
    value = arr[i] + sumOfDigits(arr[i])
    if value in mp:
      mp[value] += 1
    else:
      mp[value] = 1
  count = 0
  for value in mp:
    count += mp[value] * (mp[value] - 1) // 2
  return count
```"
669,Longest subarray with GCD greater than 1 | Java program of the above approach ; Function to build the Segment Tree from the given array to process range queries in log ( N ) time ; Termination Condition ; Find the mid value ; Left and Right Recursive Call ; Update the Segment Tree Node ; Function to return the GCD of the elements of the Array from index l to index r ; Base Case ; Find the middle range ; Find the GCD and return ; Function to print maximum length of the subarray having GCD > one ; Stores the Segment Tree ; Function call to build the Segment tree from array arr [ ] ; Store maximum length of subarray ; Starting and ending pointer of the current window ; Case where the GCD of the current window is 1 ; Update the maximum length ; Print answer ; Driver Code,"```java
class Solution {
    int[] segTree;
    int n;

    public void buildTree(int[] arr, int l, int r, int node) {
        if (l == r) {
            segTree[node] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        buildTree(arr, l, mid, 2 * node);
        buildTree(arr, mid + 1, r, 2 * node + 1);
        segTree[node] = gcd(segTree[2 * node], segTree[2 * node + 1]);
    }

    public int query(int l, int r, int ql, int qr, int node) {
        if (ql <= l && qr >= r) {
            return segTree[node];
        }
        if (r < ql || l > qr) {
            return 1;
        }
        int mid = (l + r) / 2;
        return gcd(query(l, mid, ql, qr, 2 * node), query(mid + 1, r, ql, qr, 2 * node + 1));
    }

    public int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }

    public void printMaxLenSubarray(int[] arr) {
        n = arr.length;
        segTree = new int[4 * n];
        buildTree(arr, 0, n - 1, 1);
        int maxLen = 0;
        int start = 0;
        int end = 0;
        while (end < n) {
            if (query(0, n - 1, start, end, 1) == 1) {
                maxLen = Math.max(maxLen, end - start + 1);
                start = end + 1;
            }
            end++;
        }
        System.out.println(maxLen);
    }

    public static void main(String[] args) {
        Solution ob = new Solution();
        int[] arr = {2, 4, 6, 8, 10, 12};
        ob.printMaxLenSubarray(arr);
    }
}
```","```python
def build_segment_tree(arr, tree, node, start, end):
    if start == end:
        tree[node] = arr[start]
        return
    mid = (start + end) // 2
    build_segment_tree(arr, tree, 2 * node, start, mid)
    build_segment_tree(arr, tree, 2 * node + 1, mid + 1, end)
    tree[node] = gcd(tree[2 * node], tree[2 * node + 1])


def query_segment_tree(tree, node, start, end, l, r):
    if l > end or r < start:
        return 1
    if l <= start and r >= end:
        return tree[node]
    mid = (start + end) // 2
    return gcd(query_segment_tree(tree, 2 * node, start, mid, l, r),
               query_segment_tree(tree, 2 * node + 1, mid + 1, end, l, r))


def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)


def max_length_subarray_gcd_greater_than_one(arr):
    n = len(arr)
    tree = [0] * (4 * n)
    build_segment_tree(arr, tree, 1, 0, n - 1)
    max_len = 0
    i = 0
    j = 0
    while j < n:
        if query_segment_tree(tree, 1, 0, n - 1, i, j) > 1:
            max_len = max(max_len, j - i + 1)
            j += 1
        else:
            i = j + 1
            j += 1
    print(max_len)


# Driver Code
arr = [2, 4, 6, 8, 10]
max_length_subarray_gcd_greater_than_one(arr)
```"
670,Smallest pair of integers with minimum difference whose Bitwise XOR is N | Java program for the above approach ; Function to find the numbers A and B whose Bitwise XOR is N and the difference between them is minimum ; Find the MSB of the N ; Find the value of B ; Find the value of A ; Print the result ; Driver Code,"```java
public static void findNumbers(int n) {
    int msb = Integer.highestOneBit(n);
    int b = n ^ msb;
    int a = msb;
    System.out.println(""A = "" + a + "", B = "" + b);
}
```","```python
def find_smallest_pair(N):
  msb = 1
  while msb <= N:
    msb <<= 1
  msb >>= 1
  B = msb - 1
  A = N ^ B
  return A, B
```"
671,Find all possible values of K such that the sum of first N numbers starting from K is G | Java program for the above approach ; Function to find the count the value of K such that sum of the first N numbers from K is G ; Stores the total count of K ; Iterate till square root of g ; If the number is factor of g ; If the second factor is not equal to first factor ; Check if two factors are odd or not ; If second factor is the same as the first factor then check if the first factor is odd or not ; Print the resultant count ; Driver code,"```java
public static int countK(int n, int g) {
  int count = 0;
  for (int i = 1; i * i <= g; i++) {
    if (g % i == 0) {
      int j = g / i;
      if (i != j) {
        if ((i % 2 == 1 && j % 2 == 1) || (i == j && i % 2 == 1)) {
          count++;
        }
      } else if (i % 2 == 1) {
        count++;
      }
    }
  }
  return count;
}
```","```python
def find_k_count(g, n):
  count = 0
  for i in range(1, int(g**0.5) + 1):
    if g % i == 0:
      j = g // i
      if i != j:
        if (i % 2 != 0 and j % 2 != 0) or (i == j and i % 2 != 0):
          count += 1
      else:
        if i % 2 != 0:
          count += 1
  return count
```"
672,"Difference between maximum and minimum average of all K | Java program for the above approach ; Function to find the difference between the maximum and minimum subarrays of length K ; Stores the sum of subarray over the range [ 0 , K ] ; Iterate over the range [ 0 , K ] ; Store min and max sum ; Iterate over the range [ K , N - K ] ; Increment sum by arr [ i ] - arr [ i - K ] ; Update max and min moving sum ; Return difference between max and min average ; Driver Code ; Given Input ; Function Call","```java
public static double maxMinAvgDiff(int[] arr, int k) {
    if (arr.length < k) {
      return 0;
    }
    int sum = 0;
    for (int i = 0; i < k; i++) {
      sum += arr[i];
    }
    int minSum = sum;
    int maxSum = sum;
    for (int i = k; i < arr.length - k + 1; i++) {
      sum += arr[i] - arr[i - k];
      minSum = Math.min(minSum, sum);
      maxSum = Math.max(maxSum, sum);
    }
    return (double) (maxSum - minSum) / k;
  }
```","```python
def find_max_min_avg_difference(arr, K):
  n = len(arr)
  sum_subarray = sum(arr[:K])
  min_sum = sum_subarray
  max_sum = sum_subarray
  for i in range(K, n - K + 1):
    sum_subarray += arr[i] - arr[i - K]
    min_sum = min(min_sum, sum_subarray)
    max_sum = max(max_sum, sum_subarray)
  return (max_sum / K) - (min_sum / K)
```"
